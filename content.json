[{"title":"","date":"2016-03-20T14:24:54.000Z","path":"2016/03/20/ObjectMapper框架解析/","text":"ObjectMapper框架解析 ObjectMapper是一个用Swift编写的框架，它使你可以很容易地将你的模型对象（类和结构）转换成JSON。 GitHub地址如下:https://github.com/Hearst-DD/ObjectMapper objectMapper 两个协议文件(Mappleable 和 ImmutableMapple),是其他一切的基础 map文件 主要是用来匹配json字符和模型 Mapper文件是转换模型的逻辑文件,里面各种映射逻辑 operators 文件是操作符定义的文件,将模型和jsonvalue关联的地方 toJson 和 fromJson 文件是转换的过程中需要做的工作 transform 转成模型的具体类型的转换 #Mappable和ImmutableMapple文件1.文件中主要是两个必须实现的协议方法,以及协议的扩展,协议的扩展中的方法也可以直接调用转换成模型.2.模型遵守协议的时候一定要搞清楚需要模型中的变量是变量还是常量.如果是常量的话,然后继承不同的协议,进行不同的处理. 1234567891011struct Struct &#123; let prop1: String let prop2: Int&#125;extension Struct: ImmutableMappable &#123; init(map: Map) throws &#123; prop1 = try map.value(\"prop1\") prop2 = try map.value(\"prop2\") &#125; &#125; Mapper文件 这个方法是跟外界接触的方法,主要分为两大部分: 将[String:Any]转为模型T,还有就是把T转为json.主要说一下将json转化为模型. 将一个json串转化成的value给一个已经存在的模型对象赋值还是直接创建一个新的模型,对新的模型赋值.主要讲一下给一个新的模型赋值的例子 方法例子: 12345678//直接将json中得到的value赋值给这个已经存在的objectpublic func map(JSONObject: Any?, toObject object: N) -&gt; N&#123; &#125;// 重新创建一个模型,然后将json的value赋值给这个模型public func map(JSONObject: Any?) -&gt; N?&#123; &#125; ##json数据处理 1.map可以将json字符串转换成相应的字典或者数组格式,然后再次转换成相应的模型.格式对应的模型总结如下: [String:Any] -&gt; T,[[String:Any]] -&gt; [T],[String:[string:Any]] -&gt; [String:T],[String:[[String:Any]]] -&gt; [String:[T]],[[[string:Any]]] -&gt; [[T]] 2.不管这些格式多么复杂,都是通过遍历等各种方法得到最终核心[String:Any]这个格式,然后变成T.所以可以看看这个方法是怎么写的: 1234567891011121314151617181920212223242526272829303132// 对于新创建一个模型public func map(JSON: [String: Any]) -&gt; N? &#123; let map = Map(mappingType: .fromJSON, JSON: JSON, context: context, shouldIncludeNilValues: shouldIncludeNilValues) // N 是遵循了StaticMappable协议的 if let klass = N.self as? StaticMappable.Type &#123; if var object = klass.objectForMapping(map: map) as? N &#123; object.mapping(map: map) return object &#125; &#125; else if let klass = N.self as? Mappable.Type &#123; // Check if object is Mappable if var object = klass.init(map: map) as? N &#123; object.mapping(map: map) return object &#125; &#125; else if N.self is ImmutableMappable.Type &#123; // Check if object is ImmutableMappable assert(false, \"'ImmutableMappable' type requires throwing version of function \\(#function) - use 'try' before \\(#function)\") &#125; else &#123; // Ensure BaseMappable is not implemented directly assert(false, \"BaseMappable should not be implemented directly. Please implement Mappable, StaticMappable or ImmutableMappable\") &#125; return nil&#125; 对于上面一段代码主要是逻辑是: 创建一个map实例对象. 看一下模型 T 遵守的协议是哪个,然后创建模型实例并且调用协议中的方法 Map文件1.map文件最主要搞明白几个主要的变量和subscript方法:JSON变量是mapper文件中传递过来带有json值得变量.isKeyPresent如果是true,则可以将其赋值给对应的模型变量.currentValue存放模型变量的值currentKey是实例对象map中括号中的key值.keyIsNested是key值是否被包裹着,例如a.b就是被包裹着toObject是否映射到一个已经存在的模型上. 重写subscript()方法就可以让自定义的实例变量也可以通过像字典那样,可以拥有key值.我们还可以给类、结构、枚举等自定义下标（subscript）。 12345678//参数不可以是inout类型参数，且参数不能有默认值// 可以只实现get方法,或者set和get方法同时实现subscript(参数1，参数2...)-&gt;返回值&#123; get&#123; &#125; set(newValue)&#123; &#125;&#125; 123456789101112131415// 例子 subscript(requestedMeal : MealTime) -&gt; String &#123; get &#123; if let thisMeal = meals[requestedMeal] &#123; return thisMeal &#125; else &#123; return \"Ramen\" &#125; &#125; set &#123; meals[requestedMeal] = newValue &#125;&#125; ** 其中最主要的方法是下面这个: 12345678910111213141516171819202122232425262728293031public subscript(key: String, nested nested: Bool, delimiter delimiter: String, ignoreNil ignoreNil: Bool) -&gt; Map &#123; // save key and value associated to it currentKey = key keyIsNested = nested nestedKeyDelimiter = delimiter if mappingType == .fromJSON &#123; // check if a value exists for the current key // do this pre-check for performance reasons if nested == false &#123; let object = JSON[key] let isNSNull = object is NSNull // 判断是不是null isKeyPresent = isNSNull ? true : object != nil currentValue = isNSNull ? nil : object &#125; else &#123; // break down the components of the key that are separated by . (isKeyPresent, currentValue) = valueFor(ArraySlice(key.components(separatedBy: delimiter)), dictionary: JSON) &#125; // update isKeyPresent if ignoreNil is true if ignoreNil &amp;&amp; currentValue == nil &#123; isKeyPresent = false &#125; &#125; return self&#125; 主要逻辑是: 通过key或者去JSON字典中值,判断是不是nil或者NULL 如果key被包裹着,然后拆开获取JSON中的value值 Operators文件 Swift可以自定义运算符。自定义的运算符可以在全局使用。需要使用operator关键字。使用prefix, infix or postfix标记运算符使用的位置。(另外swift还可以对结构体.类重载已经存在运算符,在全局使用) 文件中对不同的参数进行了完备的定义.兼顾各种情况. 1234567891011121314151617181920212223242526272829这里有三个步骤去定义一个自定义操作符：1.命名你的运算符 例如:&gt;&gt;&gt;2.选择一种类型:一元,二元,三元 例如:一元关键字 : prefix or postfix,二元或者三元 :infix.3.设置它的优先级和结合性:associativity和优先级precedence。associativity有三个值：left, right, none,默认是none。precedence默认值是：100。可以默认不写 infix operator &gt;&gt;&gt; &#123;// 有默认值,可以不写associativity left precedence 140 # objectMapper1. 两个协议文件**(Mappleable 和 ImmutableMapple)**,是其他一切的基础2. map文件 主要是用来匹配json字符和模型3. Mapper文件是转换模型的逻辑文件,里面各种映射逻辑4. operators 文件是操作符定义的文件,将模型和jsonvalue关联的地方5. toJson 和 fromJson 文件是转换的过程中需要做的工作6. transform 转成模型的具体类型的转换 ##Mappable和ImmutableMapple文件1.文件中主要是两个必须实现的协议方法,以及协议的扩展,协议的扩展中的方法也可以直接调用转换成模型.2.模型遵守协议的时候一定要搞清楚需要模型中的变量是变量还是常量.如果是常量的话,然后继承不同的协议,进行不同的处理. struct Struct &#123; let prop1: String let prop2: Int&#125;extension Struct: ImmutableMappable &#123; init(map: Map) throws &#123; prop1 = try map.value(\"prop1\") prop2 = try map.value(\"prop2\") Mapper文件这个方法是跟外界接触的方法,主要分为两大部分: 将json[String:Any]转为模型T,还有就是把T转为json.主要说一下将json转化为模型. 将一个json串转化成的value给一个已经存在的模型对象赋值还是直接创建一个新的模型,对新的模型赋值.主要讲一下给一个新的模型赋值的例子方法例子: 12345678//直接将json中得到的value赋值给这个已经存在的objectpublic func map(JSONObject: Any?, toObject object: N) -&gt; N&#123; &#125;// 重新创建一个模型,然后将json的value赋值给这个模型public func map(JSONObject: Any?) -&gt; N?&#123; &#125; json数据处理1.map可以将json字符串转换成相应的字典或者数组格式,然后再次转换成相应的模型.格式对应的模型总结如下:[String:Any] -&gt; T,[[String:Any]] -&gt; [T],[String:[string:Any]] -&gt; [String:T],[String:[[String:Any]]] -&gt; [String:[T]],[[[string:Any]]] -&gt; [[T]] 2.不管这些格式多么复杂,都是通过遍历等各种方法得到最终核心[String:Any]这个格式,然后变成T.所以可以看看这个方法是怎么写的: 123456789101112131415161718192021222324252627// 对于新创建一个模型public func map(JSON: [String: Any]) -&gt; N? &#123; let map = Map(mappingType: .fromJSON, JSON: JSON, context: context, shouldIncludeNilValues: shouldIncludeNilValues)// N 是遵循了StaticMappable协议的if let klass = N.self as? StaticMappable.Type &#123; if var object = klass.objectForMapping(map: map) as? N &#123; object.mapping(map: map) return object &#125;&#125; else if let klass = N.self as? Mappable.Type &#123; // Check if object is Mappable if var object = klass.init(map: map) as? N &#123; object.mapping(map: map) return object &#125;&#125; else if N.self is ImmutableMappable.Type &#123; // Check if object is ImmutableMappable assert(false, \"'ImmutableMappable' type requires throwing version of function \\(#function) - use 'try' before \\(#function)\")&#125; else &#123; // Ensure BaseMappable is not implemented directly assert(false, \"BaseMappable should not be implemented directly. Please implement Mappable, StaticMappable or ImmutableMappable\")&#125; return nil&#125; 对于上面一段代码主要是逻辑是: 创建一个map实例对象. 看一下模型T遵守的协议是哪个,然后创建模型实例并且调用协议中的方法 Map文件1.map文件最主要搞明白几个主要的变量和subscript方法:JSON变量是mapper文件中传递过来带有json值得变量.isKeyPresent如果是true,则可以将其赋值给对应的模型变量.currentValue存放模型变量的值currentKey是实例对象map中括号中的key值.keyIsNested是key值是否被包裹着,例如a.b就是被包裹着toObject是否映射到一个已经存在的模型上. 重写subscript()方法就可以让自定义的实例变量也可以通过像字典那样,可以拥有key值.我们还可以给类、结构、枚举等自定义下标（subscript）。 12345678910111213141516171819202122232425262728//参数不可以是inout类型参数，且参数不能有默认值// 可以只实现get方法,或者set和get方法同时实现subscript(参数1，参数2...)-&gt;返回值&#123;get&#123;&#125;set(newValue)&#123;&#125;&#125; // 例子subscript(requestedMeal : MealTime) -&gt; String&#123;get&#123; if let thisMeal = meals[requestedMeal] &#123; return thisMeal &#125; else &#123; return \"Ramen\" &#125;&#125;set&#123; meals[requestedMeal] = newValue&#125;&#125; ** 其中最主要的方法是下面这个: 12345678910111213141516171819202122232425262728293031public subscript(key: String, nested nested: Bool, delimiter delimiter: String, ignoreNil ignoreNil: Bool) -&gt; Map &#123; // save key and value associated to it currentKey = key keyIsNested = nested nestedKeyDelimiter = delimiter if mappingType == .fromJSON &#123; // check if a value exists for the current key // do this pre-check for performance reasons if nested == false &#123; let object = JSON[key] let isNSNull = object is NSNull // 判断是不是null isKeyPresent = isNSNull ? true : object != nil currentValue = isNSNull ? nil : object &#125; else &#123; // break down the components of the key that are separated by . (isKeyPresent, currentValue) = valueFor(ArraySlice(key.components(separatedBy: delimiter)), dictionary: JSON) &#125; // update isKeyPresent if ignoreNil is true if ignoreNil &amp;&amp; currentValue == nil &#123; isKeyPresent = false &#125; &#125; return self&#125; 主要逻辑是: 通过key或者去JSON字典中值,判断是不是nil或者NULL 如果key被包裹着,然后拆开获取JSON中的value值 Operators文件 Swift可以自定义运算符。自定义的运算符可以在全局使用。需要使用operator关键字。使用prefix, infix or postfix标记运算符使用的位置。(另外swift还可以对结构体.类重载已经存在运算符,在全局使用) 文件中对不同的参数进行了完备的定义.兼顾各种情况. 1234567891011121314这里有三个步骤去定义一个自定义操作符：1.命名你的运算符 例如:&gt;&gt;&gt;2.选择一种类型:一元,二元,三元 例如:一元关键字 : prefix or postfix,二元或者三元 :infix.3.设置它的优先级和结合性:associativity和优先级precedence。associativity有三个值：left, right, none,默认是none。precedence默认值是：100。可以默认不写infix operator &gt;&gt;&gt; &#123;// 有默认值,可以不写associativity left precedence 140 &#125;func +- (left: Int, right: Int) -&gt; Int &#123; return 111&#125; 暂时写这些捋顺一下这个源码的逻辑.","tags":[]}]