[{"title":"","date":"2017-01-10T06:30:46.000Z","path":"2017/01/10/SDWebImage的阅读笔记/","text":"SDWebImage的阅读笔记最近，将SDwebImage源码从头到尾敲了一遍，学习到了很多东西。下面放一张SDWebImage的结构图，也就说UML类图 从图中我们可以看到，SDWebImage的核心为SDWebImageManager，我们通常所调用的UImageView(Webcache)和UIButton(WebCache)实际上是依赖于SDWebimageManager的，而SDWebImage真正的核心功能缓存和下载并没有直接相关联，它们是通过SDWebImageManager进行交流的。也就说SDWebImageManager调用了下载，下载完成后SDWebImageManager又调用了缓存的接口。而从UML图中我们可以看到，SDWebImageManager是由SDImageCahce和SDWebimageDownload聚合而成的。在这里简单的解释一下聚合的概念：SDWebImageManager包含SDImageCache和SDwebImageDownloader，但是后两者不是前者的组成部分，简单地说就是后两者不是前者的属性 所以我把SDWebimage分为几个模块： 1.核心模块：SDWebImageManager，负责了各个模块之间通信，相当于一个中介者 上面已经说了，请求和缓存是不能直接通信的，SDWebimage也不是直接在downloader里面进行缓存的，它们之间的通信是通过Manager来管理的，这样一来，我们在上层调用的时候，只需要调用manager的请求方法就可以直接完成请求和缓存的两种操作，这样降低了downloader和cache的耦合性。与此同时，如果我们不需要进行缓存的话，我们可以直接调downloader的方法(当然不需要这么做，调用模块已经提供了忽略缓存的参数，只需要设置参数即可) 2.上层调用模块：UImageView(Webcache)、UIButton(WebCache)等，我们通常直接使用的部分 这个模块层级比较高，我们也常用，就简单述说几个方法的差别吧，以UIImageView(WebCache)为例 3.缓存模块，将图片异步地存入硬盘或者内存，将图片异步从内存或者硬盘中读出，缓存的清理。 这是个核心功能，没有它，体验上差了不少。 SDImageCache是以url做为key存入内存或者硬盘的，但是有时候把url传为string型，xcode是不警告的，所以SDWebimage做了一些处理。 在左图中我们可以看到，SDwebImage设置缓存有效时间即:maxCacheAge，默认为一周；最大缓存大小即:maxCacheSize，这个是很有意思的，SDWebImage不只通过它限制了缓存的大小，还通过它去删除比较旧的，但又未失效的缓存的；是否将缓存存入内存，shouldCacheImagesInMemory；是否禁止存入iCould，shouldDisableiCould，没想到吧，SDwebImage可以直接把下载好的图片存入iCould吧，不过谁需要啊。 右图是具体实现，queryDiskCacheForkey是在每次缓存的时候都需要调用的方法，它是用来检查当前url对应的缓存是否存在，如果存在的话通过回调的参数通知manger不进行下载了，同时也不进行缓存了，同时，移除当前请求队列，防止再次进行请求。这个就是SDWebimage说的:&quot;A guarantee that the same URL won&apos;t be downloaded several times&quot; 关于 @sychoronize ：相当于一个线程锁，防止其它想成对其修饰的对象进行修改 关于缓存的文件：无论是从网络请求下来的还是缓存到本地的图片，都是已经经过压缩转码的图片文件，而在设备上进行渲染的，不能这些压缩后的文件，而是位图文件。所以设备在进行图片渲染的时候，是需要先将图片解码转换位图文件，再进行渲染，而在iOS设备中，这个过程是在主线程进行的，而SDWebimage将这个过程迁移到了子线程，这提高了性能。 在将图片存入硬盘之前，如果调用者未做特殊处理，SDwebImage也会将图片存入内存作为内存缓存，内存的速度是要优于硬盘的，但是这样会有个问题，请求的图片越多，消耗的内存也就越大，直到开始报内存警告。SDWebImage监控了这个内存警告，若开始报内存警告，就进行内存清理。而图像作为文件，进行硬盘缓存的时候就是把图像文件存入到给定的沙盒目录下。 4.请求模块，设置请求线程，取消请求，请求完成回调。 从SDWebImgeDownloader中的图可以看到，着了设置了是否进行图片解码，获取图片当前请求数量，请求超时，执行顺序(先进先出或者先进后出)，url证书，当前最大下载数量的属性。这些属性很清晰明确，具备充分的自注释性。那么，现在就展示一些这些属性的默认值： 而实际上，SDWebImgeDownloader只是一个请求的入口，真正处理数据请求的是在继承于NSOperation的SDWebImgeDownloaderOperation。SDWebImgeDownloader把设置好的request对象和session对象传递给后者，待后者在其当前线程内请求完成，接收其请求完成的回调内容。 在请求完成的时候，SDWebimage对图像进行了处理，需要展示的时候，会将图片数据在子线程转换成相应的位图数据，转换完成，回到主线程进行渲染。当图片的尺寸和给定的尺寸不一致的时候，SDwebImage会根据相应的比例进行缩放，超过当前尺寸，就按比例进行裁剪；当小于当前尺寸，就按比例放大。 5.预取模块","tags":[]},{"title":"","date":"2017-01-09T14:34:54.000Z","path":"2017/01/09/NSPredicate的一些简单用法/","text":"NSPredicate的一些简单用法NSPredicate可以支持数据库查询,平时的一些数组查询之类也用这个方法,以下是一些总结 ####格式字符串的一些基本写法1&gt; @&quot;attributeName == %@&quot; 就是属性名字等于某个值2&gt;@&quot;%K == %@&quot;,将属性名字变为%K,增加拓展性. 12345// 1.第一种写法,右边值如果是字符串,可以用单引号表示NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;nickName == &apos;小明&apos;&quot;,];// 2.第二种写法,%K的K必须大写,不能用%@代替NSString *name = @&quot;cat.nickName&quot;;NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;%K == %@&quot;,name,@&quot;小明&quot;]; ####左右两边基本的比较操作符号1.=,==左边表达式等于右手表达式 2.&gt;=,=&gt;左边表达式大于或等于右边表达式 3.&lt;=,=&lt;左变表达式小于或等于右边表达式 4&gt; 或者 &lt; 5.!=,&lt;&gt;左边表达式不等于右边表达式 6.IN左边表达式必须出现在右边表达式指定的集合中。即name IN {&#39;Milk&#39;，&#39;Eggs&#39;，&#39;Bread&#39;} 7.BETWEEN左边表达式在右边表达式之间或等于右边表达式。即1 {0，33}之间。如果你的左边表达式是0或33，也是真的 8.以下是字符串表达式的比较符号(1)BEGINSWITH左边表达式以右边表达式开始(2)CONTAINS左边表达式包含表达式(3)ENDSWITH左边表达式以右边表达式结束(4)LIKE左边表达式等于右手表达式：？和*作为通配符，其中？匹配1个字符，*匹配0个或多个字符(5)MATCHES左边表达式等于右边表达式使用正则表达式样式比较 ####两个表达式的逻辑符号1.AND,&amp;&amp;,逻辑AND 2.OR,||逻辑或 3.NOT,!逻辑NOT ###数组的操作的一些特性1.对数组中数字集合的一些操作(1)@avg返回collection中对象平均值,以NSNumber的形式返回(2)@count集合中总共的个数,,以NSNumber的形式返回(3)``@min1(4)使用``valueForKeyPath``返回相应的结果 // 处理大量数字组成的数组的时候可以使用,可以方便的进行判断.然后进行下一步操作NSArray array = @[@(30),@(40),@(50)];NSPredicate pre = [NSPredicate// 最小值是不是大于30predicateWithFormat:@”@min.intValue &gt; 30”];BOOL ok = [pre evaluateWithObject:array];// 可以使用key == value 来去的最小,最大,总和,平均等值.并且返回一个nsnumer类型的值NSNumber *a = [array11 valueForKeyPath:@”@min.intValue”];NSLog(@”%d”,a.intValue);12342.**数组中存放对象的一些操作**(1) ``@distinctUnionOfObjects``返回一个数组,这个数组是由操作符``.``右侧属性的值组成的,并且重复的值被过滤掉.``@unionOfObjects``逻辑和``@distinctUnionOfObjects``相同,但是重复的值没有被过滤掉(2)``@distinctUnionOfArrays``返回的是数组,但是将数组中的数组元素拆分到一个数组里面,逻辑同上面,不包括重复值``@unionOfArrays``包括重复值(3)返回值都是使用``valueForKeyPath``取到 CatModal cat1 = [[CatModal alloc] initWithNickName:@”小明” withWeight:30.1];CatModal cat2 = [[CatModal alloc] initWithNickName:@”mimi” withWeight:33.1]; CatModal cat4 = [[CatModal alloc] initWithNickName:@”fuu” withWeight:35.1];CatModal cat5 = [[CatModal alloc] initWithNickName:@”err” withWeight:35.1]; TestModal test1 = [[TestModal alloc] initWithName:@”小七” withHeith:90.1 withCat:cat1];TestModal test2 = [[TestModal alloc] initWithName:@”小七” withHeith:80.1 withCat:cat2];withHeith:60.1 withCat:cat3]; TestModal *test4 = [[TestModal alloc] initWithName:@”小七” withHeith:60.1 withCat:cat4]; TestModal *test5 = [[TestModal alloc] initWithName:@”小七” withHeith:60.1 withCat:cat5]; NSArray array = @[test2,test1];NSArray array2 = @[test4,test5];NSArray *arrayofarray = @[array,array2]; NSArray array11111 = [array valueForKeyPath:@”@distinctUnionOfObjects.cat”];for (CatModal cat in array11111) { NSLog(@”%@\\n”,cat.nickName);[小明,mini]} NSArray array1 = [arrayofarray valueForKeyPath:@”@distinctUnionOfArrays.cat”];for (CatModal cat in array1) { NSLog(@”%@\\n”,cat.nickName); // [fuu 小明 mimi err],并不是数组中的数组的形式}1234567893.**数组中的``SELF``指什么**数组中``SELF``指的是数组中包含的每一个对象4.**对数组中具体的某个位置进行操作查询**``array[index]``指定数组中指定索引处的元素进行匹配操作``array[FIRST]````array[LAST]````array[SIZE]``分别表示对数组第一个,最后一个,数组总数进行操作 CatModal cat1 = [[CatModal alloc] initWithNickName:@”小明” withWeight:30.1];CatModal cat2 = [[CatModal alloc] initWithNickName:@”mimi” withWeight:33.1];CatModal cat3 = [[CatModal alloc] initWithNickName:@”miru” withWeight:35.1];CatModal cat4 = [[CatModal alloc] initWithNickName:@”fuu” withWeight:35.1];CatModal cat5 = [[CatModal alloc] initWithNickName:@”err” withWeight:35.1];CatModal cat6 = [[CatModal alloc] initWithNickName:@”ooo” withWeight:35.1];TestModal *test1 = [[TestModal alloc] initWithName:@”小七” withHeith:90.1 withCat:cat1];test1.catsArray = @[cat2,cat1]; TestModal test2 = [[TestModal alloc] initWithName:@”小七” withHeith:80.1 withCat:cat2];test2.catsArray = @[cat4];TestModal test3 = [[TestModal alloc] initWithName:@”小七” withHeith:60.1 withCat:cat3];test3.catsArray = @[cat5,cat6]; NSArray array = @[test2,test1,test3];NSPredicate pre = [NSPredicate predicateWithFormat:@”catsArray[SIZE] == 1”];NSArray *array1 = [array filteredArrayUsingPredicate:pre];NSLog(@”11111%@”,array1);12345675.**对数组中的数组进行操作的时候查询关键字,只能用在数组,一对多的形式**``ANY或者SOME``对数组中的数组进行查询,只要有符合条件的,就返回``TRUE````ALL``数组中所有都符合条件的时候才会返回。``NONE``都不正确的时候才返回true。 CatModal cat1 = [[CatModal alloc] initWithNickName:@”小明” withWeight:30.1];CatModal cat2 = [[CatModal alloc] initWithNickName:@”mimi” withWeight:33.1];CatModal cat3 = [[CatModal alloc] initWithNickName:@”miru” withWeight:35.1];TestModal test1 = [[TestModal alloc] initWithName:@”小七” withHeith:90.1 withCat:cat1];test1.catsArray = @[cat2,cat3]; TestModal test2 = [[TestModal alloc] initWithName:@”小七” withHeith:80.1 withCat:cat1];test2.catsArray = @[cat2];TestModal test3 = [[TestModal alloc] initWithName:@”小七” withHeith:60.1 withCat:cat1];test3.catsArray = @[cat1,cat3];NSArray array = @[test2,test1,test3];// ALL ANY SOME 用于NSArray NSSet .ANY SOME是数组中有真的就返回. ALL是数组中全部是真的才返回NSPredicate pre = [NSPredicate predicateWithFormat:@”ALL catsArray.weight &gt; 31.0”];NSArray *array1 = [array filteredArrayUsingPredicate:pre];NSLog(@”%@”,array1);1234567891011注意:1.查询过程中使用``department.name``这样的形式比较耗费性能.尽量不要使用.``department == %@``这样的形式查询效率最高.2. ``@&quot;firstName beginswith[cd] &apos;Matt&apos; AND (ANY directreports.paygrade &lt;= 7)&quot;`` 比下面这种形式更高效 ``@&quot;(ANY directreports.paygrade &lt;= 7) AND (firstName beginswith[cd] &apos;Matt&apos;)&quot;``3.使用predicate的类必须支持key-value-coding ,这样才可以在其他地方使用. 实际上使用predicate 也是根据key-value这样的形式来查询的.4.``[c],[d],[cd]``可以加到比较符号的后面表示不区分大小写，不区分发音符号，两这个都不区分5.如果想要匹配null或者nil值得时候,需要额外增加一条对比 predicate = [NSPredicate predicateWithFormat:@”(firstName == %@) || (firstName == nil)”];filteredArray = [array filteredArrayUsingPredicate:predicate];NSLog(@”%@”, filteredArray);```","tags":[]},{"title":"","date":"2016-03-20T14:24:54.000Z","path":"2016/03/20/ObjectMapper框架解析/","text":"ObjectMapper框架解析 ObjectMapper是一个用Swift编写的框架，它使你可以很容易地将你的模型对象（类和结构）转换成JSON。 GitHub地址如下:https://github.com/Hearst-DD/ObjectMapper objectMapper 两个协议文件(Mappleable 和 ImmutableMapple),是其他一切的基础 map文件 主要是用来匹配json字符和模型 Mapper文件是转换模型的逻辑文件,里面各种映射逻辑 operators 文件是操作符定义的文件,将模型和jsonvalue关联的地方 toJson 和 fromJson 文件是转换的过程中需要做的工作 transform 转成模型的具体类型的转换 #Mappable和ImmutableMapple文件1.文件中主要是两个必须实现的协议方法,以及协议的扩展,协议的扩展中的方法也可以直接调用转换成模型.2.模型遵守协议的时候一定要搞清楚需要模型中的变量是变量还是常量.如果是常量的话,然后继承不同的协议,进行不同的处理. 1234567891011struct Struct &#123; let prop1: String let prop2: Int&#125;extension Struct: ImmutableMappable &#123; init(map: Map) throws &#123; prop1 = try map.value(\"prop1\") prop2 = try map.value(\"prop2\") &#125; &#125; Mapper文件 这个方法是跟外界接触的方法,主要分为两大部分: 将[String:Any]转为模型T,还有就是把T转为json.主要说一下将json转化为模型. 将一个json串转化成的value给一个已经存在的模型对象赋值还是直接创建一个新的模型,对新的模型赋值.主要讲一下给一个新的模型赋值的例子 方法例子: 12345678//直接将json中得到的value赋值给这个已经存在的objectpublic func map(JSONObject: Any?, toObject object: N) -&gt; N&#123; &#125;// 重新创建一个模型,然后将json的value赋值给这个模型public func map(JSONObject: Any?) -&gt; N?&#123; &#125; ##json数据处理 1.map可以将json字符串转换成相应的字典或者数组格式,然后再次转换成相应的模型.格式对应的模型总结如下: [String:Any] -&gt; T,[[String:Any]] -&gt; [T],[String:[string:Any]] -&gt; [String:T],[String:[[String:Any]]] -&gt; [String:[T]],[[[string:Any]]] -&gt; [[T]] 2.不管这些格式多么复杂,都是通过遍历等各种方法得到最终核心[String:Any]这个格式,然后变成T.所以可以看看这个方法是怎么写的: 1234567891011121314151617181920212223242526272829303132// 对于新创建一个模型public func map(JSON: [String: Any]) -&gt; N? &#123; let map = Map(mappingType: .fromJSON, JSON: JSON, context: context, shouldIncludeNilValues: shouldIncludeNilValues) // N 是遵循了StaticMappable协议的 if let klass = N.self as? StaticMappable.Type &#123; if var object = klass.objectForMapping(map: map) as? N &#123; object.mapping(map: map) return object &#125; &#125; else if let klass = N.self as? Mappable.Type &#123; // Check if object is Mappable if var object = klass.init(map: map) as? N &#123; object.mapping(map: map) return object &#125; &#125; else if N.self is ImmutableMappable.Type &#123; // Check if object is ImmutableMappable assert(false, \"'ImmutableMappable' type requires throwing version of function \\(#function) - use 'try' before \\(#function)\") &#125; else &#123; // Ensure BaseMappable is not implemented directly assert(false, \"BaseMappable should not be implemented directly. Please implement Mappable, StaticMappable or ImmutableMappable\") &#125; return nil&#125; 对于上面一段代码主要是逻辑是: 创建一个map实例对象. 看一下模型 T 遵守的协议是哪个,然后创建模型实例并且调用协议中的方法 Map文件1.map文件最主要搞明白几个主要的变量和subscript方法:JSON变量是mapper文件中传递过来带有json值得变量.isKeyPresent如果是true,则可以将其赋值给对应的模型变量.currentValue存放模型变量的值currentKey是实例对象map中括号中的key值.keyIsNested是key值是否被包裹着,例如a.b就是被包裹着toObject是否映射到一个已经存在的模型上. 重写subscript()方法就可以让自定义的实例变量也可以通过像字典那样,可以拥有key值.我们还可以给类、结构、枚举等自定义下标（subscript）。 12345678//参数不可以是inout类型参数，且参数不能有默认值// 可以只实现get方法,或者set和get方法同时实现subscript(参数1，参数2...)-&gt;返回值&#123; get&#123; &#125; set(newValue)&#123; &#125;&#125; 123456789101112131415// 例子 subscript(requestedMeal : MealTime) -&gt; String &#123; get &#123; if let thisMeal = meals[requestedMeal] &#123; return thisMeal &#125; else &#123; return \"Ramen\" &#125; &#125; set &#123; meals[requestedMeal] = newValue &#125;&#125; ** 其中最主要的方法是下面这个: 12345678910111213141516171819202122232425262728293031public subscript(key: String, nested nested: Bool, delimiter delimiter: String, ignoreNil ignoreNil: Bool) -&gt; Map &#123; // save key and value associated to it currentKey = key keyIsNested = nested nestedKeyDelimiter = delimiter if mappingType == .fromJSON &#123; // check if a value exists for the current key // do this pre-check for performance reasons if nested == false &#123; let object = JSON[key] let isNSNull = object is NSNull // 判断是不是null isKeyPresent = isNSNull ? true : object != nil currentValue = isNSNull ? nil : object &#125; else &#123; // break down the components of the key that are separated by . (isKeyPresent, currentValue) = valueFor(ArraySlice(key.components(separatedBy: delimiter)), dictionary: JSON) &#125; // update isKeyPresent if ignoreNil is true if ignoreNil &amp;&amp; currentValue == nil &#123; isKeyPresent = false &#125; &#125; return self&#125; 主要逻辑是: 通过key或者去JSON字典中值,判断是不是nil或者NULL 如果key被包裹着,然后拆开获取JSON中的value值 Operators文件 Swift可以自定义运算符。自定义的运算符可以在全局使用。需要使用operator关键字。使用prefix, infix or postfix标记运算符使用的位置。(另外swift还可以对结构体.类重载已经存在运算符,在全局使用) 文件中对不同的参数进行了完备的定义.兼顾各种情况. 1234567891011121314151617181920212223242526272829这里有三个步骤去定义一个自定义操作符：1.命名你的运算符 例如:&gt;&gt;&gt;2.选择一种类型:一元,二元,三元 例如:一元关键字 : prefix or postfix,二元或者三元 :infix.3.设置它的优先级和结合性:associativity和优先级precedence。associativity有三个值：left, right, none,默认是none。precedence默认值是：100。可以默认不写 infix operator &gt;&gt;&gt; &#123;// 有默认值,可以不写associativity left precedence 140 # objectMapper1. 两个协议文件**(Mappleable 和 ImmutableMapple)**,是其他一切的基础2. map文件 主要是用来匹配json字符和模型3. Mapper文件是转换模型的逻辑文件,里面各种映射逻辑4. operators 文件是操作符定义的文件,将模型和jsonvalue关联的地方5. toJson 和 fromJson 文件是转换的过程中需要做的工作6. transform 转成模型的具体类型的转换 ##Mappable和ImmutableMapple文件1.文件中主要是两个必须实现的协议方法,以及协议的扩展,协议的扩展中的方法也可以直接调用转换成模型.2.模型遵守协议的时候一定要搞清楚需要模型中的变量是变量还是常量.如果是常量的话,然后继承不同的协议,进行不同的处理. struct Struct &#123; let prop1: String let prop2: Int&#125;extension Struct: ImmutableMappable &#123; init(map: Map) throws &#123; prop1 = try map.value(\"prop1\") prop2 = try map.value(\"prop2\") Mapper文件这个方法是跟外界接触的方法,主要分为两大部分: 将json[String:Any]转为模型T,还有就是把T转为json.主要说一下将json转化为模型. 将一个json串转化成的value给一个已经存在的模型对象赋值还是直接创建一个新的模型,对新的模型赋值.主要讲一下给一个新的模型赋值的例子方法例子: 12345678//直接将json中得到的value赋值给这个已经存在的objectpublic func map(JSONObject: Any?, toObject object: N) -&gt; N&#123; &#125;// 重新创建一个模型,然后将json的value赋值给这个模型public func map(JSONObject: Any?) -&gt; N?&#123; &#125; json数据处理1.map可以将json字符串转换成相应的字典或者数组格式,然后再次转换成相应的模型.格式对应的模型总结如下:[String:Any] -&gt; T,[[String:Any]] -&gt; [T],[String:[string:Any]] -&gt; [String:T],[String:[[String:Any]]] -&gt; [String:[T]],[[[string:Any]]] -&gt; [[T]] 2.不管这些格式多么复杂,都是通过遍历等各种方法得到最终核心[String:Any]这个格式,然后变成T.所以可以看看这个方法是怎么写的: 123456789101112131415161718192021222324252627// 对于新创建一个模型public func map(JSON: [String: Any]) -&gt; N? &#123; let map = Map(mappingType: .fromJSON, JSON: JSON, context: context, shouldIncludeNilValues: shouldIncludeNilValues)// N 是遵循了StaticMappable协议的if let klass = N.self as? StaticMappable.Type &#123; if var object = klass.objectForMapping(map: map) as? N &#123; object.mapping(map: map) return object &#125;&#125; else if let klass = N.self as? Mappable.Type &#123; // Check if object is Mappable if var object = klass.init(map: map) as? N &#123; object.mapping(map: map) return object &#125;&#125; else if N.self is ImmutableMappable.Type &#123; // Check if object is ImmutableMappable assert(false, \"'ImmutableMappable' type requires throwing version of function \\(#function) - use 'try' before \\(#function)\")&#125; else &#123; // Ensure BaseMappable is not implemented directly assert(false, \"BaseMappable should not be implemented directly. Please implement Mappable, StaticMappable or ImmutableMappable\")&#125; return nil&#125; 对于上面一段代码主要是逻辑是: 创建一个map实例对象. 看一下模型T遵守的协议是哪个,然后创建模型实例并且调用协议中的方法 Map文件1.map文件最主要搞明白几个主要的变量和subscript方法:JSON变量是mapper文件中传递过来带有json值得变量.isKeyPresent如果是true,则可以将其赋值给对应的模型变量.currentValue存放模型变量的值currentKey是实例对象map中括号中的key值.keyIsNested是key值是否被包裹着,例如a.b就是被包裹着toObject是否映射到一个已经存在的模型上. 重写subscript()方法就可以让自定义的实例变量也可以通过像字典那样,可以拥有key值.我们还可以给类、结构、枚举等自定义下标（subscript）。 12345678910111213141516171819202122232425262728//参数不可以是inout类型参数，且参数不能有默认值// 可以只实现get方法,或者set和get方法同时实现subscript(参数1，参数2...)-&gt;返回值&#123;get&#123;&#125;set(newValue)&#123;&#125;&#125; // 例子subscript(requestedMeal : MealTime) -&gt; String&#123;get&#123; if let thisMeal = meals[requestedMeal] &#123; return thisMeal &#125; else &#123; return \"Ramen\" &#125;&#125;set&#123; meals[requestedMeal] = newValue&#125;&#125; ** 其中最主要的方法是下面这个: 12345678910111213141516171819202122232425262728293031public subscript(key: String, nested nested: Bool, delimiter delimiter: String, ignoreNil ignoreNil: Bool) -&gt; Map &#123; // save key and value associated to it currentKey = key keyIsNested = nested nestedKeyDelimiter = delimiter if mappingType == .fromJSON &#123; // check if a value exists for the current key // do this pre-check for performance reasons if nested == false &#123; let object = JSON[key] let isNSNull = object is NSNull // 判断是不是null isKeyPresent = isNSNull ? true : object != nil currentValue = isNSNull ? nil : object &#125; else &#123; // break down the components of the key that are separated by . (isKeyPresent, currentValue) = valueFor(ArraySlice(key.components(separatedBy: delimiter)), dictionary: JSON) &#125; // update isKeyPresent if ignoreNil is true if ignoreNil &amp;&amp; currentValue == nil &#123; isKeyPresent = false &#125; &#125; return self&#125; 主要逻辑是: 通过key或者去JSON字典中值,判断是不是nil或者NULL 如果key被包裹着,然后拆开获取JSON中的value值 Operators文件 Swift可以自定义运算符。自定义的运算符可以在全局使用。需要使用operator关键字。使用prefix, infix or postfix标记运算符使用的位置。(另外swift还可以对结构体.类重载已经存在运算符,在全局使用) 文件中对不同的参数进行了完备的定义.兼顾各种情况. 1234567891011121314这里有三个步骤去定义一个自定义操作符：1.命名你的运算符 例如:&gt;&gt;&gt;2.选择一种类型:一元,二元,三元 例如:一元关键字 : prefix or postfix,二元或者三元 :infix.3.设置它的优先级和结合性:associativity和优先级precedence。associativity有三个值：left, right, none,默认是none。precedence默认值是：100。可以默认不写infix operator &gt;&gt;&gt; &#123;// 有默认值,可以不写associativity left precedence 140 &#125;func +- (left: Int, right: Int) -&gt; Int &#123; return 111&#125; 暂时写这些捋顺一下这个源码的逻辑.","tags":[]}]