[{"title":"iOS常用加密算法","date":"2017-06-07T06:46:23.000Z","path":"2017/06/07/iOS常用加密算法/","text":"对称加密[算法]在加密和解密时使用的是同一个秘钥；而[非对称加密算法]需要两个[密钥]来进行加密和解密，这两个秘钥是[公开密钥]（public key，简称公钥）和私有密钥（private key，简称私钥）。 DES加密（数据加密算法）AES加密（高级加密标准）替代DES加密 字节替代（SubBytes） 行移位（ShiftRows） 列混淆（MixColumns） 轮密钥加（AddRoundKey） 参考博客 http://www.mamicode.com/info-detail-514466.html MD5加密（信息-摘要算法）MD5功能： 输入任意长度的信息，经过处理，输出为128位的信息（数字指纹）； 不同的输入得到的不同的结果（唯一性）； 根据128位的输出结果不可能反推出输入的信息（不可逆）； MD5用途 1、防止被篡改： 2、比如发送一个电子文档，发送前，我先得到MD5的输出结果a。然后在对方收到电子文档后，对方也得到一个MD5的输出结果b。如果a与b一样就代表中途未被篡改。2）比如我提供文件下载，为了防止不法分子在安装程序中添加木马，我可以在网站上公布由安装文件得到的MD5输出结果。 3、SVN在检测文件是否在CheckOut后被修改过，也是用到了MD5. SHA加密（安全散列算法） 接收一段明文，然后以一种不可逆的方式将它转换成一段密文，也可以简单的理解为取一串输入码，并把这个信息转化为长度较短、位数固定的输出序列即散列值（也称为信息认证代码）的过程。适用于长度不超过2^64 二进制位的消息。根据长度小于2^64 位的消息，它会产生一个160位的信息摘要 优点 不可逆——（无法推出任何部分的原始信息） 防冲突—— （任何输入的信息的变化，哪怕一位，都将导致结果变化） 具有良好的雪崩效应——（找不到具有相同散列结果的两条信息） RSA加密 与对称加密[算法]不同，[非对称加密算法]需要两个[密钥]：[公开密钥]（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的[密钥]，所以这种算法叫作[非对称加密算法]。 RSA加密原理RSA是常用的加密模式，其加密原理可用以下的例子进行简要的论述。 随机取两个质数 1234567891011121314P = 61;q = 53;N = P * Q = 3233;// E是1-n之间的一个随机的质数E = 17;// D是通过一系列数学运算得出的一个数字，// 运算方法后续会附上阮一峰老师的两篇文章链接// (N,D)(N,E)要满足可以互相解值运算// 假如(N,D)是公钥，（N,E）是私钥// 满足私钥加密，公钥解密或者反过来公钥加密，私钥解密。// 也要满足只知道（N，D）就想知道（N,E），那就要把N这个大的整数进行因数分解。// 因数分解只能使用暴力穷举，N越大，相应的也就越安全// 当 N 大到1024位或者2048位时，以目前的技术破解几乎不可能，所以很安全 附录阮一峰-RSA算法原理1阮一峰-RSA算法原理2","content":"<blockquote>\n<p>对称加密<code>[算法]</code>在加密和解密时使用的是同一个秘钥；而<code>[非对称加密算法]</code>需要两个<code>[密钥]</code>来进行加密和解密，这两个秘钥是<code>[公开密钥]</code>（public key，简称公钥）和私有密钥（private key，简称私钥）。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"DES加密（数据加密算法）\"><a href=\"#DES加密（数据加密算法）\" class=\"headerlink\" title=\"DES加密（数据加密算法）\"></a>DES加密（数据加密算法）</h3><h3 id=\"AES加密（高级加密标准）\"><a href=\"#AES加密（高级加密标准）\" class=\"headerlink\" title=\"AES加密（高级加密标准）\"></a>AES加密（高级加密标准）</h3><p>替代DES加密</p>\n<p><img src=\"http://images.cnitblog.com/blog2015/671127/201503/130035028553414.png\" alt=\"\"></p>\n<ul>\n<li>字节替代（SubBytes）</li>\n<li>行移位（ShiftRows）</li>\n<li>列混淆（MixColumns）</li>\n<li>轮密钥加（AddRoundKey）</li>\n</ul>\n<p>参考博客   <a href=\"http://www.mamicode.com/info-detail-514466.html\" target=\"_blank\" rel=\"external\">http://www.mamicode.com/info-detail-514466.html</a></p>\n<h3 id=\"MD5加密（信息-摘要算法）\"><a href=\"#MD5加密（信息-摘要算法）\" class=\"headerlink\" title=\"MD5加密（信息-摘要算法）\"></a>MD5加密（信息-摘要算法）</h3><h6 id=\"MD5功能：\"><a href=\"#MD5功能：\" class=\"headerlink\" title=\"MD5功能：\"></a>MD5功能：</h6><ul>\n<li>输入任意长度的信息，经过处理，输出为128位的信息（数字指纹）；</li>\n<li>不同的输入得到的不同的结果（唯一性）；</li>\n<li>根据128位的输出结果不可能反推出输入的信息（不可逆）；</li>\n</ul>\n<h6 id=\"MD5用途\"><a href=\"#MD5用途\" class=\"headerlink\" title=\"MD5用途\"></a>MD5用途</h6><ul>\n<li>1、防止被篡改：</li>\n<li>2、比如发送一个电子文档，发送前，我先得到MD5的输出结果a。然后在对方收到电子文档后，对方也得到一个MD5的输出结果b。如果a与b一样就代表中途未被篡改。2）比如我提供文件下载，为了防止不法分子在安装程序中添加木马，我可以在网站上公布由安装文件得到的MD5输出结果。</li>\n<li>3、SVN在检测文件是否在CheckOut后被修改过，也是用到了MD5. </li>\n</ul>\n<h3 id=\"SHA加密（安全散列算法）\"><a href=\"#SHA加密（安全散列算法）\" class=\"headerlink\" title=\"SHA加密（安全散列算法）\"></a>SHA加密（安全散列算法）</h3><blockquote>\n<p>接收一段明文，然后以一种不可逆的方式将它转换成一段密文，也可以简单的理解为取一串输入码，并把这个信息转化为长度较短、位数固定的输出序列即散列值（也称为信息认证代码）的过程。适用于长度不超过<br>2^64 二进制位的消息。根据长度小于2^64 位的消息，它会产生一个160位的信息摘要</p>\n</blockquote>\n<h6 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h6><ul>\n<li>不可逆——（无法推出任何部分的原始信息）</li>\n<li>防冲突—— （任何输入的信息的变化，哪怕一位，都将导致结果变化）</li>\n<li>具有良好的雪崩效应——（找不到具有相同散列结果的两条信息）</li>\n</ul>\n<h3 id=\"RSA加密\"><a href=\"#RSA加密\" class=\"headerlink\" title=\"RSA加密\"></a>RSA加密</h3><blockquote>\n<p>与对称加密[算法]不同，[非对称加密算法]需要两个[密钥]：<code>[公开密钥]（publickey）</code>和<code>私有密钥（privatekey）</code>。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为<code>加密</code>和<code>解密</code>使用的是两个不同的[密钥]，所以这种算法叫作<code>[非对称加密算法]</code>。</p>\n</blockquote>\n<h4 id=\"RSA加密原理\"><a href=\"#RSA加密原理\" class=\"headerlink\" title=\"RSA加密原理\"></a><code>RSA</code>加密原理</h4><p><code>RSA</code>是常用的加密模式，其加密原理可用以下的例子进行简要的论述。</p>\n<p>随机取两个质数</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">P = <span class=\"number\">61</span>;</div><div class=\"line\">q = <span class=\"number\">53</span>;</div><div class=\"line\">N = P * Q = <span class=\"number\">3233</span>;</div><div class=\"line\"><span class=\"comment\">// E是1-n之间的一个随机的质数</span></div><div class=\"line\">E = <span class=\"number\">17</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// D是通过一系列数学运算得出的一个数字，</span></div><div class=\"line\"><span class=\"comment\">// 运算方法后续会附上阮一峰老师的两篇文章链接</span></div><div class=\"line\"><span class=\"comment\">// (N,D)(N,E)要满足可以互相解值运算</span></div><div class=\"line\"><span class=\"comment\">// 假如(N,D)是公钥，（N,E）是私钥</span></div><div class=\"line\"><span class=\"comment\">// 满足私钥加密，公钥解密或者反过来公钥加密，私钥解密。</span></div><div class=\"line\"><span class=\"comment\">// 也要满足只知道（N，D）就想知道（N,E），那就要把N这个大的整数进行因数分解。</span></div><div class=\"line\"><span class=\"comment\">// 因数分解只能使用暴力穷举，N越大，相应的也就越安全</span></div><div class=\"line\"><span class=\"comment\">// 当 N 大到1024位或者2048位时，以目前的技术破解几乎不可能，所以很安全</span></div></pre></td></tr></table></figure>\n<h4 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h4><p><a href=\"http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html\" target=\"_blank\" rel=\"external\">阮一峰-RSA算法原理1</a><br><a href=\"http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html\" target=\"_blank\" rel=\"external\">阮一峰-RSA算法原理2</a></p>\n","excerpt":"对称加密[算法]在加密和解密时使用的是同一个秘钥；而[非对称加密算法]需要两个[密钥]来进行加密和解密，这两个秘钥是[公开密钥]（public key，简称公钥）和私有密钥（private key，简称私钥）。","categories":[],"tags":[]},{"title":"WWDC2016-Session413（介绍Xcode的使用技巧）","date":"2017-06-07T02:34:15.000Z","path":"2017/06/07/WWDC2016-Session413（介绍Xcode的使用技巧）/","text":"这一章节作为开发者工具的一部分，简单介绍了我们日常使用的开发工具 Xcode,虽然是我们每天都要使用的工具，但是通过这一个session还是收获了一些实用的小技巧。 其中包括以下这几个大的模块。 创建一个简单的应用并使其运行 运行单元测试并对Bug进行调试 审阅代码和提交 对Xcode进行相关配置 配置你的工程（configuring your project）像创建运行模块、简单的测试调试、以及代码的审阅和提交，在此处就不多叙述了，而在配置项目中，有几个很关键的概念需要弄明白 Project Target BuildSetting Schemes WorkSpaces Project根据官方文档的解释 ，Xcode的Project是我们构建一个或多个应用时所需的文件、资源、相关信息的主要仓库。一个Project包含构建一个应用的所有元素，同时管理着这些元素之间的关系。它可能包含一个或者多个Target,Target可以专门指定该如何构建产品。Project为项目中的所有Target都做了默认的设定。 Project 包含以下文件 引用源文件 源代码，包括头文件(.h)以及实现文件(.m)。 静态库、动态库。内部文件和外部文件。 资源文件。 图片文件。 用户交互的图形化界面(nib)。 分组被用来在导航栏中管理源文件 项目级构建配置(Schems)。 您可以为项目指定多个构建配置; 例如，您可能有一个项目的调试和发布构建设置。 目标文件(Targets) 每个指定的可用于调试或者单元测试的执行环境 TargetsProject管理Target Targets包含一组在Project或者WorkSpace中的指定该如何构建产品的说明文件。一个Target就构建了一个独立的Product. Target构建成产品会经历上图的几个步骤，具体看图即可 SchemesScheme就是构建的方案，例如，你可以自定规则Debug或者Release,来决定不同环境下的不同规则。 Build Settings 字面意思就是 编译设置，用于设置在编译过程中一些优先级、支持架构信息、优化的优先级、引用外部框架的路径、项目名称等一系列信息。 WorkSpacesWorkSpaces就是工作空间，用来管理，整个项目中的多个Project。 收获的小技巧 ommand + shift + O == Open Quickly 单元测试中，可以使用Test Again,针对某一个，测试用例进行多次测试 利用搜索栏的条件，进行精确的搜索，筛除无用的信息 Xcode中自带的Source Control进行代码对比，查看修改，以及查看相关日至 引申出的其他相关 Session","content":"<p>这一章节作为开发者工具的一部分，简单介绍了我们日常使用的开发工具 <code>Xcode</code>,虽然是我们每天都要使用的工具，但是通过这一个<code>session</code>还是收获了一些实用的小技巧。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-01.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>其中包括以下这几个大的模块。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-02.png\" alt=\"\"></p>\n<ul>\n<li>创建一个简单的应用并使其运行</li>\n<li>运行单元测试并对Bug进行调试</li>\n<li>审阅代码和提交</li>\n<li>对Xcode进行相关配置</li>\n</ul>\n<h3 id=\"配置你的工程（configuring-your-project）\"><a href=\"#配置你的工程（configuring-your-project）\" class=\"headerlink\" title=\"配置你的工程（configuring your project）\"></a>配置你的工程（configuring your project）</h3><p>像创建运行模块、简单的测试调试、以及代码的审阅和提交，在此处就不多叙述了，而在配置项目中，有几个很关键的概念需要弄明白</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-03.png\" alt=\"\"></p>\n<ul>\n<li>Project</li>\n<li>Target</li>\n<li>BuildSetting</li>\n<li>Schemes</li>\n<li>WorkSpaces</li>\n</ul>\n<h4 id=\"Project\"><a href=\"#Project\" class=\"headerlink\" title=\"Project\"></a>Project</h4><p>根据<a href=\"https://developer.apple.com/library/content/featuredarticles/XcodeConcepts/Concept-Projects.html\" target=\"_blank\" rel=\"external\">官方文档的解释</a> ，<code>Xcode</code>的<code>Project</code>是我们构建一个或多个应用时所需的文件、资源、相关信息的主要仓库。一个<code>Project</code>包含构建一个应用的所有元素，同时管理着这些元素之间的关系。它可能包含一个或者多个<code>Target</code>,<code>Target</code>可以专门指定该如何构建产品。<code>Project</code>为项目中的所有<code>Target</code>都做了默认的设定。</p>\n<h5 id=\"Project-包含以下文件\"><a href=\"#Project-包含以下文件\" class=\"headerlink\" title=\"Project 包含以下文件\"></a>Project 包含以下文件</h5><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-04.png\" alt=\"\"></p>\n<ul>\n<li><p>引用源文件</p>\n<ul>\n<li>源代码，包括头文件(.h)以及实现文件(.m)。</li>\n<li>静态库、动态库。内部文件和外部文件。</li>\n<li>资源文件。</li>\n<li>图片文件。</li>\n<li>用户交互的图形化界面(nib)。   </li>\n</ul>\n</li>\n<li><p>分组被用来在导航栏中管理<code>源文件</code></p>\n</li>\n<li>项目级构建配置(Schems)。 您可以为项目指定多个构建配置; 例如，您可能有一个项目的调试和发布构建设置。</li>\n<li>目标文件(Targets)</li>\n<li>每个指定的可用于<code>调试</code>或者<code>单元测试</code>的执行环境</li>\n</ul>\n<h4 id=\"Targets\"><a href=\"#Targets\" class=\"headerlink\" title=\"Targets\"></a>Targets</h4><p><code>Project</code>管理<code>Target</code><br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-06.png\" alt=\"\"></p>\n<p><code>Targets</code>包含一组在<code>Project</code>或者<code>WorkSpace</code>中的指定该如何构建产品的说明文件。一个<code>Target</code>就构建了一个独立的<code>Product</code>.</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-05.png\" alt=\"\"></p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-07.png\" alt=\"\"></p>\n<p><code>Target</code>构建成产品会经历上图的几个步骤，具体看图即可</p>\n<h4 id=\"Schemes\"><a href=\"#Schemes\" class=\"headerlink\" title=\"Schemes\"></a>Schemes</h4><p><code>Scheme</code>就是构建的方案，例如，你可以自定规则<code>Debug</code>或者<code>Release</code>,来决定不同环境下的不同规则。<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-08.png\" alt=\"\"></p>\n<h4 id=\"Build-Settings\"><a href=\"#Build-Settings\" class=\"headerlink\" title=\"Build Settings\"></a>Build Settings</h4><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-11.png\" alt=\"\"></p>\n<p>字面意思就是 <code>编译设置</code>，用于设置在编译过程中一些优先级、支持架构信息、优化的优先级、引用外部框架的路径、项目名称等一系列信息。</p>\n<h4 id=\"WorkSpaces\"><a href=\"#WorkSpaces\" class=\"headerlink\" title=\"WorkSpaces\"></a>WorkSpaces</h4><p><code>WorkSpaces</code>就是工作空间，用来管理，整个项目中的多个<code>Project</code>。<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-09.png\" alt=\"\"></p>\n<h3 id=\"收获的小技巧\"><a href=\"#收获的小技巧\" class=\"headerlink\" title=\"收获的小技巧\"></a>收获的小技巧</h3><ul>\n<li><code>ommand</code> + <code>shift</code> + <code>O</code> == <code>Open Quickly</code></li>\n<li>单元测试中，可以使用<code>Test Again</code>,针对某一个，测试用例进行多次测试</li>\n<li>利用搜索栏的条件，进行精确的搜索，筛除无用的信息</li>\n<li><code>Xcode</code>中自带的<code>Source Control</code>进行代码对比，查看修改，以及查看相关日至</li>\n</ul>\n<h3 id=\"引申出的其他相关-Session\"><a href=\"#引申出的其他相关-Session\" class=\"headerlink\" title=\"引申出的其他相关 Session\"></a>引申出的其他相关 Session</h3><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-10.png\" alt=\"\"></p>\n","excerpt":"这一章节作为开发者工具的一部分，简单介绍了我们日常使用的开发工具 Xcode,虽然是我们每天都要使用的工具，但是通过这一个session还是收获了一些实用的小技巧。","categories":[],"tags":[{"name":"WWDC Session 2016","slug":"WWDC-Session-2016","permalink":"http://yoursite.com/tags/WWDC-Session-2016/"}]},{"title":"NSURLProtocol","date":"2017-05-26T08:03:27.000Z","path":"2017/05/26/NSURLProtocol/","text":"","content":"","excerpt":"","categories":[],"tags":[]},{"title":"Block详解","date":"2017-05-18T11:34:42.000Z","path":"2017/05/18/Block详解/","text":"block是2010年WWDC苹果为 Objective－C 提供的一个新特性，它为我们开发提供了便利，比如GCD就大量使用了block，用来往执行队列中添加任务。书上定义block是带有自动变量（局部变量）的匿名函数。其实它就是一个闭包，一个引用自动变量的函数，更通俗的说，block就是一段代码块，用来储存一段代码，在特定的时机执行 Block用途 自动变量（局部变量） 函数参数 静态局部变量 静态全局变量 全局变量 Block声明与定义1.没有返回值,没有参数的定义方式 12345678910111213141516//返回值类型(^block的名字)(参数类型) = ^(参数类型和参数名) &#123;&#125;; void(^block)() = ^()&#123; NSLog(@\"调用了block\"); &#125;; //当然,没有参数的时候可以把括号省去 void(^block)() = ^&#123; NSLog(@\"调用了block\"); &#125;; // Block的调用直接Block名称后面括号即可，有参数就把参数放入即可 block(); // 调用了上面定义的Block 2.有返回值,有参数的定义方式 123456//返回值类型(^block的名字)(参数类型) = ^(参数类型和参数名) &#123;&#125;;//如果有参数,定义的时候,必须要写参数,而且必须要有参数变量名 int(^block)(int) = ^(int a)&#123; return a + 1; &#125;; 3.系统提供了一个定义block的快捷函数inline 12345// block快捷方式 输入:inlinereturnType(^blockName)(parameterTypes) = ^(parameters) &#123; statements&#125;; 4.block的类型 1234567891011121314151617181920212223242526//block有自己的类型,就想@\"string\"是NSString类型一样//格式就是 返回值(^)(参数类型)//比如这个block的类型就是: int(^)(int) int(^block)(int) = ^(int a)&#123; return 1; &#125;; //这个block的类型就是void(^)() void(^block)() = ^&#123; NSLog(@\"调用了block\"); &#125;; //在ARC中把block定义成属性要用 copy 类型,定义方式如下://这样在类中可以拿到self.block@property (nonatomic, copy) void(^block)();//当然也可以取别名://BlockType不是变量名,而是这种类型的block的别名typedef void(^BlockType)();//然后就可以这样@property (nonatomic, strong) BlockType block; Block语法上的省略block的标准范式为 ^ 返回值类型 参数列表 表达式 12345678910111213141516171819202122232425// 1.例如一个完整的Block ^int (int count) &#123; return count + 1; &#125;; // 2.如果返回值为Void，那么返回值可以省略 ^ (int count) &#123; NSLog(@\"%d\",count); &#125;; // 3.同理如果返回值和参数列表都没有值，那么可以同时省略 ^ &#123; NSLog(@\"%d\",count); &#125;; // 4.省略返回值时，如果表达式内部有 return 的类型，那么上略的返回值以 return 的类型为准，下面这个离子的返回值实际就是 int ^ (int count) &#123; return count + 1; &#125;; // 5.返回值类型和实际 return的类型必须一致。 与C语言指针函数的不同123456789101112131415161718//首先我们定义一个C语言的指针函数void buttonCallBack(int event) &#123; Printf(\"event = %d\\n\",event);&#125;//再写一个相同的Block^ void (int event) &#123; NSLog(@\"event = %d\",event);&#125;//对比得出结论1.Block是匿名函数，无需写函数名称2.返回值前加上 “^” 标记 Block变量的传递1.如果block访问的变量是局部变量,那么变量是值传递 1234567//block为值传递只有一种情况:int a = 3;void(^block)() = ^&#123; NSLog(@\"%d\",a);&#125;;a = 5;block();//这里调用block打印出的是3,是值传递 2.如果是静态变量,那么变量是指针传递 1234567static int a = 3;void(^block)() = ^&#123; NSLog(@\"%d\",a);&#125;;a = 5;block();//这里调用block打印出的是5,是指针传递//另外全局变量,静态变量都是指针传递 Block值传递Block也可以进行值的传递，且一般用于逆向回传，在此处不展开了，后面会针对iOS几种值传递的类型，做一个系统的总结,随后会附上链接。","content":"<blockquote>\n<p><code>block</code>是2010年WWDC苹果为 Objective－C 提供的一个新特性，它为我们开发提供了便利，比如GCD就大量使用了<code>block</code>，用来往执行队列中添加任务。书上定义<code>block</code>是带有自动变量（局部变量）的匿名函数。其实它就是一个闭包，一个引用自动变量的函数，更通俗的说，<code>block</code>就是一段代码块，用来储存一段代码，在特定的时机执行</p>\n</blockquote>\n<h3 id=\"Block用途\"><a href=\"#Block用途\" class=\"headerlink\" title=\"Block用途\"></a>Block用途</h3><ol>\n<li>自动变量（局部变量）</li>\n<li>函数参数</li>\n<li>静态局部变量</li>\n<li>静态全局变量</li>\n<li>全局变量</li>\n</ol>\n<h3 id=\"Block声明与定义\"><a href=\"#Block声明与定义\" class=\"headerlink\" title=\"Block声明与定义\"></a>Block声明与定义</h3><p>1.没有返回值,没有参数的定义方式</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//返回值类型(^block的名字)(参数类型) = ^(参数类型和参数名) &#123;&#125;;</span></div><div class=\"line\">  <span class=\"keyword\">void</span>(^block)() = ^()&#123;</div><div class=\"line\">  </div><div class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"调用了block\"</span>);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">//当然,没有参数的时候可以把括号省去</span></div><div class=\"line\">  <span class=\"keyword\">void</span>(^block)() = ^&#123;</div><div class=\"line\">  </div><div class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"调用了block\"</span>);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">// Block的调用直接Block名称后面括号即可，有参数就把参数放入即可</span></div><div class=\"line\"></div><div class=\"line\">    block();  <span class=\"comment\">// 调用了上面定义的Block</span></div></pre></td></tr></table></figure>\n<p>2.有返回值,有参数的定义方式</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//返回值类型(^block的名字)(参数类型) = ^(参数类型和参数名) &#123;&#125;;</span></div><div class=\"line\"><span class=\"comment\">//如果有参数,定义的时候,必须要写参数,而且必须要有参数变量名</span></div><div class=\"line\">  <span class=\"keyword\">int</span>(^block)(<span class=\"keyword\">int</span>) = ^(<span class=\"keyword\">int</span> a)&#123;</div><div class=\"line\">  </div><div class=\"line\">      <span class=\"keyword\">return</span> a + <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;;</div></pre></td></tr></table></figure>\n<p>3.系统提供了一个定义block的快捷函数<code>inline</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// block快捷方式   输入:inline</span></div><div class=\"line\">returnType(^blockName)(parameterTypes) = ^(parameters) &#123;</div><div class=\"line\"></div><div class=\"line\">        statements</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>4.block的类型</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//block有自己的类型,就想@\"string\"是NSString类型一样</span></div><div class=\"line\"><span class=\"comment\">//格式就是 返回值(^)(参数类型)</span></div><div class=\"line\"><span class=\"comment\">//比如这个block的类型就是: int(^)(int)</span></div><div class=\"line\">  <span class=\"keyword\">int</span>(^block)(<span class=\"keyword\">int</span>) = ^(<span class=\"keyword\">int</span> a)&#123;</div><div class=\"line\">  </div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">      </div><div class=\"line\">  &#125;;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">//这个block的类型就是void(^)()</span></div><div class=\"line\">  <span class=\"keyword\">void</span>(^block)() = ^&#123;</div><div class=\"line\">  </div><div class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"调用了block\"</span>);</div><div class=\"line\">      </div><div class=\"line\">  &#125;; </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">//在ARC中把block定义成属性要用 copy 类型,定义方式如下:</span></div><div class=\"line\"><span class=\"comment\">//这样在类中可以拿到self.block</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"keyword\">void</span>(^block)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//当然也可以取别名:</span></div><div class=\"line\"><span class=\"comment\">//BlockType不是变量名,而是这种类型的block的别名</span></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^BlockType)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//然后就可以这样</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) BlockType block;</div></pre></td></tr></table></figure>\n<h3 id=\"Block语法上的省略\"><a href=\"#Block语法上的省略\" class=\"headerlink\" title=\"Block语法上的省略\"></a>Block语法上的省略</h3><p><code>block</code>的标准范式为</p>\n<p><code>^</code>  <code>返回值类型</code>  <code>参数列表</code>  <code>表达式</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 1.例如一个完整的Block</span></div><div class=\"line\">    ^<span class=\"keyword\">int</span> (<span class=\"keyword\">int</span> count) &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> count + <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">// 2.如果返回值为Void，那么返回值可以省略</span></div><div class=\"line\">    ^ (<span class=\"keyword\">int</span> count) &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,count);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">// 3.同理如果返回值和参数列表都没有值，那么可以同时省略</span></div><div class=\"line\">    ^  &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,count);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">// 4.省略返回值时，如果表达式内部有 return 的类型，那么上略的返回值以 return 的类型为准，下面这个离子的返回值实际就是 int</span></div><div class=\"line\">    ^ (<span class=\"keyword\">int</span> count) &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> count + <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;;</div><div class=\"line\">   </div><div class=\"line\"><span class=\"comment\">// 5.返回值类型和实际 return的类型必须一致。</span></div></pre></td></tr></table></figure>\n<h3 id=\"与C语言指针函数的不同\"><a href=\"#与C语言指针函数的不同\" class=\"headerlink\" title=\"与C语言指针函数的不同\"></a>与C语言指针函数的不同</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//首先我们定义一个C语言的指针函数</span></div><div class=\"line\"><span class=\"keyword\">void</span> buttonCallBack(<span class=\"keyword\">int</span> event) &#123;</div><div class=\"line\"></div><div class=\"line\">    Printf(<span class=\"string\">\"event = %d\\n\"</span>,event);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//再写一个相同的Block</span></div><div class=\"line\">^ <span class=\"keyword\">void</span> (<span class=\"keyword\">int</span> event) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"event = %d\"</span>,event);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//对比得出结论</span></div><div class=\"line\"><span class=\"number\">1.</span>Block是匿名函数，无需写函数名称</div><div class=\"line\"><span class=\"number\">2.</span>返回值前加上 “^” 标记</div></pre></td></tr></table></figure>\n<h3 id=\"Block变量的传递\"><a href=\"#Block变量的传递\" class=\"headerlink\" title=\"Block变量的传递\"></a>Block变量的传递</h3><p>1.如果block访问的变量是局部变量,那么变量是值传递</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//block为值传递只有一种情况:</span></div><div class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"keyword\">void</span>(^block)() = ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,a);</div><div class=\"line\">&#125;;</div><div class=\"line\">a = <span class=\"number\">5</span>;</div><div class=\"line\">block();<span class=\"comment\">//这里调用block打印出的是3,是值传递</span></div></pre></td></tr></table></figure>\n<p>2.如果是静态变量,那么变量是指针传递</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"keyword\">void</span>(^block)() = ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,a);</div><div class=\"line\">&#125;;</div><div class=\"line\">a = <span class=\"number\">5</span>;</div><div class=\"line\">block();<span class=\"comment\">//这里调用block打印出的是5,是指针传递</span></div><div class=\"line\"><span class=\"comment\">//另外全局变量,静态变量都是指针传递</span></div></pre></td></tr></table></figure>\n<h3 id=\"Block值传递\"><a href=\"#Block值传递\" class=\"headerlink\" title=\"Block值传递\"></a>Block值传递</h3><p><code>Block</code>也可以进行值的传递，且一般用于逆向回传，在此处不展开了，后面会针对<code>iOS</code>几种值传递的类型，做一个系统的总结,随后会附上链接。</p>\n","excerpt":"","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://yoursite.com/tags/知识点/"}]},{"title":"iOS知识点小集","date":"2017-05-17T05:45:24.000Z","path":"2017/05/17/iOS知识点小集/","text":"在初始化项目时，LaunchScreen &gt; LaunchImage的优先级 123456789 如果是通过LaunchImage设置启动界面,那么屏幕的可视范围由图片决定 注意:如果使用LaunchImage,必须让你的美工提供各种尺寸的启动图片 LaunchScreen:Xcode6开始才有 LaunchScreen好处:1.自动识别当前真机或者模拟器的尺寸 2.只要让美工提供一个可拉伸图片 3.展示更多东西 LaunchScreen底层实现:把LaunchScreen截屏,生成一张图片.作为启动界面*/","content":"<ol>\n<li><p>在初始化项目时，<code>LaunchScreen</code> &gt; <code>LaunchImage</code>的优先级</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">   如果是通过LaunchImage设置启动界面,那么屏幕的可视范围由图片决定</div><div class=\"line\">   注意:如果使用LaunchImage,必须让你的美工提供各种尺寸的启动图片</div><div class=\"line\">   </div><div class=\"line\">   LaunchScreen:Xcode6开始才有</div><div class=\"line\">   LaunchScreen好处:<span class=\"number\">1.</span>自动识别当前真机或者模拟器的尺寸 <span class=\"number\">2.</span>只要让美工提供一个可拉伸图片</div><div class=\"line\">   <span class=\"number\">3.</span>展示更多东西</div><div class=\"line\"></div><div class=\"line\">   LaunchScreen底层实现:把LaunchScreen截屏,生成一张图片.作为启动界面</div><div class=\"line\">*/</div></pre></td></tr></table></figure>\n</li>\n</ol>\n","excerpt":"","categories":[],"tags":[]},{"title":"SDWebImage源码解析","date":"2017-05-16T05:59:32.000Z","path":"2017/05/16/SDWebImage源码解析/","text":"SDWebImage是我们经常使用的一个异步图片加载库，大大提高了我们的开发效率。它支持从网络中下载且缓存图片，并设置图片到对应的UIImageView控件或者UIButton控件上。 SDWebImage 概论123456789101.提供了一个UIImageView的category用来加载网络图片并且对网络图片的缓存进行管理2.采用异步方式来下载网络图片3.采用异步方式，使用memory＋disk来缓存网络图片，自动管理缓存。4.支持GIF动画,支持JEPG,JPG格式。5.支持WebP格式6.同一个URL的网络图片不会被重复下载7.失效的URL不会被无限重试8.耗时操作都在子线程，确保不会阻塞主线程9.使用GCD和ARC10.支持Arm64 ##SDWebImage知识点的梳理 正常程序退出后，会在几秒内停止工作,要想申请更长的时间，需要用到beginBackgroundTaskWithExpirationHandler endBackgroundTask一定要成对出现 使用NSdirectoryEnumerator遍历所有的缓存文件不会有性能耗时的问题,检查某个文件是否存在或者检查是否为文件夹都会检查文件的inode 数据,而这个inode中包括file的各种attribute. 使用NSCache作为内存储存比NSDictionary的好处是:当系统资源要耗尽的时候可以自动的删减,NSCache不会自动的拷贝键,并且是线程安全的,比NSDictionary线程安全. 线程中urlCallbacks的增加,改动都是使用所有增改回调集合URLCallbacks的操作使用dispatch_barrier_sync放入队列barrierQueue中，而查询URLCallbakcs的操作只需使用dispatch_sync放入队列barrierQueue中。 要先说一些系统中锁的问题: 同步锁@synchronized(self)在self上加一个同步锁,频繁滥用的话会导致程序会等待另外一段与此代码无关的执行完毕之后才能执行,会耗时. 123[_lock lock];//[_lock unlock]; 这样遇到死锁也会很麻烦,并且效率也不高.一般情况下想要为代码加锁,最好使用CGD.将所有的操作放到串行队列中执行.而对于并行队列的话就需要,读取的话可以并发进行,并没有任何改动,而增加或者修改数据的话必须保证此时不能进行读取数据,那么可以使用栅栏(barrier)来设置.在队列中栅栏块必须单独执行,不能与其他一起执行.这对于并发队列来说,如果并发队列发下下面要处理的是栅栏块,那么会一直等前面所有的并发块执行完毕后才执行这个栅栏,而等栅栏执行完毕后才执行其后的并发任务.所以增加和修改使用栅栏可以保证线程安全. 5.图片的解码.当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。SDWebImage就是在后台生成这种位图. SDWebImageManager结构关于结构，我们可以用一张流程图说明 SDWebImageDownloaderOptionsSDWebImageDownloaderOptions是图片下载选项 123456789101112131415161718192021222324typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) &#123; SDWebImageDownloaderLowPriority = 1 &lt;&lt; 0, //低优先级 SDWebImageDownloaderProgressiveDownload = 1 &lt;&lt; 1, //渐进式下载 SDWebImageDownloaderUseNSURLCache = 1 &lt;&lt; 2, //使用 NSURLCache 和默认缓存策略 /* * 如果图像是从 NSURLCache 读取的，则调用 completion block 时，image/imageData 传入 nil * (此标记要和 `SDWebImageDownloaderUseNSURLCache` 组合使用) */ SDWebImageDownloaderIgnoreCachedResponse = 1 &lt;&lt; 3, SDWebImageDownloaderContinueInBackground = 1 &lt;&lt; 4, //当 App 进入后台后仍然会继续下载图像 SDWebImageDownloaderHandleCookies = 1 &lt;&lt; 5, //处理保存在 NSHTTPCookieStore 中的 cookies SDWebImageDownloaderAllowInvalidSSLCertificates = 1 &lt;&lt; 6, //允许不信任的 SSL 证书 SDWebImageDownloaderHighPriority = 1 &lt;&lt; 7, //将图像放入高优先级队列 &#125; SDWebImageDownloaderExecutionOrderSDWebImageDownloaderExecutionOrder是图片下载操作的执行方式 123456typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) &#123; SDWebImageDownloaderFIFOExecutionOrder, //默认值，按照队列的先进先出方式执行 SDWebImageDownloaderLIFOExecutionOrder //按照堆栈的后进先出方式执行&#125;;","content":"<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/header/image/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-SDWebImage.png\" alt=\"\"></p>\n<blockquote>\n<p><a href=\"https://github.com/rs/SDWebImage\" target=\"_blank\" rel=\"external\">SDWebImage</a>是我们经常使用的一个异步图片加载库，大大提高了我们的开发效率。它支持从网络中下载且缓存图片，并设置图片到对应的UIImageView控件或者UIButton控件上。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"SDWebImage-概论\"><a href=\"#SDWebImage-概论\" class=\"headerlink\" title=\"SDWebImage 概论\"></a>SDWebImage 概论</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.提供了一个UIImageView的category用来加载网络图片并且对网络图片的缓存进行管理</div><div class=\"line\">2.采用异步方式来下载网络图片</div><div class=\"line\">3.采用异步方式，使用memory＋disk来缓存网络图片，自动管理缓存。</div><div class=\"line\">4.支持GIF动画,支持JEPG,JPG格式。</div><div class=\"line\">5.支持WebP格式</div><div class=\"line\">6.同一个URL的网络图片不会被重复下载</div><div class=\"line\">7.失效的URL不会被无限重试</div><div class=\"line\">8.耗时操作都在子线程，确保不会阻塞主线程</div><div class=\"line\">9.使用GCD和ARC</div><div class=\"line\">10.支持Arm64</div></pre></td></tr></table></figure>\n<p>##SDWebImage知识点的梳理</p>\n<ol>\n<li><p>正常程序退出后，会在几秒内停止工作,要想申请更长的时间，需要用到<code>beginBackgroundTaskWithExpirationHandler</code></p>\n</li>\n<li><p><code>endBackgroundTask</code>一定要成对出现</p>\n</li>\n<li><p>使用<code>NSdirectoryEnumerator</code>遍历所有的缓存文件不会有性能耗时的问题,检查某个文件是否存在或者检查是否为文件夹都会检查文件的inode 数据,而这个inode中包括file的各种attribute.</p>\n</li>\n<li><p>使用NSCache作为内存储存比NSDictionary的好处是:当系统资源要耗尽的时候可以自动的删减,NSCache不会自动的拷贝键,并且是线程安全的,比NSDictionary线程安全.</p>\n</li>\n<li><p>线程中<code>urlCallbacks</code>的增加,改动都是使用所有增改回调集合<code>URLCallbacks</code>的操作使用<code>dispatch_barrier_sync</code>放入队列<code>barrierQueue</code>中，而查询<code>URLCallbakcs</code>的操作只需使用<code>dispatch_sync</code>放入队列<code>barrierQueue</code>中。</p>\n</li>\n</ol>\n<p>要先说一些系统中锁的问题:</p>\n<p>同步锁<code>@synchronized(self)</code>在<code>self</code>上加一个同步锁,频繁滥用的话会导致程序会等待另外一段与此代码无关的执行完毕之后才能执行,会耗时.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[_lock lock];</div><div class=\"line\">//</div><div class=\"line\">[_lock unlock];</div></pre></td></tr></table></figure>\n<p>这样遇到死锁也会很麻烦,并且效率也不高.<br>一般情况下想要为代码加锁,最好使用CGD.将所有的操作放到串行队列中执行.而对于并行队列的话就需要,读取的话可以并发进行,并没有任何改动,而增加或者修改数据的话必须保证此时不能进行读取数据,那么可以使用<code>栅栏(barrier)</code>来设置.<strong>在队列中栅栏块必须单独执行,不能与其他一起执行.这对于并发队列来说,如果并发队列发下下面要处理的是栅栏块,那么会一直等前面所有的并发块执行完毕后才执行这个栅栏,而等栅栏执行完毕后才执行其后的并发任务</strong>.所以增加和修改使用栅栏可以保证线程安全.</p>\n<p>5.图片的解码.当你用 <code>UIImage</code> 或 <code>CGImageSource</code> 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 <code>UIImageView</code> 或者 <code>CALayer.contents</code> 中去，并且 <code>CALayer</code> 被提交到 <code>GPU</code> 前，<code>CGImage</code> 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 <code>CGBitmapContext</code> 中，然后从 <code>Bitmap</code> 直接创建图片。目前常见的网络图片库都自带这个功能。<code>SDWebImage</code>就是在后台生成这种位图.</p>\n<h2 id=\"SDWebImageManager结构\"><a href=\"#SDWebImageManager结构\" class=\"headerlink\" title=\"SDWebImageManager结构\"></a>SDWebImageManager结构</h2><p>关于结构，我们可以用一张流程图说明<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/SDWebImage%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png?watermark/2/text/QExpYmVyYWxpc20=/font/5a6L5L2T/fontsize/800/fill/IzhBMTgxOA==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" alt=\"\"></p>\n<h4 id=\"SDWebImageDownloaderOptions\"><a href=\"#SDWebImageDownloaderOptions\" class=\"headerlink\" title=\"SDWebImageDownloaderOptions\"></a>SDWebImageDownloaderOptions</h4><p><code>SDWebImageDownloaderOptions</code>是图片下载选项</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, SDWebImageDownloaderOptions) &#123;</div><div class=\"line\"></div><div class=\"line\">    SDWebImageDownloaderLowPriority = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,  <span class=\"comment\">//低优先级</span></div><div class=\"line\">    </div><div class=\"line\">    SDWebImageDownloaderProgressiveDownload = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,  <span class=\"comment\">//渐进式下载</span></div><div class=\"line\"></div><div class=\"line\">    SDWebImageDownloaderUseNSURLCache = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,  <span class=\"comment\">//使用 NSURLCache 和默认缓存策略</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     * 如果图像是从 NSURLCache 读取的，则调用 completion block 时，image/imageData 传入 nil</div><div class=\"line\">     * (此标记要和 `SDWebImageDownloaderUseNSURLCache` 组合使用)</div><div class=\"line\">     */</div><div class=\"line\">    SDWebImageDownloaderIgnoreCachedResponse = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span>,</div><div class=\"line\"></div><div class=\"line\">    SDWebImageDownloaderContinueInBackground = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>,  <span class=\"comment\">//当 App 进入后台后仍然会继续下载图像</span></div><div class=\"line\"></div><div class=\"line\">    SDWebImageDownloaderHandleCookies = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">5</span>, <span class=\"comment\">//处理保存在 NSHTTPCookieStore 中的 cookies</span></div><div class=\"line\"></div><div class=\"line\">    SDWebImageDownloaderAllowInvalidSSLCertificates = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">6</span>,  <span class=\"comment\">//允许不信任的 SSL 证书</span></div><div class=\"line\"></div><div class=\"line\">    SDWebImageDownloaderHighPriority = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">7</span>, <span class=\"comment\">//将图像放入高优先级队列</span></div><div class=\"line\">    </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"SDWebImageDownloaderExecutionOrder\"><a href=\"#SDWebImageDownloaderExecutionOrder\" class=\"headerlink\" title=\"SDWebImageDownloaderExecutionOrder\"></a>SDWebImageDownloaderExecutionOrder</h4><p><code>SDWebImageDownloaderExecutionOrder</code>是图片下载操作的执行方式</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, SDWebImageDownloaderExecutionOrder) &#123;</div><div class=\"line\">     </div><div class=\"line\">    SDWebImageDownloaderFIFOExecutionOrder,  <span class=\"comment\">//默认值，按照队列的先进先出方式执行</span></div><div class=\"line\"></div><div class=\"line\">    SDWebImageDownloaderLIFOExecutionOrder  <span class=\"comment\">//按照堆栈的后进先出方式执行</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n","excerpt":"SDWebImage是我们经常使用的一个异步图片加载库，大大提高了我们的开发效率。它支持从网络中下载且缓存图片，并设置图片到对应的UIImageView控件或者UIButton控件上。","categories":[],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"}]},{"title":"iOS知识总结-多线程","date":"2017-05-12T05:36:13.000Z","path":"2017/05/12/iOS知识总结-多线程/","text":"进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。 线程进程要想执行任务，必须得有线程（每1个进程至少要有1条线程），线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。线程中任务的执行是串行的，如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务。也就是说，在同一时间内，1个线程只能执行1个任务。 多线程即1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务。在同一时间里，CPU只能处理1条线程，只有1条线程在工作。多线程并发执行，其实是CPU快速地在多条线程之间切换，如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象 多线程优缺点优点1.能适当提高程序的执行效率。 2.能适当提高资源利用率（CPU、内存利用率） 缺点1.开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能。 2.线程越多，CPU在调度线程上的开销就越大。 3.程序设计更加复杂：比如线程之间的通信、多线程的数据共享 #### 12345678910111213141516171819202122232425265-2 NSThread a.特点： 1）使用更加面向对象 2）简单易用，可直接操作线程对象 b.使用语言：OC语言 c.使用频率：偶尔使用 d.线程生命周期：由程序员进行管理5-3 GCD a.特点： 1）旨在替代NSThread等线程技术 2）充分利用设备的多核（自动） b.使用语言：C语言 c.使用频率：经常使用 d.线程生命周期：自动管理5-4 NSOperation a.特点： 1）基于GCD（底层是GCD） 2）比GCD多了一些更简单实用的功能 3）使用更加面向对象 b.使用语言：OC语言 c.使用频率：经常使用 d.线程生命周期：自动管理 ###3 NSThread（1）NSThread的基本使用123456789101112131415161718192021222324//第一种创建线程的方式：alloc init.//特点：需要手动开启线程，可以拿到线程对象进行详细设置 //创建线程 /* 第一个参数：目标对象 第二个参数：选择器，线程启动要调用哪个方法 第三个参数：前面方法要接收的参数（最多只能接收一个参数，没有则传nil） */ NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(run:) object:@\"wendingding\"]; //启动线程 [thread start];//第二种创建线程的方式：分离出一条子线程//特点：自动启动线程，无法对线程进行更详细的设置 /* 第一个参数：线程启动调用的方法 第二个参数：目标对象 第三个参数：传递给调用方法的参数 */ [NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@\"我是分离出来的子线程\"];//第三种创建线程的方式：后台线程//特点：自动启动县城，无法进行更详细设置[self performSelectorInBackground:@selector(run:) withObject:@\"我是后台线程\"]; （2）设置线程的属性123456//设置线程的属性 //设置线程的名称 thread.name = @\"线程A\"; //设置线程的优先级,注意线程优先级的取值范围为0.0~1.0之间，1.0表示线程的优先级最高,如果不设置该值，那么理想状态下默认为0.5 thread.threadPriority = 1.0; （3）线程的状态（了解）123456//线程的各种状态：新建-就绪-运行-阻塞-死亡//常用的控制线程状态的方法[NSThread exit];//退出当前线程[NSThread sleepForTimeInterval:2.0];//阻塞线程[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:2.0]];//阻塞线程//注意：线程死了不能复生 （4）线程安全 01 前提：多个线程访问同一块资源会发生数据安全问题 02 解决方案：加互斥锁 03 相关代码：@synchronized(self){} 04 专业术语-线程同步 05 原子和非原子属性（是否对setter方法加锁） （5）线程间通信1234567891011121314151617181920212223242526272829-(void)touchesBegan:(nonnull NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event&#123;// [self download2]; //开启一条子线程来下载图片 [NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil];&#125;-(void)downloadImage&#123; //1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源 NSURL *url = [NSURL URLWithString:@\"http://p6.qhimg.com/t01d2954e2799c461ab.jpg\"]; //2.根据url地址下载图片数据到本地（二进制数据 NSData *data = [NSData dataWithContentsOfURL:url]; //3.把下载到本地的二进制数据转换成图片 UIImage *image = [UIImage imageWithData:data]; //4.回到主线程刷新UI //4.1 第一种方式// [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES]; //4.2 第二种方式// [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES]; //4.3 第三种方式 [self.imageView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:YES];&#125; （6）如何计算代码段的执行时间1234567891011121314//第一种方法 NSDate *start = [NSDate date]; //2.根据url地址下载图片数据到本地（二进制数据） NSData *data = [NSData dataWithContentsOfURL:url]; NSDate *end = [NSDate date]; NSLog(@\"第二步操作花费的时间为%f\",[end timeIntervalSinceDate:start]);//第二种方法 CFTimeInterval start = CFAbsoluteTimeGetCurrent(); NSData *data = [NSData dataWithContentsOfURL:url]; CFTimeInterval end = CFAbsoluteTimeGetCurrent(); NSLog(@\"第二步操作花费的时间为%f\",end - start); ###4.GCD （1）GCD基本知识 01 两个核心概念-队列和任务 02 同步函数和异步函数 （2）GCD基本使用【重点】123456701 异步函数+并发队列：开启多条线程，并发执行任务02 异步函数+串行队列：开启一条线程，串行执行任务03 同步函数+并发队列：不开线程，串行执行任务04 同步函数+串行队列：不开线程，串行执行任务05 异步函数+主队列：不开线程，在主线程中串行执行任务06 同步函数+主队列：不开线程，串行执行任务（注意死锁发生）07 注意同步函数和异步函数在执行顺序上面的差异 （3）GCD线程间通信 123456789101112131415161718192021//0.获取一个全局的队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //1.先开启一个线程，把下载图片的操作放在子线程中处理 dispatch_async(queue, ^&#123; //2.下载图片 NSURL *url = [NSURL URLWithString:@\"http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg\"]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; NSLog(@\"下载操作所在的线程--%@\",[NSThread currentThread]); //3.回到主线程刷新UI dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; //打印查看当前线程 NSLog(@\"刷新UI---%@\",[NSThread currentThread]); &#125;); &#125;); （4）GCD其它常用函数 12345678910111213141516171819202122232425262728293031323334353637 01 栅栏函数（控制任务的执行顺序） dispatch_barrier_async(queue, ^&#123; NSLog(@\"--dispatch_barrier_async-\"); &#125;); 02 延迟执行（延迟·控制在哪个线程执行） dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@\"---%@\",[NSThread currentThread]); &#125;); 03 一次性代码（注意不能放到懒加载） -(void)once &#123; //整个程序运行过程中只会执行一次 //onceToken用来记录该部分的代码是否被执行过 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@\"-----\"); &#125;); &#125; 04 快速迭代（开多个线程并发完成迭代操作） dispatch_apply(subpaths.count, queue, ^(size_t index) &#123; &#125;); 05 队列组（同栅栏函数） //创建队列组 dispatch_group_t group = dispatch_group_create(); //队列组中的任务执行完毕之后，执行该函数 dispatch_group_notify(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block);06进入群组和离开群组 dispatch_group_enter(group);//执行该函数后，后面异步执行的block会被gruop监听 dispatch_group_leave(group);//异步block中，所有的任务都执行完毕，最后离开群组 //注意：dispatch_group_enter|dispatch_group_leave必须成对使用","content":"<p><strong>进程</strong>是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a><strong>线程</strong></h2><pre><code>进程要想执行任务，必须得有线程（每1个进程至少要有1条线程），线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。线程中任务的执行是串行的，如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务。也就是说，在同一时间内，1个线程只能执行1个任务。\n</code></pre><h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a><strong>多线程</strong></h2><pre><code>即1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务。在同一时间里，CPU只能处理1条线程，只有1条线程在工作。多线程并发执行，其实是CPU快速地在多条线程之间切换，如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象\n</code></pre><h3 id=\"多线程优缺点\"><a href=\"#多线程优缺点\" class=\"headerlink\" title=\"多线程优缺点\"></a><strong>多线程优缺点</strong></h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><pre><code>1.能适当提高程序的执行效率。\n2.能适当提高资源利用率（CPU、内存利用率）\n</code></pre><h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><pre><code>1.开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能。\n2.线程越多，CPU在调度线程上的开销就越大。\n3.程序设计更加复杂：比如线程之间的通信、多线程的数据共享\n</code></pre><p>#### </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5</span><span class=\"number\">-2</span> <span class=\"built_in\">NSThread</span></div><div class=\"line\">\ta.特点：</div><div class=\"line\">\t    <span class=\"number\">1</span>）使用更加面向对象</div><div class=\"line\">\t    <span class=\"number\">2</span>）简单易用，可直接操作线程对象</div><div class=\"line\">\tb.使用语言：OC语言</div><div class=\"line\">\tc.使用频率：偶尔使用</div><div class=\"line\">\td.线程生命周期：由程序员进行管理</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5</span><span class=\"number\">-3</span> GCD</div><div class=\"line\">\ta.特点：</div><div class=\"line\">\t    <span class=\"number\">1</span>）旨在替代<span class=\"built_in\">NSThread</span>等线程技术</div><div class=\"line\">\t    <span class=\"number\">2</span>）充分利用设备的多核（自动）</div><div class=\"line\">\tb.使用语言：C语言</div><div class=\"line\">\tc.使用频率：经常使用</div><div class=\"line\">\td.线程生命周期：自动管理</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5</span><span class=\"number\">-4</span> <span class=\"built_in\">NSOperation</span></div><div class=\"line\">\ta.特点：</div><div class=\"line\">\t    <span class=\"number\">1</span>）基于GCD（底层是GCD）</div><div class=\"line\">\t    <span class=\"number\">2</span>）比GCD多了一些更简单实用的功能</div><div class=\"line\">\t    <span class=\"number\">3</span>）使用更加面向对象</div><div class=\"line\">\tb.使用语言：OC语言</div><div class=\"line\">\tc.使用频率：经常使用</div><div class=\"line\">\td.线程生命周期：自动管理</div></pre></td></tr></table></figure>\n<p>###3 NSThread<br>（1）NSThread的基本使用<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//第一种创建线程的方式：alloc init.</span></div><div class=\"line\"><span class=\"comment\">//特点：需要手动开启线程，可以拿到线程对象进行详细设置</span></div><div class=\"line\">    <span class=\"comment\">//创建线程</span></div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     第一个参数：目标对象</div><div class=\"line\">     第二个参数：选择器，线程启动要调用哪个方法</div><div class=\"line\">     第三个参数：前面方法要接收的参数（最多只能接收一个参数，没有则传nil）</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"built_in\">NSThread</span> *thread = [[<span class=\"built_in\">NSThread</span> alloc]initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run:) object:<span class=\"string\">@\"wendingding\"</span>];</div><div class=\"line\">     <span class=\"comment\">//启动线程</span></div><div class=\"line\">    [thread start];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第二种创建线程的方式：分离出一条子线程</span></div><div class=\"line\"><span class=\"comment\">//特点：自动启动线程，无法对线程进行更详细的设置</span></div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     第一个参数：线程启动调用的方法</div><div class=\"line\">     第二个参数：目标对象</div><div class=\"line\">     第三个参数：传递给调用方法的参数</div><div class=\"line\">     */</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(run:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"我是分离出来的子线程\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第三种创建线程的方式：后台线程</span></div><div class=\"line\"><span class=\"comment\">//特点：自动启动县城，无法进行更详细设置</span></div><div class=\"line\">[<span class=\"keyword\">self</span> performSelectorInBackground:<span class=\"keyword\">@selector</span>(run:) withObject:<span class=\"string\">@\"我是后台线程\"</span>];</div></pre></td></tr></table></figure></p>\n<p>（2）设置线程的属性<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置线程的属性</span></div><div class=\"line\"> <span class=\"comment\">//设置线程的名称</span></div><div class=\"line\"> thread.name = <span class=\"string\">@\"线程A\"</span>;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">//设置线程的优先级,注意线程优先级的取值范围为0.0~1.0之间，1.0表示线程的优先级最高,如果不设置该值，那么理想状态下默认为0.5</span></div><div class=\"line\"> thread.threadPriority = <span class=\"number\">1.0</span>;</div></pre></td></tr></table></figure></p>\n<p>（3）线程的状态（了解）<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//线程的各种状态：新建-就绪-运行-阻塞-死亡</span></div><div class=\"line\"><span class=\"comment\">//常用的控制线程状态的方法</span></div><div class=\"line\">[<span class=\"built_in\">NSThread</span> exit];<span class=\"comment\">//退出当前线程</span></div><div class=\"line\">[<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">2.0</span>];<span class=\"comment\">//阻塞线程</span></div><div class=\"line\">[<span class=\"built_in\">NSThread</span> sleepUntilDate:[<span class=\"built_in\">NSDate</span> dateWithTimeIntervalSinceNow:<span class=\"number\">2.0</span>]];<span class=\"comment\">//阻塞线程</span></div><div class=\"line\"><span class=\"comment\">//注意：线程死了不能复生</span></div></pre></td></tr></table></figure></p>\n<p>（4）线程安全</p>\n<pre><code>01 前提：多个线程访问同一块资源会发生数据安全问题\n02 解决方案：加互斥锁\n03 相关代码：@synchronized(self){}\n04 专业术语-线程同步\n05 原子和非原子属性（是否对setter方法加锁）\n</code></pre><p>（5）线程间通信<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"keyword\">nonnull</span> <span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"comment\">//    [self download2];</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//开启一条子线程来下载图片</span></div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(downloadImage) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)downloadImage</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源</span></div><div class=\"line\">    <span class=\"built_in\">NSURL</span> *url = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://p6.qhimg.com/t01d2954e2799c461ab.jpg\"</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//2.根据url地址下载图片数据到本地（二进制数据</span></div><div class=\"line\">    <span class=\"built_in\">NSData</span> *data = [<span class=\"built_in\">NSData</span> dataWithContentsOfURL:url];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//3.把下载到本地的二进制数据转换成图片</span></div><div class=\"line\">    <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageWithData:data];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//4.回到主线程刷新UI</span></div><div class=\"line\">    <span class=\"comment\">//4.1 第一种方式</span></div><div class=\"line\"><span class=\"comment\">//    [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES];</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//4.2 第二种方式</span></div><div class=\"line\"><span class=\"comment\">//    [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES];</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//4.3 第三种方式</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.imageView performSelector:<span class=\"keyword\">@selector</span>(setImage:) onThread:[<span class=\"built_in\">NSThread</span> mainThread] withObject:image waitUntilDone:<span class=\"literal\">YES</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>（6）如何计算代码段的执行时间<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//第一种方法</span></div><div class=\"line\">    <span class=\"built_in\">NSDate</span> *start = [<span class=\"built_in\">NSDate</span> date];</div><div class=\"line\">    <span class=\"comment\">//2.根据url地址下载图片数据到本地（二进制数据）</span></div><div class=\"line\">    <span class=\"built_in\">NSData</span> *data = [<span class=\"built_in\">NSData</span> dataWithContentsOfURL:url];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSDate</span> *end = [<span class=\"built_in\">NSDate</span> date];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第二步操作花费的时间为%f\"</span>,[end timeIntervalSinceDate:start]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第二种方法</span></div><div class=\"line\">    <span class=\"built_in\">CFTimeInterval</span> start = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</div><div class=\"line\">    <span class=\"built_in\">NSData</span> *data = [<span class=\"built_in\">NSData</span> dataWithContentsOfURL:url];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CFTimeInterval</span> end = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第二步操作花费的时间为%f\"</span>,end - start);</div></pre></td></tr></table></figure></p>\n<p>###4.GCD</p>\n<p>（1）GCD基本知识</p>\n<pre><code>01 两个核心概念-队列和任务\n02 同步函数和异步函数\n</code></pre><p>（2）GCD基本使用【重点】<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">01</span> 异步函数+并发队列：开启多条线程，并发执行任务</div><div class=\"line\"><span class=\"number\">02</span> 异步函数+串行队列：开启一条线程，串行执行任务</div><div class=\"line\"><span class=\"number\">03</span> 同步函数+并发队列：不开线程，串行执行任务</div><div class=\"line\"><span class=\"number\">04</span> 同步函数+串行队列：不开线程，串行执行任务</div><div class=\"line\"><span class=\"number\">05</span> 异步函数+主队列：不开线程，在主线程中串行执行任务</div><div class=\"line\"><span class=\"number\">06</span> 同步函数+主队列：不开线程，串行执行任务（注意死锁发生）</div><div class=\"line\"><span class=\"number\">07</span> 注意同步函数和异步函数在执行顺序上面的差异</div></pre></td></tr></table></figure></p>\n<p>（3）GCD线程间通信</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//0.获取一个全局的队列</span></div><div class=\"line\">   <span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">//1.先开启一个线程，把下载图片的操作放在子线程中处理</span></div><div class=\"line\">   <span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">//2.下载图片</span></div><div class=\"line\">       <span class=\"built_in\">NSURL</span> *url = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg\"</span>];</div><div class=\"line\">       <span class=\"built_in\">NSData</span> *data = [<span class=\"built_in\">NSData</span> dataWithContentsOfURL:url];</div><div class=\"line\">       <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageWithData:data];</div><div class=\"line\"></div><div class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"下载操作所在的线程--%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//3.回到主线程刷新UI</span></div><div class=\"line\">       <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">          <span class=\"keyword\">self</span>.imageView.image = image;</div><div class=\"line\">          <span class=\"comment\">//打印查看当前线程</span></div><div class=\"line\">           <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"刷新UI---%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">       &#125;);</div><div class=\"line\"></div><div class=\"line\">   &#125;);</div></pre></td></tr></table></figure>\n<p>（4）GCD其它常用函数</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">   <span class=\"number\">01</span> 栅栏函数（控制任务的执行顺序）</div><div class=\"line\">   dispatch_barrier_async(queue, ^&#123;</div><div class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"--dispatch_barrier_async-\"</span>);</div><div class=\"line\">   &#125;);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"number\">02</span> 延迟执行（延迟·控制在哪个线程执行）</div><div class=\"line\">     dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"---%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">   &#125;);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"number\">03</span> 一次性代码（注意不能放到懒加载）</div><div class=\"line\">   -(<span class=\"keyword\">void</span>)once</div><div class=\"line\">   &#123;</div><div class=\"line\">       <span class=\"comment\">//整个程序运行过程中只会执行一次</span></div><div class=\"line\">       <span class=\"comment\">//onceToken用来记录该部分的代码是否被执行过</span></div><div class=\"line\">       <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</div><div class=\"line\">       <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class=\"line\"></div><div class=\"line\">           <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"-----\"</span>);</div><div class=\"line\">       &#125;);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"number\">04</span> 快速迭代（开多个线程并发完成迭代操作）</div><div class=\"line\">      dispatch_apply(subpaths.count, queue, ^(size_t index) &#123;</div><div class=\"line\">   &#125;);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"number\">05</span> 队列组（同栅栏函数）</div><div class=\"line\">   <span class=\"comment\">//创建队列组</span></div><div class=\"line\">   dispatch_group_t group = dispatch_group_create();</div><div class=\"line\">   <span class=\"comment\">//队列组中的任务执行完毕之后，执行该函数</span></div><div class=\"line\">   dispatch_group_notify(dispatch_group_t group,<span class=\"built_in\">dispatch_queue_t</span> queue,dispatch_block_t block);</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">06</span>进入群组和离开群组</div><div class=\"line\">   dispatch_group_enter(group);<span class=\"comment\">//执行该函数后，后面异步执行的block会被gruop监听</span></div><div class=\"line\">   dispatch_group_leave(group);<span class=\"comment\">//异步block中，所有的任务都执行完毕，最后离开群组</span></div><div class=\"line\">   <span class=\"comment\">//注意：dispatch_group_enter|dispatch_group_leave必须成对使用</span></div></pre></td></tr></table></figure>\n","excerpt":"","categories":[],"tags":[{"name":"知识总结","slug":"知识总结","permalink":"http://yoursite.com/tags/知识总结/"}]},{"title":"iOS常用设计模式","date":"2017-05-10T07:28:43.000Z","path":"2017/05/10/iOS常用设计模式/","text":"一、何为设计模式 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。","content":"<p>一、何为设计模式</p>\n<p><code>设计模式（Design pattern）</code>是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p>\n","excerpt":"","categories":[],"tags":[{"name":"知识总结","slug":"知识总结","permalink":"http://yoursite.com/tags/知识总结/"}]},{"title":"iOS知识总结-基础篇-2","date":"2017-04-25T05:43:49.000Z","path":"2017/04/25/iOS知识总结-基础篇-2/","text":"文章大纲，便于浏览 NSTimer以下文章详细讲述了NSTimer的创建、销毁以及与NSRunLoop的关系，通读几遍，就可以融会贯通了 iOS应用程序间共享数据这篇文章义工介绍了四种应用程序间共享数据的方法 开源许可说明 枚举的三种写法 普通写法 12345typedef enum&#123; GZQDemoTypeTop, GZQDemoTypeBottom,&#125;GZQDemoType; 文艺写法 123456定义类型typedef NS_ENUM(NSInteger,GZQType)&#123; GZQTypeTop, GZQTypeBottom,&#125;; 推荐写法（可以进行位运算，更加灵活） 12345678typedef NS_OPTIONS(NSInteger, GZQActionType)&#123; GZQActionTypeA = 1&lt;&lt;0, GZQActionTypeb = 1&lt;&lt;1, GZQActionTypec = 1&lt;&lt;2, GZQActionTypeD = 1&lt;&lt;3,&#125;","content":"<p>文章大纲，便于浏览</p>\n<h3 id=\"NSTimer\"><a href=\"#NSTimer\" class=\"headerlink\" title=\"NSTimer\"></a>NSTimer</h3><p>以下<a href=\"http://www.jianshu.com/p/330d7310339d\" target=\"_blank\" rel=\"external\">文章</a>详细讲述了NSTimer的创建、销毁以及与NSRunLoop的关系，通读几遍，就可以融会贯通了</p>\n<h3 id=\"iOS应用程序间共享数据\"><a href=\"#iOS应用程序间共享数据\" class=\"headerlink\" title=\"iOS应用程序间共享数据\"></a>iOS应用程序间共享数据</h3><p>这篇<a href=\"http://www.jianshu.com/p/169e31cacf42\" target=\"_blank\" rel=\"external\">文章</a>义工介绍了四种应用程序间共享数据的方法</p>\n<h3 id=\"开源许可说明\"><a href=\"#开源许可说明\" class=\"headerlink\" title=\"开源许可说明\"></a>开源许可说明</h3><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%B4%E6%98%8E.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"枚举的三种写法\"><a href=\"#枚举的三种写法\" class=\"headerlink\" title=\"枚举的三种写法\"></a>枚举的三种写法</h3><ul>\n<li>普通写法</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span></div><div class=\"line\">&#123;</div><div class=\"line\">    GZQDemoTypeTop,</div><div class=\"line\">    GZQDemoTypeBottom,</div><div class=\"line\">&#125;GZQDemoType;</div></pre></td></tr></table></figure>\n<ul>\n<li>文艺写法</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">定义类型</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>,GZQType)</div><div class=\"line\">&#123;</div><div class=\"line\">    GZQTypeTop,</div><div class=\"line\">    GZQTypeBottom,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li>推荐写法（可以进行位运算，更加灵活）</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSInteger</span>, GZQActionType)</div><div class=\"line\">&#123;</div><div class=\"line\">    GZQActionTypeA = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">0</span>,</div><div class=\"line\">    GZQActionTypeb = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>,</div><div class=\"line\">    GZQActionTypec = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>,</div><div class=\"line\">    GZQActionTypeD = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span>,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"文章大纲，便于浏览 NSTimer以下文章详细讲述了NSTimer的创建、销毁以及与NSRunLoop的关系，通读几遍，就可以融会贯通了 iOS应用程序间共享数据这篇文章义工介绍了四种应用程序间共享数据的方法 开源许可说明","categories":[],"tags":[{"name":"知识总结","slug":"知识总结","permalink":"http://yoursite.com/tags/知识总结/"}]},{"title":"iOS知识总结-基础篇-1","date":"2017-04-15T15:43:49.000Z","path":"2017/04/15/iOS知识总结-基础篇-1/","text":"文章大纲，便于浏览 01-iOS程序启动过程 02-浅拷贝-深拷贝 03-View的生命周期 04-@property 05-事件传递和事件响应 06-KVC 07-KVO 08-iOS数据持久化方案 01-iOS-App-startup-process###一、启动完整过程 1.main函数 2.UIApplicationMain函数 创建UIApplication对象 创建UIApplication的delegate对象 3.delegate对象开始处理(监听)系统事件(没有storyboard) 程序启动完毕的时候, 就会调用代理的:didFinishLaunchingWithOptions:方法 在application:didFinishLaunchingWithOptions:中创建UIWindow 创建和设置UIWindow的rootViewController 显示窗口 4.根据Info.plist获得最主要storyboard的文件名,加载最主要的storyboard(有storyboard) 创建UIWindow 创建和设置UIWindow的rootViewController 显示窗口 ###二、程序启动原理 1.main函数中执行了一个UIApplicationMain这个函数 123int UIApplicationMain(int argc, char *argv[], NSString *principalClassName, NSString *delegateClassName);argc、argv：直接传递给UIApplicationMain进行相关处理即可 2.principalClassName：指定应用程序类名（app的象征），该类必须是UIApplication(或子类)。如果为nil,则用UIApplication类作为默认值 3.delegateClassName：指定应用程序的代理类，该类必须遵守UIApplicationDelegate协议 4.UIApplicationMain函数会根据principalClassName创建UIApplication对象，根据delegateClassName创建一个delegate对象，并将该delegate对象赋值给UIApplication对象中的delegate属性 5.接着会建立应用程序的Main Runloop（事件循环），进行事件的处理(首先会在程序完毕后调用delegate对象的application:didFinishLaunchingWithOptions:方法) 程序正常退出时UIApplicationMain函数才返回 1234567891011int main(int argc, char * argv[])&#123; @autoreleasepool &#123; /*** argc: 系统或者用户传入的参数个数* argv: 系统或者用户传入的实际参数 * 1.根据传入的第三个参数创建UIApplication对象 * 2.根据传入的第四个产生创建UIApplication对象的代理* 3.设置刚刚创建出来的代理对象为UIApplication的代理 * 4.开启一个事件循环 **/ return UIApplicationMain(argc, argv, @\"UIApplication\", @\"YYAppDelegate\"); &#125;&#125; 启动与代理： 02-ShallowCopy-DeepCopy简要总结一下什么是浅拷贝，什么是深拷贝 深拷贝就是内容拷贝 浅拷贝就是指针拷贝 ###一.系统对象的 copy/mutableCopy 1234567891011121314151617NSString *string = @\"LiMing\"; NSString *copyString = [string copy]; NSString *mutableString = [string mutableCopy]; NSLog(@\"string = %p\",string); NSLog(@\"copyString = %p\",copyString); NSLog(@\"mutableString = %p \",mutableString);结论：1.string 和 copyString 他们只是二个不同的指针，指向内存中的同一块地址，copy 只是指针复制2.string 和 mutableString 打印出来的地址不同，是因为两个指针指向的地址本就不同，mutableCopy 是内容复制注意：其他对象 NSArray 、NSMutableArray 、NSDictionary 、NSMutableDictionary 一样适用 规律可以从这张图看出来 ###二.自定义对象实现 Copy-MutableCopy copy 1234GZQPerson *person = [[GZQPerson alloc] init];person.age = 20;person.name = @\"GZQ\";GZQPerson *copyP = [person copy]; // 这里崩溃 崩溃： 看崩溃信息GZQPerson应该先实现： 1- (id)copyWithZone:(NSZone *)zone; 测试： 12345678910111213141516171819202122232425#import \"GZQPerson.h\"@interface GZQPerson ()&lt;NSCopying,NSMutableCopying&gt;@end@implementation GZQPerson- (id)copyWithZone:(NSZone *)zone &#123; GZQPerson *person = [[[self class] allocWithZone:zone] init]; person.age = self.age; person.name = self.name; return person;&#125;- (id)mutableCopyWithZone:(NSZone *)zone &#123; GZQPerson *person = [[[self class] allocWithZone:zone] init]; person.age = self.age; person.name = self.name; return person;&#125;@end 12345678910111213141516171819202122232425#import \"ViewController.h\"#import \"GZQPerson.h\"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; GZQPerson *person = [[GZQPerson alloc] init]; person.age = 20; person.name = @\"GZQ\"; GZQPerson *copyP = [person copy]; NSLog(@\"copyP=%p\",copyP); NSLog(@\"person=%p\",person); NSLog(@\"person=%p\",copyP.name); NSLog(@\"person=%p\",person.name); &#125;@end 可以看出虽然指针的地址不同，但是存储的地址是一致的。 ###三.copy 本质 property copy 实际上就对name干了这个： 12345678#import &lt;Foundation/Foundation.h&gt;property copy 实际上就对name干了这个：- (void)setName:(NSString *)name&#123; _name = [name copy];&#125; strong是不执行Copy操作的 1234567891011@property (nonatomic, strong) NSString *name;NSMutableString *string = [NSMutableString stringWithFormat:@\"深拷贝-浅拷贝\"];GZQPerson *person = [[GZQPerson alloc] init];person.name = string;// 可以改变person.name的值，因为其内部没有生成新的对象[string appendString:@\"LALALA\"];NSLog(@\"name = %@\", person.name); 03-View的生命周期 读懂这一张图即可 04-@property @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的 @property 的本质. 1@property = ivar + getter + setter; 下面解释下： “属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。 “属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示: 编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说： 1@property = getter + setter; 例如下面这个类： 1234@interface Person : NSObject@property NSString *firstName;@property NSString *lastName;@end 上述代码写出来的类与下面这种写法等效： 123456@interface Person : NSObject- (NSString *)firstName;- (void)setFirstName:(NSString *)firstName;- (NSString *)lastName;- (void)setLastName:(NSString *)lastName;@end property在runtime中是objc_property_t定义如下: 1typedef struct objc_property *objc_property_t; 而objc_property是一个结构体，包括name和attributes，定义如下： 1234struct property_t &#123; const char *name; const char *attributes;&#125;; 而attributes本质是objc_property_attribute_t，定义了property的一些属性，定义如下： 12345/// Defines a property attributetypedef struct &#123; const char *name; /**&lt; The name of the attribute */ const char *value; /**&lt; The value of the attribute (usually empty) */&#125; objc_property_attribute_t; 而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。 例如：我们定义一个string的property 1@property (nonatomic, copy) NSString *string; 通过 property_getAttributes(property)获取到attributes并打印出来之后的结果为 1T@\"NSString\",C,N,V_string 其中T就代表类型，可参阅Type Encodings，C就代表Copy，N代表nonatomic，V就代表对于的实例变量。 ivar、getter、setter 是如何生成并添加到这个类中的? “自动合成”( autosynthesis) 完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过@synthesize 语法来指定实例变量的名字. 1234@implementation Person@synthesize firstName = _myFirstName;@synthesize lastName = _myLastName;@end 我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西 1234561. OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。2. setter 与 getter 方法对应的实现函数3. ivar_list ：成员变量列表4. method_list ：方法列表5. prop_list ：属性列表也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转. 属性可以拥有的特质分为四类: 原子性— nonatomic 特质,在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。 读/写权限—readwrite(读写)、readonly (只读) 内存管理语义—assign、strong、 weak、unsafe_unretained、copy 方法名—getter= 、setter= getter=的样式： 123@property (nonatomic, getter=isOn) BOOL on; (`setter=`这种不常用，也不推荐使用。故不在这里给出写法。） setter=一般用在特殊的情境下，比如： 在数据反序列化、转模型的过程中，服务器返回的字段如果以 init 开头，所以你需要定义一个 init 开头的属性，但默认生成的 setter 与 getter 方法也会以 init 开头，而编译器会把所有以 init 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。 这时你就可以使用下面的方式来避免编译器报错： 1@property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:)NSString *initBy; 另外也可以用关键字进行特殊说明，来避免编译器报错： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@property(nonatomic, readwrite, copy, null_resettable) NSString *initBy;- (NSString *)initBy __attribute__((objc_method_family(none)));1. 不常用的：nonnull,null_resettable,nullable注意：很多人会认为如果属性具备 nonatomic 特质，则不使用 “同步锁”。其实在属性设置方法中使用的是自旋锁，自旋锁相关代码如下：static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)&#123; if (offset == 0) &#123; object_setClass(self, newValue); return; &#125; id oldValue; id *slot = (id*) ((char*)self + offset); if (copy) &#123; newValue = [newValue copyWithZone:nil]; &#125; else if (mutableCopy) &#123; newValue = [newValue mutableCopyWithZone:nil]; &#125; else &#123; if (*slot == newValue) return; newValue = objc_retain(newValue); &#125; if (!atomic) &#123; oldValue = *slot; *slot = newValue; &#125; else &#123; spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); &#125; objc_release(oldValue);&#125;void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) &#123; bool copy = (shouldCopy &amp;&amp; shouldCopy != MUTABLE_COPY); bool mutableCopy = (shouldCopy == MUTABLE_COPY); reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);&#125; 05-事件传递和事件响应这部分知识如果自己总结，篇幅较长。可以参考以下文章 06-KVCKey-Value Coding (KVC) KVC（Key-value coding）键值编码，单看这个名字可能不太好理解。其实翻译一下就很简单了，就是指iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值。而不需要调用明确的存取方法。这样就可以在运行时动态在访问和修改对象的属性。而不是在编译时确定，这也是iOS开发中的黑魔法之一。很多高级的iOS开发技巧都是基于KVC实现的。目前网上关于KVC的文章在非常多，有的只是简单地说了下用法，有的讲得深入但是在使用场景和最佳实践没有说明，我写下这遍文章就是给大家详解一个最完整最详细的KVC。 KVC在iOS中的定义 无论是Swift还是Objective-C，KVC的定义都是对NSObject的扩展来实现的(Objective-C中有个显式的NSKeyValueCoding类别名，而Swift没有，也不需要)所以对于所有继承了NSObject在类型，都能使用KVC(一些纯Swift类和结构体是不支持KVC的)，下面是KVC最为重要的四个方法 1234- (nullable id)valueForKey:(NSString *)key; //直接通过Key来取值- (void)setValue:(nullable id)value forKey:(NSString *)key; //通过Key来设值- (nullable id)valueForKeyPath:(NSString *)keyPath; //通过KeyPath来取值- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; //通过KeyPath来设值 当然NSKeyValueCoding类别中还有其他的一些方法，下面列举一些 1234567891011121314+ (BOOL)accessInstanceVariablesDirectly;//默认返回YES，表示如果没有找到Set&lt;Key&gt;方法的话，会按照_key，_iskey，key，iskey的顺序搜索成员，设置成NO就不这样搜索- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;//KVC提供属性值确认的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;//这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回- (nullable id)valueForUndefinedKey:(NSString *)key;//如果Key不存在，且没有KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;//和上一个方法一样，只不过是设值。- (void)setNilValueForKey:(NSString *)key;//如果你在SetValue方法时面给Value传nil，则会调用这个方法- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;//输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。 上面的这些方法在碰到特殊情况或者有特殊需求还是会用到的，所以也是可以了解一下。后面的代码示例会有讲到其中的一些方法。同时苹果对一些容器类比如NSArray或者NSSet等，KVC有着特殊的实现。建议有基础的或者英文好的开发者直接去看苹果的官方文档，相信你会对KVC的理解更上一个台阶。 KVC是怎么寻找Key的 KVC是怎么使用的，我相信绝大多数的开发者都很清楚，我在这里就不再写简单的使用KVC来设值和取值的代码了，首页我们来探讨KVC在内部是按什么样的顺序来寻找key的。当调用setValue：属性值 forKey：``@”name“的代码时，底层的执行机制如下： 程序优先调用set&lt;Key&gt;:属性值方法，代码通过setter方法完成设置。注意，这里的&lt;key&gt;是指成员变量名，首字母大清写要符合KVC的全名规则，下同 如果没有找到setName：方法，KVC机制会检查+ (BOOL)accessInstanceVariablesDirectly方法有没有返回YES，默认该方法会返回YES，如果你重写了该方法让其返回NO的话，那么在这一步KVC会执行setValue：forUNdefinedKey：方法，不过一般开发者不会这么做。所以KVC机制会搜索该类里面有没有名为_&lt;key&gt;的成员变量，无论该变量是在类接口部分定义，还是在类实现部分定义，也无论用了什么样的访问修饰符，只在存在以_&lt;key&gt;命名的变量，KVC都可以对该成员变量赋值。 如果该类即没有set&lt;Key&gt;：方法，也没有_&lt;key&gt;成员变量，KVC机制会搜索_is&lt;Key&gt;的成员变量， 和上面一样，如果该类即没有set&lt;Key&gt;：方法，也没有_&lt;key&gt;和_is&lt;Key&gt;成员变量，KVC机制再会继续搜索&lt;key&gt;和is&lt;Key&gt;的成员变量。再给它们赋值。 如果上面列出的方法或者成员变量都不存在，系统将会执行该对象的setValue：forUNdefinedKey：方法，默认是抛出异常。 如果开发者想让这个类禁用KVC里，那么重写+ (BOOL)accessInstanceVariablesDirectly方法让其返回NO即可，这样的话如果KVC没有找到set&lt;Key&gt;:属性名时，会直接用setValue：forUNdefinedKey：方法。 07-KVOKVO，全称为Key-Value Observing，是iOS中的一种设计模式，用于检测对象的某些属性的实时变化情况并作出响应。当应用场景比较复杂时，多个地方存在crash的危险。 首先，假设我们的目标是在一个UITableViewController内对tableview的contentOffset进行实时监测，很容易地使用KVO来实现为。 在初始化方法中加入： 12345678910111213[_tableView addObserver:self forKeyPath:@\"contentOffset\" options:NSKeyValueObservingOptionNew context:nil];// 在dealloc中移除KVO监听：[_tableView removeObserver:self forKeyPath:@\"contentOffset\" context:nil];// 添加默认的响应回调方法：- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; [self doSomethingWhenContentOffsetChanges];&#125; 好了，KVO实现就到此完美结束了，开玩笑，肯定没这么简单的，这样的代码太粗糙了，当你在controller中添加多个KVO时，所有的回调都是走同上述函数，那就必须对触发回调函数的来源进行判断。判断如下： 12345678910- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if (object == _tableView &amp;&amp; [keyPath isEqualToString:@\"contentOffset\"]) &#123; [self doSomethingWhenContentOffsetChanges]; &#125;&#125; 你以为这样就结束了吗？答案是否定的！我们假设当前类(在例子中为UITableViewController)还有父类，并且父类也有自己绑定了一些其他KVO呢？我们看到，上述回调函数体中只有一个判断，如果这个if不成立，这次KVO事件的触发就会到此中断了。但事实上，若当前类无法捕捉到这个KVO，那很有可能是在他的superClass，或者super-superClass...中，上述处理砍断了这个链。合理的处理方式应该是这样的： 1234567891011121314- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if (object == _tableView &amp;&amp; [keyPath isEqualToString:@\"contentOffset\"]) &#123; [self doSomethingWhenContentOffsetChanges]; &#125; else &#123; [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; &#125;&#125; 这样就结束了吗？答案仍旧是否定的。潜在的问题有可能出现在dealloc中对KVO的注销上。KVO的一种缺陷(其实不能称为缺陷，应该称为特性)是，当对同一个keypath进行两次removeObserver时会导致程序crash，这种情况常常出现在父类有一个kvo，父类在dealloc中remove了一次，子类又remove了一次的情况下。不要以为这种情况很少出现！当你封装framework开源给别人用或者多人协作开发时是有可能出现的，而且这种crash很难发现。不知道你发现没，目前的代码中context字段都是nil，那能否利用该字段来标识出到底kvo是superClass注册的，还是self注册的？ 回答是可以的。我们可以分别在父类以及本类中定义各自的context字符串，比如在本类中定义context为@&quot;ThisIsMyKVOContextNotSuper&quot;;然后在dealloc中remove observer时指定移除的自身添加的observer。这样iOS就能知道移除的是自己的kvo，而不是父类中的kvo，避免二次remove造成crash。 08-iOS数据持久化方案存储方案 plist文件（属性列表） preference（偏好设置） NSKeyedArchiver（归档） SQLite 3 CoreData 沙盒 iOS程序默认情况下只能访问程序自己的目录，这个目录被称为“沙盒”。 1.结构沙盒的目录结构如下： 123456\"应用程序包\"DocumentsLibrary Caches Preferencestmp 2.目录特性 虽然沙盒中有这么多文件夹，但是每个文件夹都不尽相同，都有各自的特性。所以在选择存放目录时，一定要认真选择适合的目录。 “应用程序包”: 这里面存放的是应用程序的源文件，包括资源文件和可执行文件。 Documents: 最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。 12NSString *path = [[NSBundle mainBundle] bundlePath];NSLog(@\"%@\", path); Library/Caches: iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。 12NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;NSLog(@\"%@\", path); Library/Preferences: iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。 12NSString *path = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).firstObject;NSLog(@\"%@\", path); tmp: iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。 12NSString *path = NSTemporaryDirectory();NSLog(@\"%@\", path); plist文件 plist文件是将某些特定的类，通过XML文件的方式保存在目录中。 可以被序列化的类型只有如下几种： 12345678910NSArray;NSMutableArray;NSDictionary;NSMutableDictionary;NSData;NSMutableData;NSString;NSMutableString;NSNumber;NSDate; 1.获得文件路径12NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;NSString *fileName = [path stringByAppendingPathComponent:@\"123.plist\"]; 2.存储12NSArray *array = @[@\"123\", @\"456\", @\"789\"];[array writeToFile:fileName atomically:YES]; 3.读取12NSArray *result = [NSArray arrayWithContentsOfFile:fileName];NSLog(@\"%@\", result); 4.注意123// 只有以上列出的类型才能使用plist文件存储。// 存储时使用writeToFile: atomically:方法。 其中atomically表示是否需要先写入一个辅助文件，再把辅助文件拷贝到目标文件地址。这是更安全的写入文件方法，一般都写YES。// 读取时使用arrayWithContentsOfFile:方法。 Preference1.使用方法12345678910111213141516//1.获得NSUserDefaults文件NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];//2.向文件中写入内容[userDefaults setObject:@\"AAA\" forKey:@\"a\"];[userDefaults setBool:YES forKey:@\"sex\"];[userDefaults setInteger:21 forKey:@\"age\"];//2.1立即同步[userDefaults synchronize];//3.读取文件NSString *name = [userDefaults objectForKey:@\"a\"];BOOL sex = [userDefaults boolForKey:@\"sex\"];NSInteger age = [userDefaults integerForKey:@\"age\"];NSLog(@\"%@, %d, %ld\", name, sex, age); 2.注意123// 偏好设置是专门用来保存应用程序的配置信息的，一般不要在偏好设置中保存其他数据。// 如果没有调用synchronize方法，系统会根据I/O情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用synchronize方法。// 偏好设置会将所有数据保存到同一个文件中。即preference目录下的一个以此应用包名来命名的plist文件。 NSKeyedArchiver 归档在iOS中是另一种形式的序列化，只要遵循了NSCoding协议的对象都可以通过它实现序列化。由于决大多数支持存储数据的Foundation和Cocoa Touch类都遵循了NSCoding协议，因此，对于大多数类来说，归档相对而言还是比较容易实现的。 1.遵循NSCoding协议 NSCoding协议声明了两个方法，这两个方法都是必须实现的。一个用来说明如何将对象编码到归档中，另一个说明如何进行解档来获取一个新对象。 遵循协议和设置属性 123456//1.遵循NSCoding协议 @interface Person : NSObject //2.设置属性@property (strong, nonatomic) UIImage *avatar;@property (copy, nonatomic) NSString *name;@property (assign, nonatomic) NSInteger age;@end 实现协议方法 12345678910111213141516//解档- (id)initWithCoder:(NSCoder *)aDecoder &#123; if ([super init]) &#123; self.avatar = [aDecoder decodeObjectForKey:@\"avatar\"]; self.name = [aDecoder decodeObjectForKey:@\"name\"]; self.age = [aDecoder decodeIntegerForKey:@\"age\"]; &#125; return self;&#125;//归档- (void)encodeWithCoder:(NSCoder *)aCoder &#123; [aCoder encodeObject:self.avatar forKey:@\"avatar\"]; [aCoder encodeObject:self.name forKey:@\"name\"]; [aCoder encodeInteger:self.age forKey:@\"age\"];&#125; 特别注意 1如果需要归档的类是某个自定义类的子类时，就需要在归档和解档之前先实现父类的归档和解档方法。即 [super encodeWithCoder:aCoder] 和 [super initWithCoder:aDecoder] 方法; 2.使用需要把对象归档是调用NSKeyedArchiver的工厂方法 archiveRootObject: toFile:方法。 123456NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@\"person.data\"];Person *person = [[Person alloc] init];person.avatar = self.avatarView.image;person.name = self.nameField.text;person.age = [self.ageField.text integerValue];[NSKeyedArchiver archiveRootObject:person toFile:file]; 需要从文件中解档对象就调用NSKeyedUnarchiver的一个工厂方法 unarchiveObjectWithFile: 即可。 12345678NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@\"person.data\"];Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:file];if (person) &#123; self.avatarView.image = person.avatar; self.nameField.text = person.name; self.ageField.text = [NSString stringWithFormat:@\"%ld\", person.age];&#125; 3.注意123必须遵循并实现NSCoding协议保存文件的扩展名可以任意指定继承时必须先调用父类的归档解档方法 SQLite3 之前的所有存储方法，都是覆盖存储。如果想要增加一条数据就必须把整个文件读出来，然后修改数据后再把整个内容覆盖写入文件。所以它们都不适合存储大量的内容。 1.字段类型表面上·SQLite·将数据分为以下几种类型： 1234integer : 整数real : 实数（浮点数）text : 文本字符串blob : 二进制数据，比如文件，图片之类的 实际上SQLite是无类型的。即不管你在创表时指定的字段类型是什么，存储是依然可以存储任意类型的数据。而且在创表时也可以不指定字段类型。SQLite之所以什么类型就是为了良好的编程规范和方便开发人员交流，所以平时在使用时最好设置正确的字段类型！主键必须设置成integer 2. 准备工作准备工作就是导入依赖库啦，在iOS中要使用SQLite3，需要添加库文件：libsqlite3.dylib并导入主头文件，这是一个C语言的库，所以直接使用SQLite3还是比较麻烦的。 3.使用1.创建数据库并打开操作数据库之前必须先指定数据库文件和要操作的表，所以使用SQLite3，首先要打开数据库文件，然后指定或创建一张表。 12345678910111213141516171819202122232425262728293031// 打开数据库并创建一个表- (void)openDatabase &#123; //1.设置文件名 NSString *filename = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@\"person.db\"]; //2.打开数据库文件，如果没有会自动创建一个文件 NSInteger result = sqlite3_open(filename.UTF8String, &amp;_sqlite3); if (result == SQLITE_OK) &#123; NSLog(@\"打开数据库成功！\"); //3.创建一个数据库表 char *errmsg = NULL; sqlite3_exec(_sqlite3, \"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)\", NULL, NULL, &amp;errmsg); if (errmsg) &#123; NSLog(@\"错误：%s\", errmsg); &#125; else &#123; NSLog(@\"创表成功！\"); &#125; &#125; else &#123; NSLog(@\"打开数据库失败！\"); &#125;&#125; 2.执行指令使用 sqlite3_exec() 方法可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据。 1234567891011121314151617181920// 往表中插入1000条数据- (void)insertData &#123; NSString *nameStr; NSInteger age; for (NSInteger i = 0; i &lt; 1000; i++) &#123; nameStr = [NSString stringWithFormat:@\"Bourne-%d\", arc4random_uniform(10000)]; age = arc4random_uniform(80) + 20; NSString *sql = [NSString stringWithFormat:@\"INSERT INTO t_person (name, age) VALUES('%@', '%ld')\", nameStr, age]; char *errmsg = NULL; sqlite3_exec(_sqlite3, sql.UTF8String, NULL, NULL, &amp;errmsg); if (errmsg) &#123; NSLog(@\"错误：%s\", errmsg); &#125; &#125; NSLog(@\"插入完毕！\"); &#125; 3.查询指令前面说过一般不使用 sqlite3_exec() 方法查询数据。因为查询数据必须要获得查询结果，所以查询相对比较麻烦。示例代码如下： 123456789101112131415161718192021222324252627// sqlite3_prepare_v2() : 检查sql的合法性// sqlite3_step() : 逐行获取查询结果，不断重复，直到最后一条记录// sqlite3_coloum_xxx() : 获取对应类型的内容，iCol对应的就是SQL语句中字段的顺序，从0开始。根据实际查询字段的属性，使用sqlite3_column_xxx取得对应的内容即可。// sqlite3_finalize() : 释放stmt// 从表中读取数据到数组中- (void)readData &#123; NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1000]; char *sql = \"select name, age from t_person;\"; sqlite3_stmt *stmt; NSInteger result = sqlite3_prepare_v2(_sqlite3, sql, -1, &amp;stmt, NULL); if (result == SQLITE_OK) &#123; while (sqlite3_step(stmt) == SQLITE_ROW) &#123; char *name = (char *)sqlite3_column_text(stmt, 0); NSInteger age = sqlite3_column_int(stmt, 1); //创建对象 Person *person = [Person personWithName:[NSString stringWithUTF8String:name] Age:age]; [mArray addObject:person]; &#125; self.dataList = mArray; &#125; sqlite3_finalize(stmt);&#125; 4.总结总得来说，SQLite3的使用还是比较麻烦的，因为都是些c语言的函数，理解起来有些困难。不过在一般开发过程中，使用的都是第三方开源库 FMDB，封装了这些基本的c语言方法，使得我们在使用时更加容易理解，提高开发效率。 FMDB1.简介 FMDB是iOS平台的SQLite数据库框架，它是以OC的方式封装了SQLite的C语言API，它相对于cocoa自带的C语言框架有如下的优点:使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码对比苹果自带的Core Data框架，更加轻量级和灵活提供了多线程安全的数据库操作方法，有效地防止数据混乱 2.核心类FMDB有三个主要的类： 12345678// FMDatabase一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句// FMResultSet使用FMDatabase执行查询后的结果集// FMDatabaseQueue用于在多线程中执行多个查询或更新，它是线程安全的 3.打开数据库 和c语言框架一样，FMDB通过指定SQLite数据库文件路径来创建FMDatabase对象，但FMDB更加容易理解，使用起来更容易，使用之前一样需要导入sqlite3.dylib。打开数据库方法如下： 1234567NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@\"person.db\"];FMDatabase *database = [FMDatabase databaseWithPath:path]; if (![database open]) &#123; NSLog(@\"数据库打开失败！\");&#125; 值得注意的是，Path的值可以传入以下三种情况： 123// 具体文件路径，如果不存在会自动创建// 空字符串@\"\"，会在临时目录创建一个空的数据库，当FMDatabase连接关闭时，数据库文件也被删除// nil，会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁 4.更新 在FMDB中，除查询以外的所有操作，都称为“更新”, 如：create、drop、insert、update、delete等操作，使用executeUpdate:方法执行更新： 123456789101112//常用方法有以下 3 种： - (BOOL)executeUpdate:(NSString*)sql, ...- (BOOL)executeUpdateWithFormat:(NSString*)format, ...- (BOOL)executeUpdate:(NSString*)sql withArgumentsInArray:(NSArray *)arguments//示例[database executeUpdate:@\"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)\"]; //或者 [database executeUpdate:@\"INSERT INTO t_person(name, age) VALUES(?, ?)\", @\"Bourne\", [NSNumber numberWithInt:42]]; 5.查询查询方法也有3种，使用起来相当简单： 123- (FMResultSet *)executeQuery:(NSString*)sql, ...- (FMResultSet *)executeQueryWithFormat:(NSString*)format, ...- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments 查询示例： 123456789//1.执行查询FMResultSet *result = [database executeQuery:@\"SELECT * FROM t_person\"];//2.遍历结果集while ([result next]) &#123; NSString *name = [result stringForColumn:@\"name\"]; int age = [result intForColumn:@\"age\"];&#125; 6.线程安全 在多个线程中同时使用一个 FMDatabase 实例是不明智的。不要让多个线程分享同一个FMDatabase实例，它无法在多个线程中同时使用。 如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题。所以，请使用 FMDatabaseQueue，它是线程安全的。以下是使用方法： 创建队列。 123456789101112131415161718192021222324FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];// 使用队列[queue inDatabase:^(FMDatabase *database)&#123; [database executeUpdate:@\"INSERT INTO t_person(name, age) VALUES (?, ?)\", @\"Bourne_1\", [NSNumber numberWithInt:1]]; [database executeUpdate:@\"INSERT INTO t_person(name, age) VALUES (?, ?)\", @\"Bourne_2\", [NSNumber numberWithInt:2]]; [database executeUpdate:@\"INSERT INTO t_person(name, age) VALUES (?, ?)\", @\"Bourne_3\", [NSNumber numberWithInt:3]]; FMResultSet *result = [database executeQuery:@\"select * from t_person\"]; while([result next]) &#123; &#125; &#125;];// 而且可以轻松地把简单任务包装到事务里：[queue inTransaction:^(FMDatabase *database, BOOL *rollback) &#123; [database executeUpdate:@\"INSERT INTO t_person(name, age) VALUES (?, ?)\", @\"Bourne_1\", [NSNumber numberWithInt:1]]; [database executeUpdate:@\"INSERT INTO t_person(name, age) VALUES (?, ?)\", @\"Bourne_2\", [NSNumber numberWithInt:2]]; [database executeUpdate:@\"INSERT INTO t_person(name, age) VALUES (?, ?)\", @\"Bourne_3\", [NSNumber numberWithInt:3]]; FMResultSet *result = [database executeQuery:@\"select * from t_person\"]; while([result next]) &#123; &#125; //回滚 *rollback = YES; &#125;]; FMDatabaseQueue 后台会建立系列化的GCD队列，并执行你传给GCD队列的块。这意味着 你从多线程同时调用调用方法，GCD也会按它接收的块的顺序来执行了。","content":"<p>文章大纲，便于浏览</p>\n<ol>\n<li><a href=\"https://github.com/liberalisman/2018-Interview-Preparation#01-ios-app-startup-process\" target=\"_blank\" rel=\"external\">01-iOS程序启动过程</a></li>\n<li><a href=\"https://github.com/liberalisman/2018-Interview-Preparation#02-shallowcopy-deepcopy\" target=\"_blank\" rel=\"external\">02-浅拷贝-深拷贝</a></li>\n<li><a href=\"https://github.com/liberalisman/2018-Interview-Preparation#03-view的生命周期\" target=\"_blank\" rel=\"external\">03-View的生命周期</a></li>\n</ol>\n<a id=\"more\"></a>\n<ol>\n<li><a href=\"https://github.com/liberalisman/2018-Interview-Preparation#04-property\" target=\"_blank\" rel=\"external\">04-@property</a></li>\n<li><a href=\"https://github.com/liberalisman/iOS-Summary-Part1#05-事件传递和事件响应\" target=\"_blank\" rel=\"external\">05-事件传递和事件响应</a></li>\n<li><a href=\"https://github.com/liberalisman/iOS-Summary-Part1#06-kvc\" target=\"_blank\" rel=\"external\">06-KVC</a></li>\n<li><a href=\"https://github.com/liberalisman/iOS-Summary-Part1#07-kvo\" target=\"_blank\" rel=\"external\">07-KVO</a></li>\n<li><a href=\"https://github.com/liberalisman/iOS-Summary-Part1#08-ios数据持久化方案\" target=\"_blank\" rel=\"external\">08-iOS数据持久化方案</a></li>\n</ol>\n<h2 id=\"01-iOS-App-startup-process\"><a href=\"#01-iOS-App-startup-process\" class=\"headerlink\" title=\"01-iOS-App-startup-process\"></a>01-iOS-App-startup-process</h2><p>###一、启动完整过程</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png\" alt=\"\"></p>\n<p>1.<code>main</code>函数</p>\n<p>2.<code>UIApplicationMain</code>函数</p>\n<ul>\n<li>创建<code>UIApplication</code>对象</li>\n<li>创建<code>UIApplication的delegate</code>对象</li>\n</ul>\n<p>3.<code>delegate</code>对象开始处理(监听)系统事件(没有storyboard)</p>\n<ul>\n<li>程序启动完毕的时候, 就会调用代理的:<code>didFinishLaunchingWithOptions:</code>方法</li>\n<li>在<code>application:didFinishLaunchingWithOptions</code>:中创建<code>UIWindow</code> 创建和设置<code>UIWindow</code>的<code>rootViewController</code></li>\n<li>显示窗口</li>\n</ul>\n<p>4.根据<code>Info.plist</code>获得最主要<code>storyboard</code>的文件名,加载最主要的<code>storyboard</code>(有storyboard)</p>\n<ul>\n<li>创建<code>UIWindow</code></li>\n<li>创建和设置<code>UIWindow</code>的<code>rootViewController</code></li>\n<li>显示窗口</li>\n</ul>\n<p>###二、程序启动原理</p>\n<p>1.<code>main</code>函数中执行了一个<code>UIApplicationMain</code>这个函数</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">UIApplicationMain</span>(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[], <span class=\"built_in\">NSString</span> *principalClassName, <span class=\"built_in\">NSString</span> *delegateClassName);</div><div class=\"line\"></div><div class=\"line\">argc、argv：直接传递给<span class=\"built_in\">UIApplicationMain</span>进行相关处理即可</div></pre></td></tr></table></figure>\n<p>2.<code>principalClassName</code>：指定应用程序类名（app的象征），该类必须是<code>UIApplication</code>(或子类)。如果为<code>nil</code>,则用<code>UIApplication</code>类作为默认值</p>\n<p>3.<code>delegateClassName</code>：指定应用程序的代理类，该类必须遵守<code>UIApplicationDelegate</code>协议</p>\n<p>4.<code>UIApplicationMain</code>函数会根据<code>principalClassName</code>创建<code>UIApplication</code>对象，根据<code>delegateClassName</code>创建一个<code>delegate</code>对象，并将该<code>delegate</code>对象赋值给<code>UIApplication</code>对象中的<code>delegate</code>属性</p>\n<p>5.接着会建立应用程序的<code>Main Runloop</code>（事件循环），进行事件的处理(首先会在程序完毕后调用<code>delegate</code>对象的<code>application:didFinishLaunchingWithOptions</code>:方法)</p>\n<p>程序正常退出时<code>UIApplicationMain</code>函数才返回</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * argv[])&#123; <span class=\"keyword\">@autoreleasepool</span> &#123; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* argc: 系统或者用户传入的参数个数</div><div class=\"line\">* argv: 系统或者用户传入的实际参数 </div><div class=\"line\">* 1.根据传入的第三个参数创建UIApplication对象 </div><div class=\"line\">* 2.根据传入的第四个产生创建UIApplication对象的代理</div><div class=\"line\">* 3.设置刚刚创建出来的代理对象为UIApplication的代理 </div><div class=\"line\">* 4.开启一个事件循环 </div><div class=\"line\">**/ </div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">UIApplicationMain</span>(argc, argv, <span class=\"string\">@\"UIApplication\"</span>, <span class=\"string\">@\"YYAppDelegate\"</span>); &#125;&#125;</div></pre></td></tr></table></figure>\n<p>启动与代理：<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E4%B8%8E%E4%BB%A3%E7%90%86.png\" alt=\"\"></p>\n<h2 id=\"02-ShallowCopy-DeepCopy\"><a href=\"#02-ShallowCopy-DeepCopy\" class=\"headerlink\" title=\"02-ShallowCopy-DeepCopy\"></a>02-ShallowCopy-DeepCopy</h2><p>简要总结一下什么是浅拷贝，什么是深拷贝</p>\n<blockquote>\n<p>深拷贝就是内容拷贝</p>\n<p>浅拷贝就是指针拷贝</p>\n</blockquote>\n<p>###一.系统对象的 copy/mutableCopy</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *string = <span class=\"string\">@\"LiMing\"</span>;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"built_in\">NSString</span> *copyString = [string <span class=\"keyword\">copy</span>];</div><div class=\"line\">    </div><div class=\"line\"><span class=\"built_in\">NSString</span> *mutableString = [string mutableCopy];</div><div class=\"line\">    </div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"string = %p\"</span>,string);</div><div class=\"line\">    </div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"copyString = %p\"</span>,copyString);</div><div class=\"line\">    </div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"mutableString = %p \"</span>,mutableString);</div><div class=\"line\"></div><div class=\"line\">结论：</div><div class=\"line\"><span class=\"number\">1.</span>string 和 copyString 他们只是二个不同的指针，指向内存中的同一块地址，<span class=\"keyword\">copy</span> 只是指针复制</div><div class=\"line\"><span class=\"number\">2.</span>string 和 mutableString 打印出来的地址不同，是因为两个指针指向的地址本就不同，mutableCopy 是内容复制</div><div class=\"line\"></div><div class=\"line\">注意：其他对象 <span class=\"built_in\">NSArray</span> 、<span class=\"built_in\">NSMutableArray</span> 、<span class=\"built_in\">NSDictionary</span> 、<span class=\"built_in\">NSMutableDictionary</span> 一样适用</div></pre></td></tr></table></figure>\n<p>规律可以从这张图看出来</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D-01\" alt=\"\"></p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D-02\" alt=\"\"></p>\n<p>###二.自定义对象实现 Copy-MutableCopy</p>\n<ul>\n<li>copy</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">GZQPerson *person = [[GZQPerson alloc] init];</div><div class=\"line\">person.age = <span class=\"number\">20</span>;</div><div class=\"line\">person.name = <span class=\"string\">@\"GZQ\"</span>;</div><div class=\"line\">GZQPerson *copyP = [person <span class=\"keyword\">copy</span>];  <span class=\"comment\">// 这里崩溃</span></div></pre></td></tr></table></figure>\n<p>崩溃：<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D-03.png\" alt=\"\"></p>\n<p>看崩溃信息GZQPerson应该先实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">id</span>)copyWithZone:(<span class=\"built_in\">NSZone</span> *)zone;</div></pre></td></tr></table></figure>\n<p>测试：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"GZQPerson.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">GZQPerson</span> ()&lt;<span class=\"title\">NSCopying</span>,<span class=\"title\">NSMutableCopying</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">GZQPerson</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">id</span>)copyWithZone:(<span class=\"built_in\">NSZone</span> *)zone &#123;</div><div class=\"line\"></div><div class=\"line\">    GZQPerson *person = [[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] allocWithZone:zone] init];</div><div class=\"line\">    person.age = <span class=\"keyword\">self</span>.age;</div><div class=\"line\">    person.name = <span class=\"keyword\">self</span>.name;</div><div class=\"line\">    <span class=\"keyword\">return</span> person;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">id</span>)mutableCopyWithZone:(<span class=\"built_in\">NSZone</span> *)zone &#123;</div><div class=\"line\"></div><div class=\"line\">    GZQPerson *person = [[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] allocWithZone:zone] init];</div><div class=\"line\">    person.age = <span class=\"keyword\">self</span>.age;</div><div class=\"line\">    person.name = <span class=\"keyword\">self</span>.name;</div><div class=\"line\">    <span class=\"keyword\">return</span> person;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"ViewController.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"GZQPerson.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    </div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    GZQPerson *person = [[GZQPerson alloc] init];</div><div class=\"line\">    person.age = <span class=\"number\">20</span>;</div><div class=\"line\">    person.name = <span class=\"string\">@\"GZQ\"</span>;</div><div class=\"line\">    GZQPerson *copyP = [person <span class=\"keyword\">copy</span>];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"copyP=%p\"</span>,copyP);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"person=%p\"</span>,person);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"person=%p\"</span>,copyP.name);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"person=%p\"</span>,person.name);</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D-04.png\" alt=\"\"></p>\n<p>可以看出虽然指针的地址不同，但是存储的地址是一致的。</p>\n<p>###三.copy 本质</p>\n<p><code>property copy</code> 实际上就对name干了这个：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\">property <span class=\"keyword\">copy</span> 实际上就对name干了这个：</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name</div><div class=\"line\">&#123;</div><div class=\"line\">    _name = [name <span class=\"keyword\">copy</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>strong</code>是不执行<code>Copy</code>操作的</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *name;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSMutableString</span> *string = [<span class=\"built_in\">NSMutableString</span> stringWithFormat:<span class=\"string\">@\"深拷贝-浅拷贝\"</span>];</div><div class=\"line\"></div><div class=\"line\">GZQPerson *person = [[GZQPerson alloc] init];</div><div class=\"line\">person.name = string;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 可以改变person.name的值，因为其内部没有生成新的对象</span></div><div class=\"line\">[string appendString:<span class=\"string\">@\"LALALA\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"name = %@\"</span>, person.name);</div></pre></td></tr></table></figure>\n<h2 id=\"03-View的生命周期\"><a href=\"#03-View的生命周期\" class=\"headerlink\" title=\"03-View的生命周期\"></a>03-View的生命周期</h2><ul>\n<li>读懂这一张图即可<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/View%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"04-property\"><a href=\"#04-property\" class=\"headerlink\" title=\"04-@property\"></a>04-@property</h2><blockquote>\n<p>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</p>\n</blockquote>\n<p>@property 的本质.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> = ivar + <span class=\"keyword\">getter</span> + <span class=\"keyword\">setter</span>;</div></pre></td></tr></table></figure>\n<p>下面解释下：</p>\n<blockquote>\n<p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p>\n<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p>\n</blockquote>\n<p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> = <span class=\"keyword\">getter</span> + <span class=\"keyword\">setter</span>;</div></pre></td></tr></table></figure>\n<p>例如下面这个类：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Person</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSString</span> *firstName;</div><div class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSString</span> *lastName;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>上述代码写出来的类与下面这种写法等效：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Person</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)firstName;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)setFirstName:(<span class=\"built_in\">NSString</span> *)firstName;</div><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)lastName;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)setLastName:(<span class=\"built_in\">NSString</span> *)lastName;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p><code>property</code>在<code>runtime</code>中是<code>objc_property_t</code>定义如下:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_property *objc_property_t;</div></pre></td></tr></table></figure>\n<p>而<code>objc_property</code>是一个结构体，包括<code>name</code>和<code>attributes</code>，定义如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> property_t &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *attributes;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>而<code>attributes</code>本质是<code>objc_property_attribute_t</code>，定义了<code>property</code>的一些属性，定义如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/// Defines a property attribute</span></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;           <span class=\"comment\">/**&lt; The name of the attribute */</span></div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *value;          <span class=\"comment\">/**&lt; The value of the attribute (usually empty) */</span></div><div class=\"line\">&#125; objc_property_attribute_t;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。</p>\n</blockquote>\n<p>例如：我们定义一个<code>string</code>的<code>property</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *string;</div></pre></td></tr></table></figure>\n<p>通过 <code>property_getAttributes(property)</code>获取到<code>attributes</code>并打印出来之后的结果为</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">T<span class=\"string\">@\"NSString\"</span>,C,N,V_string</div></pre></td></tr></table></figure>\n<p>其中<code>T</code>就代表类型，可参阅<code>Type Encodings</code>，<code>C</code>就代表<code>Copy</code>，<code>N</code>代表<code>nonatomic</code>，<code>V</code>就代表对于的实例变量。</p>\n<blockquote>\n<p>ivar、getter、setter 是如何生成并添加到这个类中的?</p>\n</blockquote>\n<p><strong>“自动合成”( autosynthesis)</strong></p>\n<blockquote>\n<p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过@synthesize 语法来指定实例变量的名字.</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Person</span></span></div><div class=\"line\"><span class=\"keyword\">@synthesize</span> firstName = _myFirstName;</div><div class=\"line\"><span class=\"keyword\">@synthesize</span> lastName = _myLastName;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p><strong>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1.</span> OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。</div><div class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">setter</span> 与 <span class=\"keyword\">getter</span> 方法对应的实现函数</div><div class=\"line\"><span class=\"number\">3.</span> ivar_list ：成员变量列表</div><div class=\"line\"><span class=\"number\">4.</span> method_list ：方法列表</div><div class=\"line\"><span class=\"number\">5.</span> prop_list ：属性列表</div><div class=\"line\">也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 <span class=\"keyword\">setter</span> 与 <span class=\"keyword\">getter</span> 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 <span class=\"keyword\">setter</span> 与 <span class=\"keyword\">getter</span> 方法对应的实现,在 <span class=\"keyword\">setter</span> 方法中从偏移量的位置开始赋值,在 <span class=\"keyword\">getter</span> 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</div></pre></td></tr></table></figure>\n<p><strong>属性可以拥有的特质分为四类:</strong></p>\n<ul>\n<li><p>原子性— nonatomic 特质,在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</p>\n</li>\n<li><p>读/写权限—readwrite(读写)、readonly (只读)</p>\n</li>\n<li><p>内存管理语义—assign、strong、 weak、unsafe_unretained、copy</p>\n</li>\n<li>方法名—getter=<name> 、setter=<name></name></name></li>\n</ul>\n<p><strong>getter=<name>的样式：</name></strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">getter</span>=isOn) <span class=\"built_in\">BOOL</span> on;</div><div class=\"line\">     </div><div class=\"line\">(`<span class=\"keyword\">setter</span>=`这种不常用，也不推荐使用。故不在这里给出写法。）</div></pre></td></tr></table></figure>\n<p><strong>setter=<name>一般用在特殊的情境下，比如</name></strong>：</p>\n<blockquote>\n<p>在数据反序列化、转模型的过程中，服务器返回的字段如果以 init 开头，所以你需要定义一个 init 开头的属性，但默认生成的 setter 与 getter 方法也会以 init 开头，而编译器会把所有以 init 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。</p>\n</blockquote>\n<p><strong>这时你就可以使用下面的方式来避免编译器报错：</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">getter</span>=p_initBy, <span class=\"keyword\">setter</span>=setP_initBy:)<span class=\"built_in\">NSString</span> *initBy;</div></pre></td></tr></table></figure>\n<p><strong>另外也可以用关键字进行特殊说明，来避免编译器报错</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readwrite</span>, <span class=\"keyword\">copy</span>, <span class=\"keyword\">null_resettable</span>) <span class=\"built_in\">NSString</span> *initBy;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)initBy __attribute__((objc_method_family(none)));</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">1.</span> 不常用的：<span class=\"keyword\">nonnull</span>,<span class=\"keyword\">null_resettable</span>,<span class=\"keyword\">nullable</span></div><div class=\"line\"></div><div class=\"line\">注意：很多人会认为如果属性具备 <span class=\"keyword\">nonatomic</span> 特质，则不使用 “同步锁”。其实在属性设置方法中使用的是自旋锁，自旋锁相关代码如下：</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> reallySetProperty(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, <span class=\"keyword\">id</span> newValue, ptrdiff_t offset, <span class=\"keyword\">bool</span> atomic, <span class=\"keyword\">bool</span> <span class=\"keyword\">copy</span>, <span class=\"keyword\">bool</span> mutableCopy)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (offset == <span class=\"number\">0</span>) </div><div class=\"line\">    &#123;</div><div class=\"line\">        object_setClass(<span class=\"keyword\">self</span>, newValue);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">id</span> oldValue;</div><div class=\"line\">    <span class=\"keyword\">id</span> *slot = (<span class=\"keyword\">id</span>*) ((<span class=\"keyword\">char</span>*)<span class=\"keyword\">self</span> + offset);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">copy</span>) </div><div class=\"line\">    &#123;</div><div class=\"line\">        newValue = [newValue copyWithZone:<span class=\"literal\">nil</span>];</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mutableCopy) </div><div class=\"line\">    &#123;</div><div class=\"line\">        newValue = [newValue mutableCopyWithZone:<span class=\"literal\">nil</span>];</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"keyword\">else</span> </div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (*slot == newValue) <span class=\"keyword\">return</span>;</div><div class=\"line\">        newValue = objc_retain(newValue);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!atomic) </div><div class=\"line\">    &#123;</div><div class=\"line\">        oldValue = *slot;</div><div class=\"line\">        *slot = newValue;</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"keyword\">else</span> </div><div class=\"line\">    &#123;</div><div class=\"line\">        spinlock_t&amp; slotlock = PropertyLocks[slot];</div><div class=\"line\">        slotlock.lock();</div><div class=\"line\">        oldValue = *slot;</div><div class=\"line\">        *slot = newValue;        </div><div class=\"line\">        slotlock.unlock();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    objc_release(oldValue);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">void</span> objc_setProperty(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, ptrdiff_t offset, <span class=\"keyword\">id</span> newValue, <span class=\"built_in\">BOOL</span> atomic, <span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> shouldCopy) </div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">copy</span> = (shouldCopy &amp;&amp; shouldCopy != MUTABLE_COPY);</div><div class=\"line\">    <span class=\"keyword\">bool</span> mutableCopy = (shouldCopy == MUTABLE_COPY);</div><div class=\"line\">    reallySetProperty(<span class=\"keyword\">self</span>, _cmd, newValue, offset, atomic, <span class=\"keyword\">copy</span>, mutableCopy);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"05-事件传递和事件响应\"><a href=\"#05-事件传递和事件响应\" class=\"headerlink\" title=\"05-事件传递和事件响应\"></a>05-事件传递和事件响应</h2><p>这部分知识如果自己总结，篇幅较长。可以参考<a href=\"http://www.jianshu.com/p/2e074db792ba\" target=\"_blank\" rel=\"external\">以下文章</a></p>\n<h2 id=\"06-KVC\"><a href=\"#06-KVC\" class=\"headerlink\" title=\"06-KVC\"></a>06-KVC</h2><p><strong>Key-Value Coding (KVC)</strong></p>\n<blockquote>\n<p>KVC（Key-value coding）键值编码，单看这个名字可能不太好理解。其实翻译一下就很简单了，就是指iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值。而不需要调用明确的存取方法。这样就可以在运行时动态在访问和修改对象的属性。而不是在编译时确定，这也是iOS开发中的黑魔法之一。很多高级的iOS开发技巧都是基于KVC实现的。目前网上关于KVC的文章在非常多，有的只是简单地说了下用法，有的讲得深入但是在使用场景和最佳实践没有说明，我写下这遍文章就是给大家详解一个最完整最详细的KVC。</p>\n</blockquote>\n<p><strong>KVC在iOS中的定义</strong></p>\n<p>无论是<code>Swift</code>还是<code>Objective-C</code>，<code>KVC</code>的定义都是对<code>NSObject</code>的扩展来实现的(<code>Objective-C</code>中有个显式的<code>NSKeyValueCoding</code>类别名，而<code>Swift</code>没有，也不需要)所以对于所有继承了<code>NSObject</code>在类型，都能使用<code>KVC</code>(一些纯<code>Swift</code>类和结构体是不支持<code>KVC</code>的)，下面是<code>KVC</code>最为重要的四个方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)valueForKey:(<span class=\"built_in\">NSString</span> *)key;                          <span class=\"comment\">//直接通过Key来取值</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forKey:(<span class=\"built_in\">NSString</span> *)key;          <span class=\"comment\">//通过Key来设值</span></div><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)valueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath;                  <span class=\"comment\">//通过KeyPath来取值</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath;  <span class=\"comment\">//通过KeyPath来设值</span></div></pre></td></tr></table></figure>\n<p>当然<code>NSKeyValueCoding</code>类别中还有其他的一些方法，下面列举一些</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"built_in\">BOOL</span>)accessInstanceVariablesDirectly;</div><div class=\"line\"><span class=\"comment\">//默认返回YES，表示如果没有找到Set&lt;Key&gt;方法的话，会按照_key，_iskey，key，iskey的顺序搜索成员，设置成NO就不这样搜索</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)validateValue:(<span class=\"keyword\">inout</span> <span class=\"keyword\">id</span> __<span class=\"keyword\">nullable</span> * __<span class=\"keyword\">nonnull</span>)ioValue forKey:(<span class=\"built_in\">NSString</span> *)inKey error:(<span class=\"keyword\">out</span> <span class=\"built_in\">NSError</span> **)outError;</div><div class=\"line\"><span class=\"comment\">//KVC提供属性值确认的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</span></div><div class=\"line\">- (<span class=\"built_in\">NSMutableArray</span> *)mutableArrayValueForKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\"><span class=\"comment\">//这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回</span></div><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)valueForUndefinedKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\"><span class=\"comment\">//如果Key不存在，且没有KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forUndefinedKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\"><span class=\"comment\">//和上一个方法一样，只不过是设值。</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setNilValueForKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\"><span class=\"comment\">//如果你在SetValue方法时面给Value传nil，则会调用这个方法</span></div><div class=\"line\">- (<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *, <span class=\"keyword\">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keys;</div><div class=\"line\"><span class=\"comment\">//输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。</span></div></pre></td></tr></table></figure>\n<p>上面的这些方法在碰到特殊情况或者有特殊需求还是会用到的，所以也是可以了解一下。后面的代码示例会有讲到其中的一些方法。<br>同时苹果对一些容器类比如NSArray或者NSSet等，KVC有着特殊的实现。建议有基础的或者英文好的开发者直接去看苹果的官方文档，相信你会对KVC的理解更上一个台阶。</p>\n<p><strong>KVC是怎么寻找Key的</strong></p>\n<p>KVC是怎么使用的，我相信绝大多数的开发者都很清楚，我在这里就不再写简单的使用KVC来设值和取值的代码了，首页我们来探讨KVC在内部是按什么样的顺序来寻找key的。<br>当调用<code>setValue：</code>属性值 <code>forKey：``@”name“</code>的代码时，底层的执行机制如下：</p>\n<ul>\n<li><p>程序优先调用<code>set&lt;Key&gt;:</code>属性值方法，代码通过<code>setter</code>方法完成设置。注意，这里的<code>&lt;key&gt;</code>是指成员变量名，首字母大清写要符合<code>KVC</code>的全名规则，下同</p>\n</li>\n<li><p>如果没有找到<code>setName：</code>方法，<code>KVC</code>机制会检查<code>+ (BOOL)accessInstanceVariablesDirectly</code>方法有没有返回<code>YES</code>，默认该方法会返回<code>YES</code>，如果你重写了该方法让其返回<code>NO</code>的话，那么在这一步KVC会执行<code>setValue：forUNdefinedKey：</code>方法，不过一般开发者不会这么做。所以KVC机制会搜索该类里面有没有名为<code>_&lt;key&gt;</code>的成员变量，无论该变量是在类接口部分定义，还是在类实现部分定义，也无论用了什么样的访问修饰符，只在存在以<code>_&lt;key&gt;</code>命名的变量，<code>KVC</code>都可以对该成员变量赋值。</p>\n</li>\n<li><p>如果该类即没有<code>set&lt;Key&gt;：</code>方法，也没有<code>_&lt;key&gt;</code>成员变量，<code>KVC</code>机制会搜索<code>_is&lt;Key&gt;</code>的成员变量，</p>\n</li>\n<li><p>和上面一样，如果该类即没有<code>set&lt;Key&gt;：</code>方法，也没有<code>_&lt;key&gt;</code>和<code>_is&lt;Key&gt;</code>成员变量，<code>KVC</code>机制再会继续搜索<code>&lt;key&gt;</code>和<code>is&lt;Key&gt;</code>的成员变量。再给它们赋值。</p>\n</li>\n<li><p>如果上面列出的方法或者成员变量都不存在，系统将会执行该对象的<code>setValue：forUNdefinedKey：</code>方法，默认是抛出异常。</p>\n</li>\n</ul>\n<p>如果开发者想让这个类禁用<code>KVC</code>里，那么重写<code>+ (BOOL)accessInstanceVariablesDirectly</code>方法让其返回NO即可，这样的话如果<code>KVC</code>没有找到<code>set&lt;Key&gt;:</code>属性名时，会直接用<code>setValue：forUNdefinedKey：</code>方法。</p>\n<h2 id=\"07-KVO\"><a href=\"#07-KVO\" class=\"headerlink\" title=\"07-KVO\"></a>07-KVO</h2><p><code>KVO</code>，全称为<code>Key-Value Observing</code>，是iOS中的一种设计模式，用于检测对象的某些属性的实时变化情况并作出响应。当应用场景比较复杂时，多个地方存在crash的危险。</p>\n<p>首先，假设我们的目标是在一个<code>UITableViewController</code>内对<code>tableview</code>的<code>contentOffset</code>进行实时监测，很容易地使用<code>KVO</code>来实现为。</p>\n<p>在初始化方法中加入：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">[_tableView addObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"contentOffset\"</span> options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> context:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 在dealloc中移除KVO监听：</span></div><div class=\"line\">[_tableView removeObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"contentOffset\"</span> context:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 添加默认的响应回调方法：</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath </div><div class=\"line\">                      ofObject:(<span class=\"keyword\">id</span>)object</div><div class=\"line\">                        change:(<span class=\"built_in\">NSDictionary</span> *)change </div><div class=\"line\">                       context:(<span class=\"keyword\">void</span> *)context</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span> doSomethingWhenContentOffsetChanges];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>好了，<code>KVO</code>实现就到此完美结束了，开玩笑，肯定没这么简单的，这样的代码太粗糙了，当你在<code>controller</code>中添加多个<code>KVO</code>时，所有的回调都是走同上述函数，那就必须对触发回调函数的来源进行判断。判断如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath </div><div class=\"line\">                      ofObject:(<span class=\"keyword\">id</span>)object</div><div class=\"line\">                        change:(<span class=\"built_in\">NSDictionary</span> *)change </div><div class=\"line\">                       context:(<span class=\"keyword\">void</span> *)context</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (object == _tableView &amp;&amp; [keyPath isEqualToString:<span class=\"string\">@\"contentOffset\"</span>]) </div><div class=\"line\">    &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> doSomethingWhenContentOffsetChanges];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你以为这样就结束了吗？答案是否定的！我们假设当前类(在例子中为<code>UITableViewController</code>)还有父类，并且父类也有自己绑定了一些其他<code>KVO</code>呢？我们看到，上述回调函数体中只有一个判断，如果这个<code>if</code>不成立，这次<code>KVO</code>事件的触发就会到此中断了。但事实上，若当前类无法捕捉到这个<code>KVO</code>，那很有可能是在他的<code>superClass</code>，或者<code>super-superClass...</code>中，上述处理砍断了这个链。合理的处理方式应该是这样的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath </div><div class=\"line\">                      ofObject:(<span class=\"keyword\">id</span>)object</div><div class=\"line\">                        change:(<span class=\"built_in\">NSDictionary</span> *)change </div><div class=\"line\">                       context:(<span class=\"keyword\">void</span> *)context</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (object == _tableView &amp;&amp; [keyPath isEqualToString:<span class=\"string\">@\"contentOffset\"</span>]) </div><div class=\"line\">    &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> doSomethingWhenContentOffsetChanges];</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"keyword\">else</span> </div><div class=\"line\">    &#123;</div><div class=\"line\">        [<span class=\"keyword\">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样就结束了吗？答案仍旧是否定的。潜在的问题有可能出现在<code>dealloc</code>中对<code>KVO</code>的注销上。<code>KVO</code>的一种缺陷(其实不能称为缺陷，应该称为特性)是，当对同一个<code>keypath</code>进行两次<code>removeObserver</code>时会导致程序<code>crash</code>，这种情况常常出现在父类有一个<code>kvo</code>，父类在<code>dealloc</code>中<code>remove</code>了一次，子类又<code>remove</code>了一次的情况下。不要以为这种情况很少出现！当你封装<code>framework</code>开源给别人用或者多人协作开发时是有可能出现的，而且这种<code>crash</code>很难发现。不知道你发现没，目前的代码中<code>context</code>字段都是<code>nil</code>，那能否利用该字段来标识出到底<code>kvo</code>是<code>superClass</code>注册的，还是<code>self</code>注册的？</p>\n<p>回答是可以的。我们可以分别在父类以及本类中定义各自的<code>context</code>字符串，比如在本类中定义<code>context</code>为<code>@&quot;ThisIsMyKVOContextNotSuper&quot;</code>;然后在<code>dealloc</code>中<code>remove observer</code>时指定移除的自身添加的<code>observer</code>。这样iOS就能知道移除的是自己的<code>kvo</code>，而不是父类中的<code>kvo</code>，避免二次<code>remove</code>造成<code>crash</code>。</p>\n<h2 id=\"08-iOS数据持久化方案\"><a href=\"#08-iOS数据持久化方案\" class=\"headerlink\" title=\"08-iOS数据持久化方案\"></a>08-iOS数据持久化方案</h2><h3 id=\"存储方案\"><a href=\"#存储方案\" class=\"headerlink\" title=\"存储方案\"></a>存储方案</h3><ul>\n<li>plist文件（属性列表）</li>\n<li>preference（偏好设置）</li>\n<li>NSKeyedArchiver（归档）</li>\n<li>SQLite 3</li>\n<li>CoreData</li>\n</ul>\n<h3 id=\"沙盒\"><a href=\"#沙盒\" class=\"headerlink\" title=\"沙盒\"></a>沙盒</h3><blockquote>\n<p>iOS程序默认情况下只能访问程序自己的目录，这个目录被称为“沙盒”。</p>\n</blockquote>\n<h4 id=\"1-结构\"><a href=\"#1-结构\" class=\"headerlink\" title=\"1.结构\"></a>1.结构</h4><p>沙盒的目录结构如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"应用程序包\"</span></div><div class=\"line\">Documents</div><div class=\"line\">Library</div><div class=\"line\">    Caches</div><div class=\"line\">    Preferences</div><div class=\"line\">tmp</div></pre></td></tr></table></figure>\n<h4 id=\"2-目录特性\"><a href=\"#2-目录特性\" class=\"headerlink\" title=\"2.目录特性\"></a>2.目录特性</h4><blockquote>\n<p>虽然沙盒中有这么多文件夹，但是每个文件夹都不尽相同，都有各自的特性。所以在选择存放目录时，一定要认真选择适合的目录。</p>\n</blockquote>\n<p>“应用程序包”: 这里面存放的是应用程序的<strong>源文件</strong>，包括<strong>资源文件</strong>和<strong>可执行文件</strong>。</p>\n<ul>\n<li>Documents: 最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *path = [[<span class=\"built_in\">NSBundle</span> mainBundle] bundlePath];</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, path);</div></pre></td></tr></table></figure>\n<ul>\n<li>Library/Caches: iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).firstObject;</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, path);</div></pre></td></tr></table></figure>\n<ul>\n<li>Library/Preferences: iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSCachesDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).firstObject;</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, path);</div></pre></td></tr></table></figure>\n<ul>\n<li>tmp: iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *path = <span class=\"built_in\">NSTemporaryDirectory</span>();</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, path);</div></pre></td></tr></table></figure>\n<h3 id=\"plist文件\"><a href=\"#plist文件\" class=\"headerlink\" title=\"plist文件\"></a>plist文件</h3><blockquote>\n<p>plist文件是将某些特定的类，通过XML文件的方式保存在目录中。</p>\n</blockquote>\n<p>可以被序列化的类型只有如下几种：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span>;</div><div class=\"line\"><span class=\"built_in\">NSMutableArray</span>;</div><div class=\"line\"><span class=\"built_in\">NSDictionary</span>;</div><div class=\"line\"><span class=\"built_in\">NSMutableDictionary</span>;</div><div class=\"line\"><span class=\"built_in\">NSData</span>;</div><div class=\"line\"><span class=\"built_in\">NSMutableData</span>;</div><div class=\"line\"><span class=\"built_in\">NSString</span>;</div><div class=\"line\"><span class=\"built_in\">NSMutableString</span>;</div><div class=\"line\"><span class=\"built_in\">NSNumber</span>;</div><div class=\"line\"><span class=\"built_in\">NSDate</span>;</div></pre></td></tr></table></figure>\n<h4 id=\"1-获得文件路径\"><a href=\"#1-获得文件路径\" class=\"headerlink\" title=\"1.获得文件路径\"></a>1.获得文件路径</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).firstObject;</div><div class=\"line\"><span class=\"built_in\">NSString</span> *fileName = [path stringByAppendingPathComponent:<span class=\"string\">@\"123.plist\"</span>];</div></pre></td></tr></table></figure>\n<h4 id=\"2-存储\"><a href=\"#2-存储\" class=\"headerlink\" title=\"2.存储\"></a>2.存储</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[<span class=\"string\">@\"123\"</span>, <span class=\"string\">@\"456\"</span>, <span class=\"string\">@\"789\"</span>];</div><div class=\"line\">[array writeToFile:fileName atomically:<span class=\"literal\">YES</span>];</div></pre></td></tr></table></figure>\n<h4 id=\"3-读取\"><a href=\"#3-读取\" class=\"headerlink\" title=\"3.读取\"></a>3.读取</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *result = [<span class=\"built_in\">NSArray</span> arrayWithContentsOfFile:fileName];</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, result);</div></pre></td></tr></table></figure>\n<h4 id=\"4-注意\"><a href=\"#4-注意\" class=\"headerlink\" title=\"4.注意\"></a>4.注意</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 只有以上列出的类型才能使用plist文件存储。</span></div><div class=\"line\"><span class=\"comment\">// 存储时使用writeToFile: atomically:方法。 其中atomically表示是否需要先写入一个辅助文件，再把辅助文件拷贝到目标文件地址。这是更安全的写入文件方法，一般都写YES。</span></div><div class=\"line\"><span class=\"comment\">// 读取时使用arrayWithContentsOfFile:方法。</span></div></pre></td></tr></table></figure>\n<h3 id=\"Preference\"><a href=\"#Preference\" class=\"headerlink\" title=\"Preference\"></a>Preference</h3><h4 id=\"1-使用方法\"><a href=\"#1-使用方法\" class=\"headerlink\" title=\"1.使用方法\"></a>1.使用方法</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1.获得NSUserDefaults文件</span></div><div class=\"line\"><span class=\"built_in\">NSUserDefaults</span> *userDefaults = [<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2.向文件中写入内容</span></div><div class=\"line\">[userDefaults setObject:<span class=\"string\">@\"AAA\"</span> forKey:<span class=\"string\">@\"a\"</span>];</div><div class=\"line\">[userDefaults setBool:<span class=\"literal\">YES</span> forKey:<span class=\"string\">@\"sex\"</span>];</div><div class=\"line\">[userDefaults setInteger:<span class=\"number\">21</span> forKey:<span class=\"string\">@\"age\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2.1立即同步</span></div><div class=\"line\">[userDefaults synchronize];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3.读取文件</span></div><div class=\"line\"><span class=\"built_in\">NSString</span> *name = [userDefaults objectForKey:<span class=\"string\">@\"a\"</span>];</div><div class=\"line\"><span class=\"built_in\">BOOL</span> sex = [userDefaults boolForKey:<span class=\"string\">@\"sex\"</span>];</div><div class=\"line\"><span class=\"built_in\">NSInteger</span> age = [userDefaults integerForKey:<span class=\"string\">@\"age\"</span>];</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@, %d, %ld\"</span>, name, sex, age);</div></pre></td></tr></table></figure>\n<h4 id=\"2-注意\"><a href=\"#2-注意\" class=\"headerlink\" title=\"2.注意\"></a>2.注意</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 偏好设置是专门用来保存应用程序的配置信息的，一般不要在偏好设置中保存其他数据。</span></div><div class=\"line\"><span class=\"comment\">// 如果没有调用synchronize方法，系统会根据I/O情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用synchronize方法。</span></div><div class=\"line\"><span class=\"comment\">// 偏好设置会将所有数据保存到同一个文件中。即preference目录下的一个以此应用包名来命名的plist文件。</span></div></pre></td></tr></table></figure>\n<h3 id=\"NSKeyedArchiver\"><a href=\"#NSKeyedArchiver\" class=\"headerlink\" title=\"NSKeyedArchiver\"></a>NSKeyedArchiver</h3><blockquote>\n<p>归档在iOS中是另一种形式的序列化，只要遵循了NSCoding协议的对象都可以通过它实现序列化。由于决大多数支持存储数据的Foundation和Cocoa Touch类都遵循了NSCoding协议，因此，对于大多数类来说，归档相对而言还是比较容易实现的。</p>\n</blockquote>\n<h4 id=\"1-遵循NSCoding协议\"><a href=\"#1-遵循NSCoding协议\" class=\"headerlink\" title=\"1.遵循NSCoding协议\"></a>1.遵循NSCoding协议</h4><blockquote>\n<p>NSCoding协议声明了两个方法，这两个方法都是必须实现的。一个用来说明如何将对象编码到归档中，另一个说明如何进行解档来获取一个新对象。</p>\n</blockquote>\n<p>遵循协议和设置属性</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1.遵循NSCoding协议 </span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Person</span> : <span class=\"title\">NSObject</span>   //2.设置属性</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">UIImage</span> *avatar;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">copy</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSString</span> *name;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">assign</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSInteger</span> age;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>实现协议方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//解档</span></div><div class=\"line\">- (<span class=\"keyword\">id</span>)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.avatar = [aDecoder decodeObjectForKey:<span class=\"string\">@\"avatar\"</span>];</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = [aDecoder decodeObjectForKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">        <span class=\"keyword\">self</span>.age = [aDecoder decodeIntegerForKey:<span class=\"string\">@\"age\"</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//归档</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)encodeWithCoder:(<span class=\"built_in\">NSCoder</span> *)aCoder &#123;</div><div class=\"line\">    [aCoder encodeObject:<span class=\"keyword\">self</span>.avatar forKey:<span class=\"string\">@\"avatar\"</span>];</div><div class=\"line\">    [aCoder encodeObject:<span class=\"keyword\">self</span>.name forKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">    [aCoder encodeInteger:<span class=\"keyword\">self</span>.age forKey:<span class=\"string\">@\"age\"</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>特别注意</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">如果需要归档的类是某个自定义类的子类时，就需要在归档和解档之前先实现父类的归档和解档方法。即 [<span class=\"keyword\">super</span> encodeWithCoder:aCoder] 和 [<span class=\"keyword\">super</span> initWithCoder:aDecoder] 方法;</div></pre></td></tr></table></figure>\n<h4 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2.使用\"></a>2.使用</h4><p>需要把对象归档是调用<code>NSKeyedArchiver</code>的工厂方法 <code>archiveRootObject: toFile:</code>方法。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *file = [<span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).firstObject stringByAppendingPathComponent:<span class=\"string\">@\"person.data\"</span>];</div><div class=\"line\">Person *person = [[Person alloc] init];</div><div class=\"line\">person.avatar = <span class=\"keyword\">self</span>.avatarView.image;</div><div class=\"line\">person.name = <span class=\"keyword\">self</span>.nameField.text;</div><div class=\"line\">person.age = [<span class=\"keyword\">self</span>.ageField.text integerValue];</div><div class=\"line\">[<span class=\"built_in\">NSKeyedArchiver</span> archiveRootObject:person toFile:file];</div></pre></td></tr></table></figure>\n<p>需要从文件中解档对象就调用<code>NSKeyedUnarchiver</code>的一个工厂方法 <code>unarchiveObjectWithFile:</code> 即可。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *file = [<span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).firstObject stringByAppendingPathComponent:<span class=\"string\">@\"person.data\"</span>];</div><div class=\"line\">Person *person = [<span class=\"built_in\">NSKeyedUnarchiver</span> unarchiveObjectWithFile:file];</div><div class=\"line\"><span class=\"keyword\">if</span> (person) </div><div class=\"line\">&#123;</div><div class=\"line\">   <span class=\"keyword\">self</span>.avatarView.image = person.avatar;</div><div class=\"line\">   <span class=\"keyword\">self</span>.nameField.text = person.name;</div><div class=\"line\">   <span class=\"keyword\">self</span>.ageField.text = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%ld\"</span>, person.age];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-注意\"><a href=\"#3-注意\" class=\"headerlink\" title=\"3.注意\"></a>3.注意</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">必须遵循并实现<span class=\"built_in\">NSCoding</span>协议</div><div class=\"line\">保存文件的扩展名可以任意指定</div><div class=\"line\">继承时必须先调用父类的归档解档方法</div></pre></td></tr></table></figure>\n<h3 id=\"SQLite3\"><a href=\"#SQLite3\" class=\"headerlink\" title=\"SQLite3\"></a>SQLite3</h3><blockquote>\n<p>之前的所有存储方法，都是覆盖存储。如果想要增加一条数据就必须把整个文件读出来，然后修改数据后再把整个内容覆盖写入文件。所以它们都不适合存储大量的内容。</p>\n</blockquote>\n<h4 id=\"1-字段类型\"><a href=\"#1-字段类型\" class=\"headerlink\" title=\"1.字段类型\"></a>1.字段类型</h4><p>表面上·SQLite·将数据分为以下几种类型：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">integer : 整数</div><div class=\"line\">real : 实数（浮点数）</div><div class=\"line\">text : 文本字符串</div><div class=\"line\">blob : 二进制数据，比如文件，图片之类的</div></pre></td></tr></table></figure>\n<p>实际上<code>SQLite</code>是无类型的。即不管你在创表时指定的字段类型是什么，存储是依然可以存储任意类型的数据。而且在创表时也可以不指定字段类型。<code>SQLite</code>之所以什么类型就是为了良好的编程规范和方便开发人员交流，所以平时在使用时最好设置正确的字段类型！主键必须设置成<code>integer</code></p>\n<h4 id=\"2-准备工作\"><a href=\"#2-准备工作\" class=\"headerlink\" title=\"2. 准备工作\"></a>2. 准备工作</h4><p>准备工作就是导入依赖库啦，在<code>iOS</code>中要使用<code>SQLite3</code>，需要添加库文件：<code>libsqlite3.dylib</code>并导入主头文件，这是一个<code>C语言</code>的库，所以直接使用<code>SQLite3</code>还是比较麻烦的。</p>\n<h4 id=\"3-使用\"><a href=\"#3-使用\" class=\"headerlink\" title=\"3.使用\"></a>3.使用</h4><h5 id=\"1-创建数据库并打开\"><a href=\"#1-创建数据库并打开\" class=\"headerlink\" title=\"1.创建数据库并打开\"></a>1.创建数据库并打开</h5><p>操作数据库之前必须先指定数据库文件和要操作的表，所以使用<code>SQLite3</code>，首先要打开数据库文件，然后指定或创建一张表。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//  打开数据库并创建一个表</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)openDatabase </div><div class=\"line\">&#123;</div><div class=\"line\">   <span class=\"comment\">//1.设置文件名</span></div><div class=\"line\">   <span class=\"built_in\">NSString</span> *filename = [<span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).firstObject stringByAppendingPathComponent:<span class=\"string\">@\"person.db\"</span>];</div><div class=\"line\">   </div><div class=\"line\">   <span class=\"comment\">//2.打开数据库文件，如果没有会自动创建一个文件</span></div><div class=\"line\">   <span class=\"built_in\">NSInteger</span> result = sqlite3_open(filename.UTF8String, &amp;_sqlite3);</div><div class=\"line\">   </div><div class=\"line\">   <span class=\"keyword\">if</span> (result == SQLITE_OK) </div><div class=\"line\">   &#123;</div><div class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"打开数据库成功！\"</span>);</div><div class=\"line\">       </div><div class=\"line\">       <span class=\"comment\">//3.创建一个数据库表</span></div><div class=\"line\">       <span class=\"keyword\">char</span> *errmsg = <span class=\"literal\">NULL</span>;</div><div class=\"line\">       sqlite3_exec(_sqlite3, <span class=\"string\">\"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)\"</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, &amp;errmsg);</div><div class=\"line\">       </div><div class=\"line\">       <span class=\"keyword\">if</span> (errmsg) </div><div class=\"line\">       &#123;</div><div class=\"line\">           <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"错误：%s\"</span>, errmsg);</div><div class=\"line\">       &#125; </div><div class=\"line\">       <span class=\"keyword\">else</span> </div><div class=\"line\">       &#123;</div><div class=\"line\">           <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"创表成功！\"</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125; </div><div class=\"line\">   <span class=\"keyword\">else</span> </div><div class=\"line\">   &#123;</div><div class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"打开数据库失败！\"</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"2-执行指令\"><a href=\"#2-执行指令\" class=\"headerlink\" title=\"2.执行指令\"></a>2.执行指令</h5><p>使用 <code>sqlite3_exec()</code> 方法可以执行任何<code>SQL</code>语句，比如<code>创表、更新、插入和删除</code>操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 往表中插入1000条数据</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)insertData </div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *nameStr;</div><div class=\"line\">    <span class=\"built_in\">NSInteger</span> age;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) </div><div class=\"line\">    &#123;</div><div class=\"line\">      nameStr = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"Bourne-%d\"</span>, arc4random_uniform(<span class=\"number\">10000</span>)];</div><div class=\"line\">      age = arc4random_uniform(<span class=\"number\">80</span>) + <span class=\"number\">20</span>;</div><div class=\"line\">      <span class=\"built_in\">NSString</span> *sql = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"INSERT INTO t_person (name, age) VALUES('%@', '%ld')\"</span>, nameStr, age];</div><div class=\"line\">      <span class=\"keyword\">char</span> *errmsg = <span class=\"literal\">NULL</span>;</div><div class=\"line\">      sqlite3_exec(_sqlite3, sql.UTF8String, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, &amp;errmsg);</div><div class=\"line\">      <span class=\"keyword\">if</span> (errmsg) </div><div class=\"line\">      &#123;</div><div class=\"line\">          <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"错误：%s\"</span>, errmsg);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"插入完毕！\"</span>);   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"3-查询指令\"><a href=\"#3-查询指令\" class=\"headerlink\" title=\"3.查询指令\"></a>3.查询指令</h5><p>前面说过一般不使用 sqlite3_exec() 方法查询数据。因为查询数据必须要获得查询结果，所以查询相对比较麻烦。示例代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// sqlite3_prepare_v2() : 检查sql的合法性</span></div><div class=\"line\"><span class=\"comment\">// sqlite3_step() : 逐行获取查询结果，不断重复，直到最后一条记录</span></div><div class=\"line\"><span class=\"comment\">// sqlite3_coloum_xxx() : 获取对应类型的内容，iCol对应的就是SQL语句中字段的顺序，从0开始。根据实际查询字段的属性，使用sqlite3_column_xxx取得对应的内容即可。</span></div><div class=\"line\"><span class=\"comment\">// sqlite3_finalize() : 释放stmt</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 从表中读取数据到数组中</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)readData </div><div class=\"line\">&#123;</div><div class=\"line\">   <span class=\"built_in\">NSMutableArray</span> *mArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithCapacity:<span class=\"number\">1000</span>];</div><div class=\"line\">   <span class=\"keyword\">char</span> *sql = <span class=\"string\">\"select name, age from t_person;\"</span>;</div><div class=\"line\">   sqlite3_stmt *stmt;</div><div class=\"line\">   <span class=\"built_in\">NSInteger</span> result = sqlite3_prepare_v2(_sqlite3, sql, <span class=\"number\">-1</span>, &amp;stmt, <span class=\"literal\">NULL</span>);</div><div class=\"line\">   </div><div class=\"line\">   <span class=\"keyword\">if</span> (result == SQLITE_OK) </div><div class=\"line\">   &#123;</div><div class=\"line\">       <span class=\"keyword\">while</span> (sqlite3_step(stmt) == SQLITE_ROW) </div><div class=\"line\">       &#123;</div><div class=\"line\">           <span class=\"keyword\">char</span> *name = (<span class=\"keyword\">char</span> *)sqlite3_column_text(stmt, <span class=\"number\">0</span>);</div><div class=\"line\">           <span class=\"built_in\">NSInteger</span> age = sqlite3_column_int(stmt, <span class=\"number\">1</span>);</div><div class=\"line\">           <span class=\"comment\">//创建对象</span></div><div class=\"line\">           Person *person = [Person personWithName:[<span class=\"built_in\">NSString</span> stringWithUTF8String:name] Age:age];</div><div class=\"line\">           [mArray addObject:person];</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">self</span>.dataList = mArray;</div><div class=\"line\">   &#125;</div><div class=\"line\">   sqlite3_finalize(stmt);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h4><p>总得来说，<code>SQLite3</code>的使用还是比较麻烦的，因为都是些<code>c语言</code>的函数，理解起来有些困难。不过在一般开发过程中，使用的都是第三方开源库 <code>FMDB</code>，封装了这些基本的<code>c语言</code>方法，使得我们在使用时更加容易理解，提高开发效率。</p>\n<h3 id=\"FMDB\"><a href=\"#FMDB\" class=\"headerlink\" title=\"FMDB\"></a>FMDB</h3><h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h4><blockquote>\n<p>FMDB是iOS平台的SQLite数据库框架，它是以OC的方式封装了SQLite的C语言API，它相对于cocoa自带的C语言框架有如下的优点:<br>使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码<br>对比苹果自带的Core Data框架，更加轻量级和灵活<br>提供了多线程安全的数据库操作方法，有效地防止数据混乱</p>\n</blockquote>\n<h4 id=\"2-核心类\"><a href=\"#2-核心类\" class=\"headerlink\" title=\"2.核心类\"></a>2.核心类</h4><p><strong>FMDB有三个主要的类：</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// FMDatabase</span></div><div class=\"line\">一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// FMResultSet</span></div><div class=\"line\">使用FMDatabase执行查询后的结果集</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// FMDatabaseQueue</span></div><div class=\"line\">用于在多线程中执行多个查询或更新，它是线程安全的</div></pre></td></tr></table></figure>\n<h4 id=\"3-打开数据库\"><a href=\"#3-打开数据库\" class=\"headerlink\" title=\"3.打开数据库\"></a>3.打开数据库</h4><blockquote>\n<p>和c语言框架一样，FMDB通过指定SQLite数据库文件路径来创建FMDatabase对象，但FMDB更加容易理解，使用起来更容易，使用之前一样需要导入sqlite3.dylib。打开数据库方法如下：</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *path = [<span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).firstObject stringByAppendingPathComponent:<span class=\"string\">@\"person.db\"</span>];</div><div class=\"line\">FMDatabase *database = [FMDatabase databaseWithPath:path]; </div><div class=\"line\">   </div><div class=\"line\"><span class=\"keyword\">if</span> (![database open]) </div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"数据库打开失败！\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>值得注意的是，Path的值可以传入以下三种情况：</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 具体文件路径，如果不存在会自动创建</span></div><div class=\"line\"><span class=\"comment\">// 空字符串@\"\"，会在临时目录创建一个空的数据库，当FMDatabase连接关闭时，数据库文件也被删除</span></div><div class=\"line\"><span class=\"comment\">// nil，会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁</span></div></pre></td></tr></table></figure>\n<h4 id=\"4-更新\"><a href=\"#4-更新\" class=\"headerlink\" title=\"4.更新\"></a>4.更新</h4><blockquote>\n<p>在FMDB中，除查询以外的所有操作，都称为“更新”, 如：create、drop、insert、update、delete等操作，使用executeUpdate:方法执行更新：</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//常用方法有以下 3 种：   </span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)executeUpdate:(<span class=\"built_in\">NSString</span>*)sql, ...</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)executeUpdateWithFormat:(<span class=\"built_in\">NSString</span>*)format, ...</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)executeUpdate:(<span class=\"built_in\">NSString</span>*)sql withArgumentsInArray:(<span class=\"built_in\">NSArray</span> *)arguments</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//示例</span></div><div class=\"line\">[database executeUpdate:<span class=\"string\">@\"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)\"</span>]; </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">//或者  </span></div><div class=\"line\">[database executeUpdate:<span class=\"string\">@\"INSERT INTO t_person(name, age) VALUES(?, ?)\"</span>, <span class=\"string\">@\"Bourne\"</span>, [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">42</span>]];</div></pre></td></tr></table></figure>\n<h4 id=\"5-查询\"><a href=\"#5-查询\" class=\"headerlink\" title=\"5.查询\"></a>5.查询</h4><p>查询方法也有3种，使用起来相当简单：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (FMResultSet *)executeQuery:(<span class=\"built_in\">NSString</span>*)sql, ...</div><div class=\"line\">- (FMResultSet *)executeQueryWithFormat:(<span class=\"built_in\">NSString</span>*)format, ...</div><div class=\"line\">- (FMResultSet *)executeQuery:(<span class=\"built_in\">NSString</span> *)sql withArgumentsInArray:(<span class=\"built_in\">NSArray</span> *)arguments</div></pre></td></tr></table></figure>\n<p>查询示例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1.执行查询</span></div><div class=\"line\">FMResultSet *result = [database executeQuery:<span class=\"string\">@\"SELECT * FROM t_person\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2.遍历结果集</span></div><div class=\"line\"><span class=\"keyword\">while</span> ([result next]) </div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *name = [result stringForColumn:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> age = [result intForColumn:<span class=\"string\">@\"age\"</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"6-线程安全\"><a href=\"#6-线程安全\" class=\"headerlink\" title=\"6.线程安全\"></a>6.线程安全</h4><blockquote>\n<p>在多个线程中同时使用一个 <code>FMDatabase</code> 实例是不明智的。不要让多个线程分享同一个<code>FMDatabase</code>实例，它无法在多个线程中同时使用。 如果在多个线程中同时使用一个<code>FMDatabase</code>实例，会造成数据混乱等问题。所以，请使用 <code>FMDatabaseQueue</code>，它是线程安全的。以下是使用方法：</p>\n</blockquote>\n<p>创建队列。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用队列</span></div><div class=\"line\">[queue inDatabase:^(FMDatabase *database)</div><div class=\"line\">&#123;    </div><div class=\"line\">          [database executeUpdate:<span class=\"string\">@\"INSERT INTO t_person(name, age) VALUES (?, ?)\"</span>, <span class=\"string\">@\"Bourne_1\"</span>, [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">1</span>]];    </div><div class=\"line\">          [database executeUpdate:<span class=\"string\">@\"INSERT INTO t_person(name, age) VALUES (?, ?)\"</span>, <span class=\"string\">@\"Bourne_2\"</span>, [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">2</span>]];    </div><div class=\"line\">          [database executeUpdate:<span class=\"string\">@\"INSERT INTO t_person(name, age) VALUES (?, ?)\"</span>, <span class=\"string\">@\"Bourne_3\"</span>, [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">3</span>]];      </div><div class=\"line\">          FMResultSet *result = [database executeQuery:<span class=\"string\">@\"select * from t_person\"</span>];    </div><div class=\"line\">         <span class=\"keyword\">while</span>([result next]) &#123;   </div><div class=\"line\">         &#125;    </div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 而且可以轻松地把简单任务包装到事务里：</span></div><div class=\"line\">[queue inTransaction:^(FMDatabase *database, <span class=\"built_in\">BOOL</span> *rollback) &#123;    </div><div class=\"line\">          [database executeUpdate:<span class=\"string\">@\"INSERT INTO t_person(name, age) VALUES (?, ?)\"</span>, <span class=\"string\">@\"Bourne_1\"</span>, [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">1</span>]];    </div><div class=\"line\">          [database executeUpdate:<span class=\"string\">@\"INSERT INTO t_person(name, age) VALUES (?, ?)\"</span>, <span class=\"string\">@\"Bourne_2\"</span>, [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">2</span>]];    </div><div class=\"line\">          [database executeUpdate:<span class=\"string\">@\"INSERT INTO t_person(name, age) VALUES (?, ?)\"</span>, <span class=\"string\">@\"Bourne_3\"</span>, [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">3</span>]];      </div><div class=\"line\">          FMResultSet *result = [database executeQuery:<span class=\"string\">@\"select * from t_person\"</span>];    </div><div class=\"line\">             <span class=\"keyword\">while</span>([result next]) &#123;   </div><div class=\"line\">             &#125;   </div><div class=\"line\">           <span class=\"comment\">//回滚</span></div><div class=\"line\">           *rollback = <span class=\"literal\">YES</span>;  </div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<p>FMDatabaseQueue 后台会建立系列化的<code>GCD</code>队列，并执行你传给<code>GCD</code>队列的块。这意味着 你从多线程同时调用调用方法，<code>GCD</code>也会按它接收的块的顺序来执行了。</p>\n","excerpt":"文章大纲，便于浏览 01-iOS程序启动过程 02-浅拷贝-深拷贝 03-View的生命周期","categories":[],"tags":[{"name":"知识总结","slug":"知识总结","permalink":"http://yoursite.com/tags/知识总结/"}]},{"title":"weak-弱引用实现原理","date":"2017-04-03T06:33:09.000Z","path":"2017/04/03/weak-弱引用实现原理/","text":"weak是一个弱引用，这个引用不会增加对象的引用计数，并且所指对象在释放后被自动置为nil。weak通常用于处理循环引用的问题。如代理属性以及block中用得比较多。 此处重点记录一下weak的实现过程 123&#123; id __weak obj1 = obj;&#125; 当我们初始化一个weak属性的变量时，Runtime会调用objc_initWeak函数 声明如下： 123&#123; id objc_initWeak (id *object , id value);&#125; 其具体实现如下： 12345id objc_initWeak (id *object , id value)&#123; *object = 0; return objc_storeWeak(object,value);&#125; 轮换成编译器代码如下 12id obj1;objc_initWeak(&amp;obj1,obj); 因此，这里所做的事是先将obj1初始化为0(nil)，然后将obj1的地址及obj作为参数传递给objc_storeWeak函数。 objc_storeWeak的函数声明如下: 1id objc_storeWeak(id *location, id value); 具体实现相对较为复杂，去掉线程之间锁之后，大致如下： 12345678910111213141516171819202122id objc_storeWeak(id *location, id newObj)&#123; id oldObj; SideTable *oldTable; SideTable *newTable; oldObj = *location; // 旧值 oldTable = SideTable::tableForPointer(oldObj); // 旧表 newTable = SideTable::tableForPointer(newObj); // 新表 if (oldObj) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); &#125; if (newObj) &#123; newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location); &#125; *location = newObj; return newObj;&#125; 这里面有很关键的两个结构体weak和SideTable weak表是一个弱引用表，实现为一个weak_table_t结构体，存储了某个对象相关的的所有的弱引用信息。其定义如下(具体定义在objc-weak.h中)： 12345struct weak_table_t &#123; weak_entry_t *weak_entries; size_t num_entries; ......&#125;; 其中weak_entry_t是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用hash表。其定义如下： 1234567891011121314struct weak_entry_t &#123; DisguisedPtr&lt;objc_object&gt; referent; union &#123; struct &#123; weak_referrer_t *referrers; uintptr_t out_of_line : 1; ...... &#125;; struct &#123; weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; &#125;; &#125;;&#125;; SideTable是一个用C++实现的类，它的具体定义在NSObject.mm中，看看它的一些成员变量的定义: 1234567class SideTable &#123;private: static uint8_t table_buf[SIDE_TABLE_STRIPE * SIDE_TABLE_SIZE];public: RefcountMap refcnts; weak_table_t weak_table;&#125; 了解了weak表和SideTable，让我们再回过头来看看objc_storeWeak。首先是根据weak指针找到其指向的老的对象： 1oldObj = *location; 然后获取到与新旧对象相关的SideTable对象： 12oldTable = SideTable::tableForPointer(oldObj);newTable = SideTable::tableForPointer(newObj); 下面要做的就是在老对象的weak表中移除指向信息，而在新对象的weak表中建立关联信息： 123456if (oldObj) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);&#125;if (newObj) &#123; newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location);&#125; 接下来让弱引用指针指向新的对象： 1*location = newObj; 最后会返回这个新对象： 1return newObj; 而当weak引用指向的对象被释放时，其基本流程如下： 调用objc_release 因为对象的引用计数为0，所以执行dealloc 在dealloc中，调用了_objc_rootDealloc函数 在_objc_rootDealloc中，调用了object_dispose函数 调用objc_destructInstance 最后调用objc_clear_deallocating objc_clear_deallocating中首先取出对象对应的SideTable实例，如果这个对象有关联的弱引用，则调用arr_clear_deallocating来清除对象的弱引用信息。 这个函数首先是找出对象对应的weak_entry_t链表，然后挨个将弱引用置为nil。最后清理对象的记录。 一个weak引用的处理涉及各种查表、添加与删除操作，还是有一定消耗的。所以如果大量使用__weak变量的话，会对性能造成一定的影响。","content":"<p><code>weak</code>是一个弱引用，这个引用不会增加对象的引用计数，并且所指对象在释放后被自动置为nil。<code>weak</code>通常用于处理循环引用的问题。如<code>代理</code>属性以及<code>block</code>中用得比较多。</p>\n<p>此处重点记录一下<code>weak</code>的实现过程</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> __<span class=\"keyword\">weak</span> obj1 = obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>当我们初始化一个<code>weak</code>属性的变量时，<code>Runtime</code>会调用<code>objc_initWeak</code>函数</p>\n<p>声明如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> objc_initWeak (<span class=\"keyword\">id</span> *object , <span class=\"keyword\">id</span> value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其具体实现如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">id</span> objc_initWeak (<span class=\"keyword\">id</span> *object , <span class=\"keyword\">id</span> value)</div><div class=\"line\">&#123;</div><div class=\"line\">   *object = <span class=\"number\">0</span>;</div><div class=\"line\">   <span class=\"keyword\">return</span> objc_storeWeak(object,value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>轮换成编译器代码如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">id</span> obj1;</div><div class=\"line\">objc_initWeak(&amp;obj1,obj);</div></pre></td></tr></table></figure>\n<p>因此，这里所做的事是先将<code>obj1</code>初始化为<code>0(nil)</code>，然后将<code>obj1</code>的地址及<code>obj</code>作为参数传递给<code>objc_storeWeak</code>函数。</p>\n<p><code>objc_storeWeak</code>的函数声明如下:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">id</span> objc_storeWeak(<span class=\"keyword\">id</span> *location, <span class=\"keyword\">id</span> value);</div></pre></td></tr></table></figure>\n<p>具体实现相对较为复杂，去掉线程之间锁之后，大致如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">id</span> objc_storeWeak(<span class=\"keyword\">id</span> *location, <span class=\"keyword\">id</span> newObj)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> oldObj;</div><div class=\"line\">    SideTable *oldTable;</div><div class=\"line\">    SideTable *newTable;  </div><div class=\"line\"></div><div class=\"line\">    oldObj = *location;                               <span class=\"comment\">// 旧值</span></div><div class=\"line\">    oldTable = SideTable::tableForPointer(oldObj);    <span class=\"comment\">// 旧表</span></div><div class=\"line\">    newTable = SideTable::tableForPointer(newObj);    <span class=\"comment\">// 新表</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (oldObj) &#123;</div><div class=\"line\">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (newObj) &#123;</div><div class=\"line\">        newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location);</div><div class=\"line\">    &#125;</div><div class=\"line\">   </div><div class=\"line\">    *location = newObj;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> newObj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里面有很关键的两个结构体<code>weak</code>和<code>SideTable</code></p>\n<p><code>weak</code>表是一个弱引用表，实现为一个<code>weak_table_t</code>结构体，存储了某个对象相关的的所有的弱引用信息。其定义如下(具体定义在<code>objc-weak.h</code>中)：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> weak_table_t &#123;</div><div class=\"line\">    weak_entry_t *weak_entries;</div><div class=\"line\">    size_t    num_entries;</div><div class=\"line\">    ......</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>其中<code>weak_entry_t</code>是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用<code>hash</code>表。其定义如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> weak_entry_t &#123;</div><div class=\"line\">    DisguisedPtr&lt;objc_object&gt; referent;</div><div class=\"line\">    <span class=\"keyword\">union</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">            weak_referrer_t *referrers;</div><div class=\"line\">            uintptr_t        out_of_line : <span class=\"number\">1</span>;</div><div class=\"line\">            ......</div><div class=\"line\">        &#125;;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>SideTable</code>是一个用<code>C++</code>实现的类，它的具体定义在<code>NSObject.mm</code>中，看看它的一些成员变量的定义:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> SideTable &#123;</div><div class=\"line\">private:</div><div class=\"line\">    <span class=\"keyword\">static</span> uint8_t table_buf[SIDE_TABLE_STRIPE * SIDE_TABLE_SIZE];</div><div class=\"line\">public:</div><div class=\"line\">    RefcountMap refcnts;</div><div class=\"line\">    weak_table_t weak_table;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>了解了<code>weak</code>表和<code>SideTable</code>，让我们再回过头来看看<code>objc_storeWeak</code>。首先是根据<code>weak</code>指针找到其指向的老的对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">oldObj = *location;</div></pre></td></tr></table></figure>\n<p>然后获取到与新旧对象相关的<code>SideTable</code>对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">oldTable = SideTable::tableForPointer(oldObj);</div><div class=\"line\">newTable = SideTable::tableForPointer(newObj);</div></pre></td></tr></table></figure>\n<p>下面要做的就是在老对象的<code>weak</code>表中移除指向信息，而在新对象的<code>weak</code>表中建立关联信息：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (oldObj) &#123;</div><div class=\"line\">    weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">if</span> (newObj) &#123;</div><div class=\"line\">    newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来让弱引用指针指向新的对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">*location = newObj;</div></pre></td></tr></table></figure>\n<p>最后会返回这个新对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> newObj;</div></pre></td></tr></table></figure>\n<p>而当<code>weak</code>引用指向的对象被释放时，其基本流程如下：</p>\n<ul>\n<li>调用<code>objc_release</code></li>\n<li>因为对象的引用计数为<code>0</code>，所以执行<code>dealloc</code></li>\n<li>在<code>dealloc</code>中，调用了<code>_objc_rootDealloc</code>函数</li>\n<li>在<code>_objc_rootDealloc</code>中，调用了<code>object_dispose</code>函数</li>\n<li>调用<code>objc_destructInstance</code></li>\n<li>最后调用<code>objc_clear_deallocating</code></li>\n</ul>\n<p><code>objc_clear_deallocating</code>中首先取出对象对应的<code>SideTable</code>实例，如果这个对象有关联的弱引用，则调用<code>arr_clear_deallocating</code>来清除对象的弱引用信息。</p>\n<p>这个函数首先是找出对象对应的<code>weak_entry_t</code>链表，然后挨个将弱引用置为<code>nil</code>。最后清理对象的记录。</p>\n<p>一个<code>weak</code>引用的处理涉及各种查表、添加与删除操作，还是有一定消耗的。所以如果大量使用__weak变量的话，会对性能造成一定的影响。</p>\n","excerpt":"weak是一个弱引用，这个引用不会增加对象的引用计数，并且所指对象在释放后被自动置为nil。weak通常用于处理循环引用的问题。如代理属性以及block中用得比较多。 此处重点记录一下weak的实现过程 123&#123; id __weak obj1 = obj;&#125;","categories":[],"tags":[{"name":"读后感","slug":"读后感","permalink":"http://yoursite.com/tags/读后感/"}]},{"title":"WWDC2016-Session707（UNNotifications）","date":"2017-03-08T06:15:20.000Z","path":"2017/03/08/WWDC2016-Session707（UNNotifications）/","text":"UNNotifications是WWDC2016基于之前的推送服务，推出的全新的的通知框架。 概览 此课程主要分为两大部分。 全新的 User Notifictions 框架 通知的注册 构建通知的内容 通知的排期 通知的管理 通知出发的动作 服务的扩展 还有一些更深入的知识，可以等我的下一篇文章。 通知的样式通知的样式有三种 可见的提示框 声音和震动 App图标角标 通知的类型通知的类型可以分为两类 本地通知 远程通知 本地通知本地通知是自身触发的 我们App按照一定规则对系统进行排期，当触发条件达成，就会发出本地通知。 可以触发本地通知的行为有以下三种 任务通知 日期通知 基于定位的通知 远程通知讲远程通知，首先要知道远程通知的原理。 通过上面这张图，理解起来会比较轻松 我们的iOS设备和苹果的APNS服务器一直保持着一个长连接，我们将App注册通知后，设备与 APNS 服务器通信，由 APNS 服务器返回设备一个Token，随后这个Token被上传到我们所需要使用的推送服务器上。之后当我们需要向设备上推送的时候，我们的推送服务器直接把要推送的内容和Token发送给APNS，APNS就可以把信息准确、快速的推送到指定的设备上 APNS远程通知可以被用于以下场景 新闻标题 即时通讯 信息的实时更新等。。。 远程通知实际上也分为两种 显式的远程通知显式的远程通知是设备接到通知之后，会显示在用户的设备界面上，用户可以直观的看 隐式的远程通知隐式的远程通知是App在后台时，接收到隐式的远程通知，此时并不会调起程序，而是程序在后台发起请求，更新数据，当用户下一次主动点击，进入App后，直接显示的就是已经更新好数据的页面。 iOS 10 之前通知存在的问题 注册繁琐 本地通知和远程通知要写不同的代码 通知被排期之后管理就变得困难 不同平台，通知的区别比较大 User Notifications Framework基于之前通知平台所存在的问题和不足，WWDC-2016 退出了全新的通知架构 User Notifications Framework。 通过上图我们可以简要的概括一下这个新框架 和之前几乎相同的API。 内容扩展（支持标题、子标题、内容以及音视频附件）。 本地通知、远程通知的代码可以只写一份。 更简单的代理方法。 针对通知的管理比以前更加优化（可更新、撤销）。 在拓展中对通知进行排期和操作。 通知的拓展（可在通知到达设备之前利用 Notification Service 进行操作）！ 新的User Notifications Framework框架可以全平台支持 其中iOS平台支持全部的新特性 WatchOS平台，可以实现不依靠iOS设备转发，直接实现本地通知（例如 实现运动目标、定时通知等）。 TV OS支持角标，可以实现一些特定的提醒通知。 推送流程推送的流程基本如图所示，下面一一展开来说 1.配置并获取许可（Registration） 12345678910111213141516171819202122232425// 献上OC版本的代码-(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter]; [center requestAuthorizationWithOptions:UNAuthorizationOptionCarPlay | UNAuthorizationOptionSound | UNAuthorizationOptionBadge | UNAuthorizationOptionAlert completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; if (granted) &#123; NSLog(@\" iOS 10 request notification success\"); &#125; else &#123; NSLog(@\" iOS 10 request notification fail\"); &#125; &#125;]; [[UIApplication sharedApplication] registerForRemoteNotifications]; return YES; &#125; iOS 10 可以通过以下方法获取针对通知的用户配置，于是我们可以更加灵活的给用户发出提示 1234[[UNUserNotificationCenter currentNotificationCenter] getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) &#123; NSLog(@\"%@\",settings); &#125;]; 2.构建推送的内容（Content）1.针对本地通知，构建推送内容方式 123456// OC版本UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];content.title = @\"Introduction to Notification\";content.subtitle = @\"Session 707\";content.body = @\"lalalalala\";content.badge = 2; 2.针对远程通知，构建推送内容方式 3.通知触发（Triggers）触发一共有四种方式 基于APNS的推送任务 基于时间间隔的推送任务 基于日程、日历的推送任务 基于定位信息的推送任务 4.排期（Schedule）本地通知排期 远程通知排期 自此，前端的通知配置完毕 5.代码（code）1234567891011121314151617181920 import UserNotifications // 获取用户许可 UNUserNotificationCenter.current().requestAuthorization([.alert, .sound, .badge]) &#123; (granted, error) in ... &#125; // 构建推送内容 let content = UNMutableNotificationContent() content.title = \"Introduction to Notifications\" content.body = \"Let's talk about notifications!\" // 构建触发条件 let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false) // 构建推送请求 let requestIdentifier = \"sampleRequest\" let request = UNNotificationRequest(identifier: requestIdentifier, content: content, trigger: trigger) // 进行排期 UNUserNotificationCenter.current().add(request) &#123; (error) in // ... &#125; import UserNotifications Notifiction Handling（前台的通知处理）为了使我们的程序在前台时依然可以接收通知，我们可以通过实现 UNUserNotificationCenterDelegate 的代理方法，通过这个代理方法，我们可以获取到即将收到的通知，此时我们就可以在他的Handler回调中对其进行处理 如果没有传递参数，也就意味着不对其进行处理 Notifiction ManagementNotifiction Management允许开发者访问已经排期等待发出的通知，甚至可以管理用户已经收到了的通知。这包括本地通知和远程通知。 同时你也可以更新、提升或者删除已经发送给用户的通知。 其中有个很关键的要素就是请求识别符（RequestIdentifier），在本地通知中，它被设置在通知的请求对象上，在远程通知中，在 HTTP/2 有一个新的请求数据头 apns-collapse-id。 系统通过这个 RequestIdentifier 来得知是哪个通知 我们可以通过官方的示例，来简单的理解这个功能。 删除通知 12345678// 比赛开始时给一个标识符let gameStartIdentifier = \"game1.start.identifier\" let gameStartRequest = UNNotificationRequest(identifier: gameStartIdentifier, content: content, trigger: startTrigger)UNUserNotificationCenter.current().add(gameStartRequest) &#123; (error) in // ... &#125;// 因为发送了错误的信息，所可以直接取消通知，只要标识符一样即可（比赛结束也可以直接remove掉）UNUserNotificationCenter.current() .removePendingNotificationRequests(withIdentifiers: [gameStartIdentifier]) 更新通知 12345678910// 比赛开始时给一个标识符let gameStartIdentifier = \"game1.start.identifier\" let gameStartRequest = UNNotificationRequest(identifier: gameStartIdentifier, content: content, trigger: startTrigger)UNUserNotificationCenter.current().add(gameStartRequest) &#123; (error) in // ... &#125;// 比赛分数发生改变，需要更新通知，创建一个新的request，但是标识符要一样let updatedGameStartRequest = UNNotificationRequest(identifier: gameStartIdentifier, content: content, trigger: newStartTrigger)UNUserNotificationCenter.current().add(updatedGameStartRequest) &#123; (error) in // ... &#125; Notiﬁcation Actions","content":"<p><code>UNNotifications</code>是<code>WWDC2016</code>基于之前的推送服务，推出的全新的的通知框架。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-01.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-02.png\" alt=\"\"></p>\n<p>此课程主要分为两大部分。</p>\n<ul>\n<li>全新的 <code>User Notifictions</code> 框架 <ul>\n<li>通知的注册</li>\n<li>构建通知的内容</li>\n<li>通知的排期</li>\n<li>通知的管理</li>\n<li>通知出发的动作</li>\n</ul>\n</li>\n<li>服务的扩展</li>\n</ul>\n<p>还有一些更深入的知识，可以等我的下一篇文章。</p>\n<h2 id=\"通知的样式\"><a href=\"#通知的样式\" class=\"headerlink\" title=\"通知的样式\"></a>通知的样式</h2><p>通知的样式有三种</p>\n<ul>\n<li>可见的提示框</li>\n<li>声音和震动</li>\n<li>App图标角标</li>\n</ul>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-03.png\" alt=\"\"></p>\n<h2 id=\"通知的类型\"><a href=\"#通知的类型\" class=\"headerlink\" title=\"通知的类型\"></a>通知的类型</h2><p>通知的类型可以分为两类</p>\n<ul>\n<li>本地通知</li>\n<li>远程通知</li>\n</ul>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-04.png\" alt=\"\"></p>\n<h3 id=\"本地通知\"><a href=\"#本地通知\" class=\"headerlink\" title=\"本地通知\"></a>本地通知</h3><p>本地通知是自身触发的<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-05.png\" alt=\"\"></p>\n<p>我们App按照一定规则对系统进行排期，当触发条件达成，就会发出本地通知。</p>\n<p>可以触发本地通知的行为有以下三种</p>\n<ul>\n<li>任务通知</li>\n<li>日期通知</li>\n<li>基于定位的通知</li>\n</ul>\n<h3 id=\"远程通知\"><a href=\"#远程通知\" class=\"headerlink\" title=\"远程通知\"></a>远程通知</h3><p>讲远程通知，首先要知道远程通知的原理。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/11.png\" alt=\"\"></p>\n<p>通过上面这张图，理解起来会比较轻松</p>\n<p>我们的<code>iOS</code>设备和苹果的<code>APNS</code>服务器一直保持着一个长连接，我们将<code>App注册</code>通知后，设备与 <code>APNS</code> 服务器通信，由 <code>APNS</code> 服务器返回设备一个<code>Token</code>，随后这个<code>Token</code>被上传到我们所需要使用的<code>推送服务器</code>上。之后当我们需要向设备上推送的时候，我们的<code>推送服务器</code>直接把要<code>推送的内容</code>和<code>Token</code>发送给<code>APNS</code>，<code>APNS</code>就可以把信息准确、快速的推送到指定的设备上</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-06.png\" alt=\"\"></p>\n<p><code>APNS</code>远程通知可以被用于以下场景</p>\n<ul>\n<li>新闻标题</li>\n<li>即时通讯</li>\n<li>信息的实时更新等。。。</li>\n</ul>\n<p>远程通知实际上也分为两种</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-07.png\" alt=\"\"></p>\n<p><strong>显式的远程通知</strong><br><code>显式的远程通知</code>是设备接到通知之后，会显示在用户的设备界面上，用户可以直观的看</p>\n<p><strong>隐式的远程通知</strong><br><code>隐式的远程通知</code>是App在后台时，接收到隐式的远程通知，此时并不会调起程序，而是程序在后台发起请求，更新数据，当用户下一次主动点击，进入App后，直接显示的就是已经更新好数据的页面。</p>\n<h2 id=\"iOS-10-之前通知存在的问题\"><a href=\"#iOS-10-之前通知存在的问题\" class=\"headerlink\" title=\"iOS 10 之前通知存在的问题\"></a>iOS 10 之前通知存在的问题</h2><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-08.png\" alt=\"\"></p>\n<ul>\n<li>注册繁琐</li>\n<li>本地通知和远程通知要写不同的代码</li>\n<li>通知被排期之后管理就变得困难</li>\n<li>不同平台，通知的区别比较大</li>\n</ul>\n<h2 id=\"User-Notifications-Framework\"><a href=\"#User-Notifications-Framework\" class=\"headerlink\" title=\"User Notifications Framework\"></a>User Notifications Framework</h2><p>基于之前通知平台所存在的问题和不足，WWDC-2016 退出了全新的通知架构 <code>User Notifications Framework</code>。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-09.png\" alt=\"\"><br>通过上图我们可以简要的概括一下这个新框架</p>\n<ul>\n<li>和之前几乎相同的API。</li>\n<li>内容扩展（支持标题、子标题、内容以及音视频附件）。</li>\n<li>本地通知、远程通知的代码可以只写一份。</li>\n<li>更简单的代理方法。</li>\n<li>针对通知的管理比以前更加优化（可更新、撤销）。</li>\n<li>在拓展中对通知进行排期和操作。</li>\n<li>通知的拓展（可在通知到达设备之前利用 Notification Service 进行操作）！</li>\n</ul>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-10.png\" alt=\"\"></p>\n<p>新的<code>User Notifications Framework</code>框架可以全平台支持</p>\n<ul>\n<li>其中<code>iOS</code>平台支持全部的新特性</li>\n<li><code>WatchOS</code>平台，可以实现不依靠<code>iOS设备转发</code>，直接实现<code>本地通知</code>（例如 实现运动目标、定时通知等）。</li>\n<li><code>TV OS</code>支持角标，可以实现一些特定的提醒通知。</li>\n</ul>\n<h2 id=\"推送流程\"><a href=\"#推送流程\" class=\"headerlink\" title=\"推送流程\"></a>推送流程</h2><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/15.png\" alt=\"\"><br>推送的流程基本如图所示，下面一一展开来说</p>\n<h3 id=\"1-配置并获取许可（Registration）\"><a href=\"#1-配置并获取许可（Registration）\" class=\"headerlink\" title=\"1.配置并获取许可（Registration）\"></a>1.配置并获取许可（Registration）</h3><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/12.png\" alt=\"\"></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 献上OC版本的代码</span></div><div class=\"line\">-(<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;  </div><div class=\"line\"> </div><div class=\"line\">    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter]; </div><div class=\"line\">     </div><div class=\"line\">    [center requestAuthorizationWithOptions:UNAuthorizationOptionCarPlay | </div><div class=\"line\">                                              UNAuthorizationOptionSound | </div><div class=\"line\">                                              UNAuthorizationOptionBadge | </div><div class=\"line\">                                              UNAuthorizationOptionAlert </div><div class=\"line\">                                              completionHandler:^(<span class=\"built_in\">BOOL</span> granted, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;  </div><div class=\"line\">    </div><div class=\"line\">           <span class=\"keyword\">if</span> (granted) </div><div class=\"line\">           &#123;  </div><div class=\"line\">               <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\" iOS 10 request notification success\"</span>);  </div><div class=\"line\">           &#125; </div><div class=\"line\">           <span class=\"keyword\">else</span> </div><div class=\"line\">           &#123;  </div><div class=\"line\">               <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\" iOS 10 request notification fail\"</span>);  </div><div class=\"line\">           &#125;  </div><div class=\"line\">    &#125;];  </div><div class=\"line\">    </div><div class=\"line\">     [[<span class=\"built_in\">UIApplication</span> sharedApplication] registerForRemoteNotifications]; </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>iOS 10</code> 可以通过以下方法获取针对通知的用户配置，于是我们可以更加灵活的给用户发出提示</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[UNUserNotificationCenter currentNotificationCenter] getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,settings);</div><div class=\"line\"> &#125;];</div></pre></td></tr></table></figure>\n<h3 id=\"2-构建推送的内容（Content）\"><a href=\"#2-构建推送的内容（Content）\" class=\"headerlink\" title=\"2.构建推送的内容（Content）\"></a>2.构建推送的内容（Content）</h3><p>1.针对<code>本地通知</code>，构建推送内容方式<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/13.png\" alt=\"\"></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// OC版本</span></div><div class=\"line\">UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];</div><div class=\"line\">content.title = <span class=\"string\">@\"Introduction to Notification\"</span>;</div><div class=\"line\">content.subtitle = <span class=\"string\">@\"Session 707\"</span>;</div><div class=\"line\">content.body = <span class=\"string\">@\"lalalalala\"</span>;</div><div class=\"line\">content.badge = <span class=\"number\">2</span>;</div></pre></td></tr></table></figure>\n<p>2.针对<code>远程通知</code>，构建推送内容方式<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/14.png\" alt=\"\"></p>\n<h3 id=\"3-通知触发（Triggers）\"><a href=\"#3-通知触发（Triggers）\" class=\"headerlink\" title=\"3.通知触发（Triggers）\"></a>3.通知触发（Triggers）</h3><p>触发一共有四种方式<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/16.png\" alt=\"\"></p>\n<ul>\n<li>基于<code>APNS</code>的推送任务</li>\n<li>基于<code>时间间隔</code>的推送任务</li>\n<li>基于<code>日程、日历</code>的推送任务</li>\n<li>基于<code>定位信息</code>的推送任务</li>\n</ul>\n<h3 id=\"4-排期（Schedule）\"><a href=\"#4-排期（Schedule）\" class=\"headerlink\" title=\"4.排期（Schedule）\"></a>4.排期（Schedule）</h3><p><strong>本地通知排期</strong><br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/17.png\" alt=\"\"></p>\n<p><strong>远程通知排期</strong><br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/18.png\" alt=\"\"></p>\n<p>自此，前端的通知配置完毕</p>\n<h3 id=\"5-代码（code）\"><a href=\"#5-代码（code）\" class=\"headerlink\" title=\"5.代码（code）\"></a>5.代码（code）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">    </div><div class=\"line\"><span class=\"keyword\">import</span> UserNotifications</div><div class=\"line\">       </div><div class=\"line\">    <span class=\"comment\">// 获取用户许可</span></div><div class=\"line\">    <span class=\"type\">UNUserNotificationCenter</span>.current().requestAuthorization([.alert, .sound, .badge]) &#123; (granted, error) <span class=\"keyword\">in</span>  ... &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 构建推送内容  </span></div><div class=\"line\">    <span class=\"keyword\">let</span> content = <span class=\"type\">UNMutableNotificationContent</span>() </div><div class=\"line\">    content.title = <span class=\"string\">\"Introduction to Notifications\"</span> </div><div class=\"line\">    content.body = <span class=\"string\">\"Let's talk about notifications!\"</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 构建触发条件  </span></div><div class=\"line\">    <span class=\"keyword\">let</span> trigger = <span class=\"type\">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class=\"number\">5</span>, repeats: <span class=\"literal\">false</span>)</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 构建推送请求   </span></div><div class=\"line\">    <span class=\"keyword\">let</span> requestIdentifier = <span class=\"string\">\"sampleRequest\"</span> </div><div class=\"line\">    <span class=\"keyword\">let</span> request = <span class=\"type\">UNNotificationRequest</span>(identifier: requestIdentifier, content: content, trigger: trigger)</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 进行排期</span></div><div class=\"line\">    <span class=\"type\">UNUserNotificationCenter</span>.current().add(request) &#123; (error) <span class=\"keyword\">in</span> <span class=\"comment\">// ... &#125; import UserNotifications</span></div></pre></td></tr></table></figure>\n<h2 id=\"Notifiction-Handling（前台的通知处理）\"><a href=\"#Notifiction-Handling（前台的通知处理）\" class=\"headerlink\" title=\"Notifiction Handling（前台的通知处理）\"></a>Notifiction Handling（前台的通知处理）</h2><p>为了使我们的程序在前台时依然可以接收通知，我们可以通过实现 <code>UNUserNotificationCenterDelegate</code> 的代理方法，通过这个代理方法，我们可以获取到即将收到的<code>通知</code>，此时我们就可以在他的<code>Handler回调</code>中对其进行处理</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/19.png\" alt=\"\"></p>\n<p>如果没有传递参数，也就意味着不对其进行处理</p>\n<h2 id=\"Notifiction-Management\"><a href=\"#Notifiction-Management\" class=\"headerlink\" title=\"Notifiction Management\"></a>Notifiction Management</h2><p><code>Notifiction Management</code>允许开发者访问已经排期等待发出的<code>通知</code>，甚至可以管理用户已经收到了的<code>通知</code>。这包括<code>本地通知</code>和<code>远程通知</code>。</p>\n<p>同时你也可以<code>更新、提升或者删除</code>已经发送给用户的通知。</p>\n<p>其中有个很关键的要素就是<code>请求识别符（RequestIdentifier）</code>，在<strong>本地通知</strong>中，它被设置在通知的请求对象上，在<strong>远程通知</strong>中，在 <code>HTTP/2</code> 有一个新的请求数据头 <code>apns-collapse-id</code>。</p>\n<p>系统通过这个 <code>RequestIdentifier</code> 来得知是哪个通知</p>\n<p>我们可以通过官方的示例，来简单的理解这个功能。</p>\n<ul>\n<li>删除通知</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 比赛开始时给一个标识符</span></div><div class=\"line\"><span class=\"keyword\">let</span> gameStartIdentifier = <span class=\"string\">\"game1.start.identifier\"</span> </div><div class=\"line\"><span class=\"keyword\">let</span> gameStartRequest = <span class=\"type\">UNNotificationRequest</span>(identifier: gameStartIdentifier, content: content, trigger: startTrigger)</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().add(gameStartRequest) &#123; (error) <span class=\"keyword\">in</span> <span class=\"comment\">// ... &#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 因为发送了错误的信息，所可以直接取消通知，只要标识符一样即可（比赛结束也可以直接remove掉）</span></div><div class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current() .removePendingNotificationRequests(withIdentifiers: [gameStartIdentifier])</div></pre></td></tr></table></figure>\n<ul>\n<li>更新通知</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 比赛开始时给一个标识符</span></div><div class=\"line\"><span class=\"keyword\">let</span> gameStartIdentifier = <span class=\"string\">\"game1.start.identifier\"</span> </div><div class=\"line\"><span class=\"keyword\">let</span> gameStartRequest = <span class=\"type\">UNNotificationRequest</span>(identifier: gameStartIdentifier, content: content, trigger: startTrigger)</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().add(gameStartRequest) &#123; (error) <span class=\"keyword\">in</span> <span class=\"comment\">// ... &#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 比赛分数发生改变，需要更新通知，创建一个新的request，但是标识符要一样</span></div><div class=\"line\"><span class=\"keyword\">let</span> updatedGameStartRequest = <span class=\"type\">UNNotificationRequest</span>(identifier: gameStartIdentifier, content: content, trigger: newStartTrigger)</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().add(updatedGameStartRequest) &#123; (error) <span class=\"keyword\">in</span> <span class=\"comment\">// ... &#125;</span></div></pre></td></tr></table></figure>\n<h2 id=\"Notiﬁcation-Actions\"><a href=\"#Notiﬁcation-Actions\" class=\"headerlink\" title=\"Notiﬁcation Actions\"></a>Notiﬁcation Actions</h2>","excerpt":"UNNotifications是WWDC2016基于之前的推送服务，推出的全新的的通知框架。","categories":[],"tags":[{"name":"WWDC Session 2016","slug":"WWDC-Session-2016","permalink":"http://yoursite.com/tags/WWDC-Session-2016/"}]},{"title":"Healthkit睡眠分析","date":"2016-05-03T06:55:55.000Z","path":"2016/05/03/Healthkit睡眠分析/","text":"原文：http://appcoda.com/sleep-analysis-healthkit/ 翻译：Liberalism 日期：2016年5月3日 现如今，睡眠变革已经成为了一种全新的潮流。用户比以往任何时候都更加关注自己的睡眠。他们不仅仅关心自己睡了多久，同样也很希望通过一段时间的数据收集和分析能够绘制出他们的睡眠趋势。而技术上的进步，包括硬件、特别是智能手机的高速发展，使睡眠变革这一高速发展的领域迎来了全新的曙光。 苹果在基于安全的前提下，提供了一种非常酷的方式来与用户的个人健康信息进行通信，并通过iOS内置的健康应用存储信息。作为开发者不仅可以使用HealyhKit来打造健康类的App，同时该框架还允许开发者访问睡眠数据，进行处理分析。 在本教程中，针对Healthkit框架我会带领大家快速入门，同时会向大家演示如果快速搭建一个简单的睡眠分析的App 1.简介 HealthKit框架结构提供了一个称之为HealthKit Store的加密数据库，开发者可以使用HKhealth Store这个类来访问这个数据库。iPhone和Apple Watch分别有自己的HealthKit Store，健康数据会在iPhone和Apple Watch之间同步。然而，Apple Watch为了节省内存空间会自动清理掉一些旧的数据。目前healthKit框架和健康类的App在iPad上是不支持的。 如果你想创建一个基于健康数据的iOS App或者是WatchOS App，HealthKit框架无疑是非常强大的一个工具。HealthKit设计的初衷是管理来源广泛的数据，基于用户喜好把来源不同的数据进行自动合并。应用程序还可以访问每个源的原始数据，并将数据本身合并。App不仅仅用于身体指标的检测、健身或营养情况，还可以用于睡眠分析 那么在接下来的文章里，我会向大家展示在iOS平台上如何利用HealthKit框架去存储、连接睡眠的分析数据。以上的方法也同样适用于watchOS平台上应用。需要注意的是这篇教程使用了Swift2.0和Xcode 7，所以为了接下来的课程，请确保你目前正在使用的Xcode 7 在我们正式开始之前，请提前下载好我们的项目并且解压。我已经创建好了基本的UI界面。当你运行时，你会看到一个计时器的UI界面，当你按下开始按钮之后，就会发现开始计时。 2.使用HealthKit Framework我们App的目标是存储睡眠的分析信息，并通过开始和结束两个按钮检索信息。要使用HealthKit，首先应该在你应用的bundle中打开HealthKit的权限。在你的项目中，在导航中找到当前的target -&gt; 再找到 capabilities，然后打开。 接下来你需要按照以下的代码在ViewController类里创建一个HKHealthStore的实例变量 1let healthStore = HKHealthStore() 然后，我们将利用HKHealthStore这个实例变量去连接HealthKit Store这个加密数据库。 如之前所说，HealthKit允许用户掌握自己的健康数据，所以在你可以操作、分析用户的睡眠数据之前，你首先需要去获取用户许可。获取许可，首先要导入HealthKit Framework，然后如下面一样更新ViewDidLoad中的代码 1234567891011121314151617override func viewDidLoad() &#123; super.viewDidLoad() let typestoRead = Set([ HKObjectType.categoryTypeForIdentifier(HKCategoryTypeIdentifierSleepAnalysis)! ]) let typestoShare = Set([ HKObjectType.categoryTypeForIdentifier(HKCategoryTypeIdentifierSleepAnalysis)! ]) self.healthStore.requestAuthorizationToShareTypes(typestoShare, readTypes: typestoRead) &#123; (success, error) -&gt; Void in if success == false &#123; NSLog(\" Display not allowed\") &#125; &#125;&#125; 以上代码可以提供给用户同意或拒绝的提示，通过block，你可以在处理成功和失败后进行相应的操作并获得最终的结果。没有必要一直向用户请求许可，你必须很好的处理程序中的各种错误 但是为了避免用户的误操作，用户必须在设置页面亲自打开允许按钮，这样才能确保真正获得设备上健康数据的权限 写入睡眠分析数据 首先，如何去检索睡眠分析数据呢？根据苹果官方文档的说法，每一个睡眠分析的样本都有一个唯一值，为了确保用户是躺下并且入睡，HealthKit在同一时间内会对两个或更多的数据进行采样。通过对这些样本的开始时间和结束时间进行对比，应用程序可以进行大量的二次统计和计算。 用户花费多少时间入睡。 用户躺在床上实际入睡时间所占的比例 用户醒来之后，会在床上躺多久 用户在床上，以及睡眠时所花费的时间汇总 简明的讲，把睡眠分析数据储存到HealthKit store数据库中时，你需要遵循以下方法 首先我们需要定义两个NSDate对象去对应开始时间和结束时间。 然后我们利用HKCategoryTypeIdentifierSleepAnalysis创建一个HKObjectType的实例变量 我们需要创建一个全新的HKCategorySample类型的对象，通常采用分类样本的方式来存储睡眠数据，独立的样本代表用户躺在床上或者入睡的时间段。所以我们可以在同一时间段内分别创建出在床上未入睡以及入睡之后的样本 最终，我们就可以利用HKHealthStore类中的saveObject方法把对象存储起来 编者提示：如果想查看样本的类型，可以查阅HealthKit官方文档 如果你把以上的注意点和方法转化到Swift中，以下就是把躺床上未入睡和入睡的分析数据储存起来的代码，请把以下代码插入到ViewController类中 123456789101112131415161718192021222324252627282930313233343536func saveSleepAnalysis() &#123; // alarmTime and endTime are NSDate objects if let sleepType = HKObjectType.categoryTypeForIdentifier(HKCategoryTypeIdentifierSleepAnalysis) &#123; // we create our new object we want to push in Health app let object = HKCategorySample(type:sleepType, value: HKCategoryValueSleepAnalysis.InBed.rawValue, startDate: self.alarmTime, endDate: self.endTime) // at the end, we save it healthStore.saveObject(object, withCompletion: &#123; (success, error) -&gt; Void in if error != nil &#123; // something happened return &#125; if success &#123; print(\"My new data was saved in HealthKit\") &#125; else &#123; // something happened again &#125; &#125;) let object2 = HKCategorySample(type:sleepType, value: HKCategoryValueSleepAnalysis.Asleep.rawValue, startDate: self.alarmTime, endDate: self.endTime) healthStore.saveObject(object2, withCompletion: &#123; (success, error) -&gt; Void in if error != nil &#123; // something happened return &#125; if success &#123; print(\"My new data (2) was saved in HealthKit\") &#125; else &#123; // something happened again &#125; &#125;) &#125; &#125; 这个方法会在我们想把睡眠分析数据存储到HealthKit中时被调用 3.读取睡眠分析数据 想要读取睡眠分析数据，我们需要创建一个查询对象。首先需要为HKCategoryTypeIdentifierSleepAnalysis定义一个HKObjectType类型的分类。或许你希望通过谓词在开始时间和结束时间这个你需要的时间段内进行筛选、检索数据。你也需要为分类检索查询创建 一个分类描述器以获取我们想要的结果 您的用于检索睡眠分析数据的代码应如下所示： 1234567891011121314151617181920212223242526272829303132333435363738func retrieveSleepAnalysis() &#123; // first, we define the object type we want if let sleepType = HKObjectType.categoryTypeForIdentifier(HKCategoryTypeIdentifierSleepAnalysis) &#123; // Use a sortDescriptor to get the recent data first let sortDescriptor = NSSortDescriptor(key: HKSampleSortIdentifierEndDate, ascending: false) // we create our query with a block completion to execute let query = HKSampleQuery(sampleType: sleepType, predicate: nil, limit: 30, sortDescriptors: [sortDescriptor]) &#123; (query, tmpResult, error) -&gt; Void in if error != nil &#123; // something happened return &#125; if let result = tmpResult &#123; // do something with my data for item in result &#123; if let sample = item as? HKCategorySample &#123; let value = (sample.value == HKCategoryValueSleepAnalysis.InBed.rawValue) ? \"InBed\" : \"Asleep\" print(\"Healthkit sleep: \\(sample.startDate) \\(sample.endDate) - value: \\(value)\") &#125; &#125; &#125; &#125; // finally, we execute our query healthStore.executeQuery(query) &#125;&#125; 此代码查询HealthKit以获取所有睡眠分析数据，然后将其按降序排序。 然后使用startDate和endDate以及值的类型（即In Bed或Asleep）打印每个查询。 我已将限制设置为30，以检索最近30个记录的样本。 您还可以使用谓词方法来选择自定义的开始和结束日期。 4.App 测试对于演示应用程序，我使用NSTimer显示自您按下启动按钮以来经过的时间。 NSDate对象在开始和结束按钮上创建，以将睡眠分析数据保存为已用时间。 在停止操作方法中，可以调用saveSleepAnalysis（）和retrieveSleepAnalysis（）方法来保存和获取睡眠数据。 123456@IBAction func stop(sender: AnyObject) &#123; endTime = NSDate() saveSleepAnalysis() retrieveSleepAnalysis() timer.invalidate()&#125; 在您的应用程序中，您可能需要更改NSDate对象以选择相关的开始和结束时间（可能不同），以保存躺在床上的数据和睡眠值。 完成更改后，您可以运行演示应用并启动计时器。让它运行几分钟，然后点击停止按钮。之后打开健康应用程序。你会发现睡眠数据。 5.对使用 HealthKit 应用的一些建议HealthKit旨在为应用开发人员提供一个通用平台，以便轻松共享和访问用户数据，并避免数据中可能的重复或不一致。苹果审查指南非常明确的说明应用程序使用HealthKit和访问用户读/写权限必须通过向用户请求，但没有清楚地阐述HealthKit的使用可能会导致应用程序被拒绝。 将假的或不正确的数据保存到健康的应用程序也将被拒绝。 这意味着，你不能天真地使用算法来计算不同的健康值，如本教程中的睡眠分析。 您应该尝试使用内置的传感器数据读取和操作任何参数，以避免计算假数据。 对于完整的Xcode项目，你可以在这里得到。","content":"<p>原文：<a href=\"\"></a><a href=\"http://appcoda.com/sleep-analysis-healthkit/\" target=\"_blank\" rel=\"external\">http://appcoda.com/sleep-analysis-healthkit/</a></p>\n<p>翻译：Liberalism</p>\n<p>日期：2016年5月3日</p>\n<a id=\"more\"></a>\n<hr>\n<p>现如今，睡眠变革已经成为了一种全新的潮流。用户比以往任何时候都更加关注自己的睡眠。他们不仅仅关心自己睡了多久，同样也很希望通过一段时间的数据收集和分析能够绘制出他们的睡眠趋势。而技术上的进步，包括硬件、特别是智能手机的高速发展，使睡眠变革这一高速发展的领域迎来了全新的曙光。</p>\n<p>苹果在基于安全的前提下，提供了一种非常酷的方式来与用户的个人健康信息进行通信，并通过iOS内置的<code>健康</code>应用存储信息。作为开发者不仅可以使用<code>HealyhKit</code>来打造健康类的<code>App</code>，同时该框架还允许开发者访问睡眠数据，进行处理分析。</p>\n<p>在本教程中，针对<code>Healthkit</code>框架我会带领大家快速入门，同时会向大家演示如果快速搭建一个简单的睡眠分析的App</p>\n<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h2><blockquote>\n<p><code>HealthKit</code>框架结构提供了一个称之为<code>HealthKit Store</code>的加密数据库，开发者可以使用<code>HKhealth Store</code>这个类来访问这个数据库。iPhone和Apple Watch分别有自己的<code>HealthKit Store</code>，健康数据会在iPhone和Apple Watch之间同步。然而，Apple Watch为了节省内存空间会自动清理掉一些旧的数据。目前<code>healthKit</code>框架和健康类的App在iPad上是不支持的。</p>\n</blockquote>\n<p>如果你想创建一个基于健康数据的iOS App或者是WatchOS App，<code>HealthKit</code>框架无疑是非常强大的一个工具。HealthKit设计的初衷是管理来源广泛的数据，基于用户喜好把来源不同的数据进行自动合并。应用程序还可以访问每个源的原始数据，并将数据本身合并。App不仅仅用于身体指标的检测、健身或营养情况，还可以用于睡眠分析</p>\n<p>那么在接下来的文章里，我会向大家展示在iOS平台上如何利用<code>HealthKit</code>框架去存储、连接睡眠的分析数据。以上的方法也同样适用于watchOS平台上应用。需要注意的是这篇教程使用了Swift2.0和Xcode 7，所以为了接下来的课程，请确保你目前正在使用的Xcode 7</p>\n<p>在我们正式开始之前，请提前下载好我们的项目并且解压。我已经创建好了基本的UI界面。当你运行时，你会看到一个计时器的UI界面，当你按下开始按钮之后，就会发现开始计时。</p>\n<h2 id=\"2-使用HealthKit-Framework\"><a href=\"#2-使用HealthKit-Framework\" class=\"headerlink\" title=\"2.使用HealthKit Framework\"></a>2.使用HealthKit Framework</h2><p>我们App的目标是存储睡眠的分析信息，并通过开始和结束两个按钮检索信息。要使用<code>HealthKit</code>，首先应该在你应用的bundle中打开<code>HealthKit</code>的权限。在你的项目中，在导航中找到当前的target -&gt; 再找到 capabilities，然后打开。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/translate/image/Healthkit-01.png?watermark/2/text/QExpYmVyYWxpc20=/font/5a6L5L2T/fontsize/800/fill/IzhBMTgxOA==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" alt=\"\"></p>\n<p>接下来你需要按照以下的代码在ViewController类里创建一个HKHealthStore的实例变量</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> healthStore = <span class=\"type\">HKHealthStore</span>()</div></pre></td></tr></table></figure>\n<p>然后，我们将利用<code>HKHealthStore</code>这个实例变量去连接<code>HealthKit Store</code>这个加密数据库。</p>\n<p>如之前所说，<code>HealthKit</code>允许用户掌握自己的健康数据，所以在你可以操作、分析用户的睡眠数据之前，你首先需要去获取用户许可。获取许可，首先要导入HealthKit Framework，然后如下面一样更新<code>ViewDidLoad</code>中的代码</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.viewDidLoad()</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">let</span> typestoRead = <span class=\"type\">Set</span>([</div><div class=\"line\">        <span class=\"type\">HKObjectType</span>.categoryTypeForIdentifier(<span class=\"type\">HKCategoryTypeIdentifierSleepAnalysis</span>)!</div><div class=\"line\">        ])</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">let</span> typestoShare = <span class=\"type\">Set</span>([</div><div class=\"line\">        <span class=\"type\">HKObjectType</span>.categoryTypeForIdentifier(<span class=\"type\">HKCategoryTypeIdentifierSleepAnalysis</span>)!</div><div class=\"line\">        ])</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">self</span>.healthStore.requestAuthorizationToShareTypes(typestoShare, readTypes: typestoRead) &#123; (success, error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></div><div class=\"line\">        <span class=\"keyword\">if</span> success == <span class=\"literal\">false</span> &#123;</div><div class=\"line\">            <span class=\"type\">NSLog</span>(<span class=\"string\">\" Display not allowed\"</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上代码可以提供给用户<code>同意</code>或<code>拒绝</code>的提示，通过<code>block</code>，你可以在处理成功和失败后进行相应的操作并获得最终的结果。没有必要一直向用户请求许可，你必须很好的处理程序中的各种错误</p>\n<p>但是为了避免用户的误操作，用户必须在设置页面亲自打开允许按钮，这样才能确保真正获得设备上健康数据的权限</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/translate/image/Healthkit-02.png?watermark/2/text/QExpYmVyYWxpc20=/font/5a6L5L2T/fontsize/800/fill/IzhBMTgxOA==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" alt=\"\"></p>\n<p>写入睡眠分析数据</p>\n<p>首先，如何去检索睡眠分析数据呢？根据苹果官方文档的说法，每一个睡眠分析的样本都有一个唯一值，为了确保用户是躺下并且入睡，HealthKit在同一时间内会对两个或更多的数据进行采样。通过对这些样本的开始时间和结束时间进行对比，应用程序可以进行大量的二次统计和计算。</p>\n<ul>\n<li>用户花费多少时间入睡。</li>\n<li>用户躺在床上实际入睡时间所占的比例</li>\n<li>用户醒来之后，会在床上躺多久</li>\n<li>用户在床上，以及睡眠时所花费的时间汇总<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/translate/image/Healthkit-03.png?watermark/2/text/QExpYmVyYWxpc20=/font/5a6L5L2T/fontsize/800/fill/IzhBMTgxOA==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" alt=\"\"></li>\n</ul>\n<p>简明的讲，把睡眠分析数据储存到HealthKit store数据库中时，你需要遵循以下方法</p>\n<hr>\n<ul>\n<li>首先我们需要定义两个NSDate对象去对应开始时间和结束时间。</li>\n</ul>\n<ul>\n<li>然后我们利用<code>HKCategoryTypeIdentifierSleepAnalysis</code>创建一个<code>HKObjectType</code>的实例变量</li>\n</ul>\n<ul>\n<li>我们需要创建一个全新的<code>HKCategorySample</code>类型的对象，通常采用分类样本的方式来存储睡眠数据，独立的样本代表用户躺在床上或者入睡的时间段。所以我们可以在同一时间段内分别创建出<code>在床上未入睡</code>以及<code>入睡之后</code>的样本</li>\n</ul>\n<ul>\n<li>最终，我们就可以利用<code>HKHealthStore</code>类中的<code>saveObject</code>方法把对象存储起来</li>\n</ul>\n<hr>\n<blockquote>\n<p>编者提示：如果想查看样本的类型，可以查阅<br><a href=\"https://developer.apple.com/reference/healthkit/healthkit_constants#//apple_ref/doc/uid/TP40014710\" target=\"_blank\" rel=\"external\"><code>HealthKit</code>官方文档</a></p>\n</blockquote>\n<hr>\n<p>如果你把以上的注意点和方法转化到Swift中，以下就是把<code>躺床上未入睡</code>和<code>入睡</code>的分析数据储存起来的代码，请把以下代码插入到<code>ViewController</code>类中</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">saveSleepAnalysis</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// alarmTime and endTime are NSDate objects</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> sleepType = <span class=\"type\">HKObjectType</span>.categoryTypeForIdentifier(<span class=\"type\">HKCategoryTypeIdentifierSleepAnalysis</span>) &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// we create our new object we want to push in Health app</span></div><div class=\"line\">        <span class=\"keyword\">let</span> object = <span class=\"type\">HKCategorySample</span>(type:sleepType, value: <span class=\"type\">HKCategoryValueSleepAnalysis</span>.<span class=\"type\">InBed</span>.rawValue, startDate: <span class=\"keyword\">self</span>.alarmTime, endDate: <span class=\"keyword\">self</span>.endTime)</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// at the end, we save it</span></div><div class=\"line\">        healthStore.saveObject(object, withCompletion: &#123; (success, error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">if</span> error != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// something happened</span></div><div class=\"line\">                <span class=\"keyword\">return</span></div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> success &#123;</div><div class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"My new data was saved in HealthKit\"</span>)    </div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// something happened again</span></div><div class=\"line\">            &#125;     </div><div class=\"line\">        &#125;)</div><div class=\"line\">        <span class=\"keyword\">let</span> object2 = <span class=\"type\">HKCategorySample</span>(type:sleepType, value: <span class=\"type\">HKCategoryValueSleepAnalysis</span>.<span class=\"type\">Asleep</span>.rawValue, startDate: <span class=\"keyword\">self</span>.alarmTime, endDate: <span class=\"keyword\">self</span>.endTime)</div><div class=\"line\">        </div><div class=\"line\">        healthStore.saveObject(object2, withCompletion: &#123; (success, error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></div><div class=\"line\">            <span class=\"keyword\">if</span> error != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// something happened</span></div><div class=\"line\">                <span class=\"keyword\">return</span></div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> success &#123;</div><div class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"My new data (2) was saved in HealthKit\"</span>)</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// something happened again</span></div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;)   </div><div class=\"line\">    &#125;   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法会在我们想把睡眠分析数据存储到<code>HealthKit</code>中时被调用</p>\n<h2 id=\"3-读取睡眠分析数据\"><a href=\"#3-读取睡眠分析数据\" class=\"headerlink\" title=\"3.读取睡眠分析数据\"></a>3.读取睡眠分析数据</h2><ul>\n<li>想要读取睡眠分析数据，我们需要创建一个查询对象。首先需要为<code>HKCategoryTypeIdentifierSleepAnalysis</code>定义一个<code>HKObjectType</code>类型的分类。或许你希望通过谓词在开始时间和结束时间这个你需要的时间段内进行筛选、检索数据。你也需要为分类检索查询创建 一个分类描述器以获取我们想要的结果</li>\n</ul>\n<p>您的用于检索睡眠分析数据的代码应如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">retrieveSleepAnalysis</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// first, we define the object type we want</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> sleepType = <span class=\"type\">HKObjectType</span>.categoryTypeForIdentifier(<span class=\"type\">HKCategoryTypeIdentifierSleepAnalysis</span>) &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// Use a sortDescriptor to get the recent data first</span></div><div class=\"line\">        <span class=\"keyword\">let</span> sortDescriptor = <span class=\"type\">NSSortDescriptor</span>(key: <span class=\"type\">HKSampleSortIdentifierEndDate</span>, ascending: <span class=\"literal\">false</span>)</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// we create our query with a block completion to execute</span></div><div class=\"line\">        <span class=\"keyword\">let</span> query = <span class=\"type\">HKSampleQuery</span>(sampleType: sleepType, predicate: <span class=\"literal\">nil</span>, limit: <span class=\"number\">30</span>, sortDescriptors: [sortDescriptor]) &#123; (query, tmpResult, error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">if</span> error != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">                </div><div class=\"line\">                <span class=\"comment\">// something happened</span></div><div class=\"line\">                <span class=\"keyword\">return</span></div><div class=\"line\">                </div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> result = tmpResult &#123;</div><div class=\"line\">                </div><div class=\"line\">                <span class=\"comment\">// do something with my data</span></div><div class=\"line\">                <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> result &#123;</div><div class=\"line\">                </div><div class=\"line\">                    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> sample = item <span class=\"keyword\">as</span>? <span class=\"type\">HKCategorySample</span> &#123;</div><div class=\"line\">                    </div><div class=\"line\">                        <span class=\"keyword\">let</span> value = (sample.value == <span class=\"type\">HKCategoryValueSleepAnalysis</span>.<span class=\"type\">InBed</span>.rawValue) ? <span class=\"string\">\"InBed\"</span> : <span class=\"string\">\"Asleep\"</span></div><div class=\"line\">                        </div><div class=\"line\">                        <span class=\"built_in\">print</span>(<span class=\"string\">\"Healthkit sleep: \\(sample.startDate) \\(sample.endDate) - value: \\(value)\"</span>)</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// finally, we execute our query</span></div><div class=\"line\">        healthStore.executeQuery(query)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>此代码查询<code>HealthKit</code>以获取所有睡眠分析数据，然后将其按降序排序。 然后使用<code>startDate</code>和<code>endDate</code>以及值的类型（即In Bed或Asleep）打印每个查询。 我已将限制设置为30，以检索最近30个记录的样本。 您还可以使用谓词方法来选择自定义的开始和结束日期。</p>\n<h2 id=\"4-App-测试\"><a href=\"#4-App-测试\" class=\"headerlink\" title=\"4.App 测试\"></a>4.App 测试</h2><p>对于演示应用程序，我使用<code>NSTimer</code>显示自您按下启动按钮以来经过的时间。 <code>NSDate</code>对象在开始和结束按钮上创建，以将睡眠分析数据保存为已用时间。 在停止操作方法中，可以调用<code>saveSleepAnalysis（）</code>和<code>retrieveSleepAnalysis（）</code>方法来保存和获取睡眠数据。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stop</span><span class=\"params\">(sender: AnyObject)</span></span> &#123;</div><div class=\"line\">    endTime = <span class=\"type\">NSDate</span>()</div><div class=\"line\">    saveSleepAnalysis()</div><div class=\"line\">    retrieveSleepAnalysis()</div><div class=\"line\">    timer.invalidate()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在您的应用程序中，您可能需要更改<code>NSDate</code>对象以选择相关的开始和结束时间（可能不同），以保存躺在床上的数据和睡眠值。</p>\n<p>完成更改后，您可以运行演示应用并启动计时器。让它运行几分钟，然后点击停止按钮。之后打开<code>健康</code>应用程序。你会发现睡眠数据。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/translate/image/Healthkit-04.png?watermark/2/text/QExpYmVyYWxpc20=/font/5a6L5L2T/fontsize/800/fill/IzhBMTgxOA==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" alt=\"\"></p>\n<h2 id=\"5-对使用-HealthKit-应用的一些建议\"><a href=\"#5-对使用-HealthKit-应用的一些建议\" class=\"headerlink\" title=\"5.对使用 HealthKit 应用的一些建议\"></a>5.对使用 <code>HealthKit</code> 应用的一些建议</h2><p><code>HealthKit</code>旨在为应用开发人员提供一个通用平台，以便轻松共享和访问用户数据，并避免数据中可能的重复或不一致。苹果审查指南非常明确的说明应用程序使用<code>HealthKit</code>和访问用户<code>读/写权限</code>必须通过向用户请求，但没有清楚地阐述<code>HealthKit</code>的使用可能会导致应用程序被拒绝。</p>\n<p>将假的或不正确的数据保存到<code>健康</code>的应用程序也将被拒绝。 这意味着，你不能天真地使用算法来计算不同的健康值，如本教程中的睡眠分析。 您应该尝试使用内置的传感器数据读取和操作任何参数，以避免计算假数据。</p>\n<p>对于完整的Xcode项目，你可以在这里<a href=\"https://github.com/appcoda/SleepAnalysis\" target=\"_blank\" rel=\"external\">得到</a>。</p>\n","excerpt":"原文：http://appcoda.com/sleep-analysis-healthkit/ 翻译：Liberalism 日期：2016年5月3日","categories":[],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://yoursite.com/tags/翻译/"}]}]