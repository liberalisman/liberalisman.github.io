[{"title":"NSMutableDictionary实现完全深拷贝","date":"2017-10-26T11:32:16.000Z","path":"2017/10/26/NSMutableDictionary实现完全深拷贝/","text":"概念性的东西我们不讲了，我们都知道集合类的拷贝比较特殊，对集合类进行 Deep Copy其实并不是完整的深拷贝，只是拷贝了外面的容器，里面的指针并没有被拷贝。道理大家都懂，可平时用的少，前几天我就栽了个跟头，特此记录一下。 网上有现成的解决方案，特此解读 遍历字典中所有的键值对 如果还是字典，继续遍历轮询 不是字典，采取 mutableCopy 无法执行 Copy 的需要进行特殊处理，例如 UIImage 12345678910111213141516171819202122232425262728293031323334-(NSMutableDictionary *)mutableDeepCopy&#123; NSMutableDictionary *dict=[[NSMutableDictionary alloc] initWithCapacity:[self count]]; NSArray *keys=[self allKeys]; for(id key in keys) &#123; id value=[self objectForKey:key]; id copyValue; if ([value respondsToSelector:@selector(mutableDeepCopy)]) &#123; copyValue=[value mutableDeepCopy]; &#125; else if([value respondsToSelector:@selector(mutableCopy)]) &#123; if ([value isMemberOfClass:[UIImage class]]) &#123; continue; &#125; copyValue=[value mutableCopy]; &#125; if(copyValue==nil) &#123; copyValue=[value copy]; &#125; [dict setObject:copyValue forKey:key]; &#125; return dict;&#125;","content":"<blockquote>\n<p>概念性的东西我们不讲了，我们都知道集合类的拷贝比较特殊，对集合类进行 <code>Deep Copy</code>其实并不是完整的深拷贝，只是拷贝了外面的容器，里面的指针并没有被拷贝。道理大家都懂，可平时用的少，前几天我就栽了个跟头，特此记录一下。</p>\n</blockquote>\n<p><strong>网上有现成的解决方案，特此解读</strong></p>\n<ol>\n<li>遍历字典中所有的键值对</li>\n<li>如果还是字典，继续遍历轮询</li>\n<li>不是字典，采取 <code>mutableCopy</code></li>\n<li>无法执行 <code>Copy</code> 的需要进行特殊处理，例如 <code>UIImage</code></li>\n</ol>\n<a id=\"more\"></a>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">NSMutableDictionary</span> *)mutableDeepCopy</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSMutableDictionary</span> *dict=[[<span class=\"built_in\">NSMutableDictionary</span> alloc] initWithCapacity:[<span class=\"keyword\">self</span> count]];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSArray</span> *keys=[<span class=\"keyword\">self</span> allKeys];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">id</span> key <span class=\"keyword\">in</span> keys)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">id</span> value=[<span class=\"keyword\">self</span> objectForKey:key];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">id</span> copyValue;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">if</span> ([value respondsToSelector:<span class=\"keyword\">@selector</span>(mutableDeepCopy)])</div><div class=\"line\">        &#123;</div><div class=\"line\">            copyValue=[value mutableDeepCopy];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>([value respondsToSelector:<span class=\"keyword\">@selector</span>(mutableCopy)])</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ([value isMemberOfClass:[<span class=\"built_in\">UIImage</span> <span class=\"keyword\">class</span>]])</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            copyValue=[value mutableCopy];</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">if</span>(copyValue==<span class=\"literal\">nil</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            copyValue=[value <span class=\"keyword\">copy</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">            </div><div class=\"line\">        [dict setObject:copyValue forKey:key];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> dict;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"概念性的东西我们不讲了，我们都知道集合类的拷贝比较特殊，对集合类进行 Deep Copy其实并不是完整的深拷贝，只是拷贝了外面的容器，里面的指针并没有被拷贝。道理大家都懂，可平时用的少，前几天我就栽了个跟头，特此记录一下。 网上有现成的解决方案，特此解读 遍历字典中所有的键值对 如果还是字典，继续遍历轮询 不是字典，采取 mutableCopy 无法执行 Copy 的需要进行特殊处理，例如 UIImage","categories":[],"tags":[{"name":"小知识","slug":"小知识","permalink":"http://yoursite.com/tags/小知识/"}]},{"title":"iOS11中使用CoreNFC","date":"2017-07-21T07:54:39.000Z","path":"2017/07/21/iOS11中使用CoreNFC/","text":"在2017的WWDC,苹果终于发布了众多开发者期待已久的系统级框架 CoreNFC。可能你对于NFC是什么并不是很了解，简而言之，NFC（近场通信）就是当两台硬件设备相距4cm以内时可以实现互相通信。NFC在商业上的应用是把NFC芯片集成到各类卡片中，极大的加强安全性。目前 CoreNFC 只支持一种格式：NFC Data Exchange Format，简称NDEF(常被用于平板电脑和智能手机中)。 提示：接下来的教程你需要Xcode9 beta,同时你也需要一部iPhone7或者iPhone 7 Plus运行iOS 11系统来验证本教程中的一些新特性。Xcode9 beta可以同时支持Swift 3.2和Swift 4.0,本教程的代码都将使用Swift 4.0来编写。只是在项目中导入CoreNFC是无法构建或者编译一个App的,必须在物理设备上才可以运行。同时你还需要一个已经付费的开发者账号才可以。 什么是CoreNFC 通过NFC，你可以阅读到包括NFC数据交换格式（NDEF）数据中的1到5类的近场通讯标签。读取标签，你的App创建了一个NFC数据交换格式的reader session并且提供了一个 delegate 。正在运行的reader session 轮询 NFC 标签，并在 delegate 方法中找到包含 NDEF 消息的标签时传递消息，并将该消息传递给 delegate 。delegate可以读取消息并处理异常。 NFC谈不上“新”技术。苹果终于向开发者开放了这个 API，以便我们可以利用 NFC 识别信息。 举一个实际的例子你经营一家商店，希望客户进入后，使用有NFC功能的手机扫描一件商品，就直接完成了所有的流程。没有任何麻烦，没有等待时间。作为一名App开发人员，在不使用NFC的情况下，还可以选择条形码或二维码，但依然比NFC麻烦很多。 说来说去NFC到底是什么？苹果虽然放开了NFC的使用权限，但苹果公司严格限制了我们的访问。这意味着CoreNFC只支持前面提到的NDEF格式。如果您打算使用CoreNFC替换您的`RFID卡,恐怕还有待时间。 准备工作我们将用一个 demo 来展示如何使用 CoreNFC 。我们的应用程序将读取存储在 NDEF格式 卡上的信息。 为此，我使用 Arduino Uno 与 Adafruit PN532 Shield 配对，将消息编程到 N​​DEF 格式的样品卡上。如果您没有这些工具，或者根本不想将时间和金钱投入到这样的硬件中，请尝试找到一张带有消息的预格式化卡。在本教程中，我将不会将 NFC 格式化或将消息嵌入到 NDEF 卡中。 我们开始吧要创建我们的项目，请打开 Xcode 9 并创建一个新的 single-view application 。然后命名您的项目，并确保选择 Swift 作为您的语言。 设计消息视图为达到目的，我们需要制作用户界面（UI），供用户进行交互。我们先创建一个导航控制器。点击 Main.storyboard 并选择View-Controller。然后，转到status-Bar，然后单击Editor&gt;embed in&gt;Navigation Controller。这会在View-Controller的顶部创建一个导航栏。您可以选择一个合适的标题。我起的标题为 Message in a Bottle。 接下来，拖动UIButton并将其放在 View-Controller 的底部。将按钮的文本更改为扫描，并根据需要进行初始化。添加扫描按钮后，利用UILabel添加背景标题。 现在我们的应用应该是这样的： 设置扫描和消息现在我们已经做好了基础设置，接下来我们将为按钮和标签通过拖线设置属性，并为按钮设置点击行为。 代码如下： 123456789101112131415161718192021import UIKitclass ViewController: UIViewController &#123; @IBOutlet weak var messageLabel: UILabel! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; @IBAction func scanPressed(_ sender: Any) &#123; // this is our newly created IBAction &#125;&#125; 设置应用程序权限和隐私接下来，在我们真正开始研究我们的 NFC 实现之前，我们需要设置我们的应用权限。 注意：您必须非常仔细地关注此部分，否则您的应用配置将无法正常工作。此外，您将需要付费的开发者帐户。 App ID首先，请转到 developer.apple.com 登录您的帐户，一旦您进入 account 面板，请转到 Certificates , Identifiers &amp; Profiles 标签页。在Identifiers下，单击App IDs。然后点击 （+）注册一个新的App ID。App ID说明应简单（例如NFC）。填入 Explicit App ID 和 Bundle ID 。 必须与您在 Xcode 项目中使用的Bundle ID 完全一致，就是com.YOURDOMAIN.Message-in-a-Bottle。一旦你把你的Bundle ID放入，向下滚动并检测服务列表。点击下一步，确保您的确认页面与我的相似： Provisioning Profiles完成设置后，我们需要为此应用程序创建一个新的配置文件。转到 Provisioning Profiles 选项卡，然后单击 all。然后，单击（+）创建一个新的配置文件。选择iOS Development，继续选择 App ID的名称（我的是NFC），继续选择您使用的证书，添加想要测试此应用程序的任何手机。命名新建的配置文件，我们就生成了一个新的有效的配置文件。 此处解释一下什么是 配置文件 ？ 配置文件 要验证在所选设备上运行的特定的应用。这样，您可以确认在设备上运行的应用程序可追溯出处并确保安全。所以我们也需要为我们的 App 选择特定的 配置文件 。为此，请返回 Xcode &gt; build setting &gt; 禁用 Automatically manage signing 。对于 Debug和 Release，选择下拉菜单并选择 Download profile。找到对应的相关配置文件，前期准备工作就完成了！ App Entitlements 然而，Xcode 团队尚未启用 CoreNFC 的自动授权。现在，下载此预构建的授权文件，并将文件位置放在 Project&gt; build setting &gt; Code Signing Entitlement 的文本框中。 我们预计苹果将在不久的将来更新此功能，但现在这个步骤不可避免。所以如果发布了一个新的测试版本，可以回到这个教程重新测试。 App Privacy打开 Info.plist 并右键单击以添加一行。在 Key 列中，打开下拉菜单并选择 Privacy - NFC Scan Usage Description。在 value 中设置自定义的提示信息。我们对 plist 文件的更新允许我们的 App 获取访问 NFC 的必要权限。 实现CoreNFC接下来让我们来看看有趣的部分！我们将继续向 ViewController.swift 添加几行代码。但在我们写代码之前，需要提一下一个让我调试了几个小时的问题。 目前 CoreNFC 框架尚未编译进 iOS 模拟器。这意味着如果你尝试import CoreNFC 你会得到一个错误，说没有 CoreNFC 模块。简单的修复方法就是主动选择您的 iPhone 或 通用设备。 123456789101112131415161718192021222324252627282930import UIKitimport CoreNFC class ViewController: UIViewController, NFCNDEFReaderSessionDelegate &#123; @IBOutlet weak var messageLabel: UILabel! var nfcSession: NFCNDEFReaderSession? override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; @IBAction func scanPressed(_ sender: Any) &#123; &#125; func readerSession(_ session: NFCNDEFReaderSession, didInvalidateWithError error: Error) &#123; print(\"The session was invalidated: \\(error.localizedDescription)\") &#125; func readerSession(_ session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage]) &#123; // Parse the card's information &#125; 我们只需要再添加两行代码就可以启动 NFC reader 。更新我们之前创建的 scanPressed 方法来调用NFCNDEFReaderSession初始化器。 12345@IBAction func scanPressed(_ sender: Any) &#123; nfcSession = NFCNDEFReaderSession.init(delegate: self, queue: nil, invalidateAfterFirstRead: true) nfcSession?.begin()&#125; 如果您的程序在运行时出现 Session is invalidated unexpectedly 错误，请返回并再次检查 设置权限和隐私 部分。 解析消息记录首先，我们来看看 func readerSession(_ session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage]) 我们可以通过打印messages 的第一个元素来认识它。 1234567( // Payload one (There's only one payload in this card) \"TNF=1, /* Type Name Format */ Payload Type=&lt;55&gt;, Payload ID=&lt;&gt;, Payload=&lt;0048656c 6c6f21&gt;\" /* What we're really interested in */) `messages` 是一个 存储`NFCNDEFMessages` 数据格式数组，在 `NFC` 会话无效之前，我们执行的每次扫描都有一个数组，而在我们扫描后，会话会自动失效。我们只需要关注数组中的一个对象。 messages[0] 是一个 NFCNDEFMessage，它包含一个 NFCNDEFPayload。messages[0].records 是一个 NFCNDEFPayload 数组，因为 NDEF卡 可以包含多个 payLoad。 单一 NFCNDEFPayload 包含4项信息： identifier type typeNameFormat payload是一个 Data 类型的对象 123456789func readerSession(_ session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage]) &#123; var result = \"\" for payload in messages[0].records &#123; result += String.init(data: payload.payload.advanced(by: 3), encoding: .utf8)! // 1 &#125; DispatchQueue.main.async &#123; self.messageLabel.text = result &#125; 此处有几个问题。为什么要前进3？DispatchQueue的内容是什么？ 为什么 NFC 标签总是以 enHello 或 enMessage 开头。在对 NDEF 规范和法规进行了一些研究后发现： 所有语言代码必须根据 RFC 3066 完成。语言代码不能省略。语言代码长度被编码在状态字节的六个最低有效位中。因此，通过使用值 0x3F 屏蔽状态字节很容易找到。 第3行将 payload 从 data 类型转换为可读的 string 字符串。” 关于这个问题 DispatchQueue，在readerSession 中 messageLabel 是不可访问的。所以我们要返回主线程，给 messageLabel 赋值，这也是线程间通信的一个最简单的方法。 这是最终的样式：","content":"<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/iOS11%E4%B8%AD%E4%BD%BF%E7%94%A8CoreNFC/1.png\" alt=\"\"></p>\n<p>在2017的<code>WWDC</code>,苹果终于发布了众多开发者期待已久的系统级框架 <code>CoreNFC</code>。可能你对于<code>NFC</code>是什么并不是很了解，简而言之，<code>NFC</code>（近场通信）就是当两台硬件设备相距<code>4cm</code>以内时可以实现互相通信。<code>NFC</code>在商业上的应用是把<code>NFC</code>芯片集成到各类卡片中，极大的加强安全性。目前 <code>CoreNFC</code> 只支持一种格式：<code>NFC Data Exchange Format</code>，简称<code>NDEF</code>(常被用于平板电脑和智能手机中)。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>提示：接下来的教程你需要<code>Xcode9 beta</code>,同时你也需要一部<code>iPhone7</code>或者<code>iPhone 7 Plus</code>运行<code>iOS 11</code>系统来验证本教程中的一些新特性。<code>Xcode9 beta</code>可以同时支持<code>Swift 3.2</code>和<code>Swift 4.0</code>,本教程的代码都将使用<code>Swift 4.0</code>来编写。只是在项目中导入<code>CoreNFC</code>是无法构建或者编译一个<code>App</code>的,必须在物理设备上才可以运行。同时你还需要一个已经付费的开发者账号才可以。</p>\n</blockquote>\n<h2 id=\"什么是CoreNFC\"><a href=\"#什么是CoreNFC\" class=\"headerlink\" title=\"什么是CoreNFC\"></a>什么是CoreNFC</h2><blockquote>\n<p>通过<code>NFC</code>，你可以阅读到包括<code>NFC数据交换格式</code>（NDEF）数据中的1到5类的近场通讯标签。读取标签，你的App创建了一个<code>NFC数据交换格式</code>的<code>reader session</code>并且提供了一个 <code>delegate</code> 。正在运行的<code>reader session</code> 轮询 <code>NFC</code> 标签，并在 <code>delegate</code> 方法中找到包含 <code>NDEF</code> 消息的标签时传递消息，并将该消息传递给 <code>delegate</code> 。<code>delegate</code>可以读取消息并处理异常。</p>\n</blockquote>\n<p><code>NFC</code>谈不上“新”技术。苹果终于向开发者开放了这个 <code>API</code>，以便我们可以利用 <code>NFC</code> 识别信息。</p>\n<p><strong>举一个实际的例子</strong><br>你经营一家商店，希望客户进入后，使用有<code>NFC</code>功能的手机扫描一件商品，就直接完成了所有的流程。没有任何麻烦，没有等待时间。作为一名<code>App</code>开发人员，在不使用<code>NFC</code>的情况下，还可以选择<code>条形码</code>或<code>二维码</code>，但依然比<code>NFC</code>麻烦很多。</p>\n<p>说来说去<code>NFC</code>到底是什么？苹果虽然放开了<code>NFC</code>的使用权限，但苹果公司严格限制了我们的访问。这意味着<code>CoreNFC</code>只支持前面提到的<code>NDEF</code>格式。如果您打算使用<code>CoreNFC</code>替换您的`RFID卡,恐怕还有待时间。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>我们将用一个 <code>demo</code> 来展示如何使用 <code>CoreNFC</code> 。我们的应用程序将读取存储在 <code>NDEF格式</code> 卡上的信息。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/working-scanner-01.png\" alt=\"\"></p>\n<p>为此，我使用 <code>Arduino Uno</code> 与 <code>Adafruit PN532 Shield</code> 配对，将消息编程到 <code>N​​DEF</code> 格式的样品卡上。如果您没有这些工具，或者根本不想将时间和金钱投入到这样的硬件中，请尝试找到一张带有消息的预格式化卡。在本教程中，我将不会将 <code>NFC</code> 格式化或将消息嵌入到 <code>NDEF</code> 卡中。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/working-scanner-02.jpg\" alt=\"\"></p>\n<h2 id=\"我们开始吧\"><a href=\"#我们开始吧\" class=\"headerlink\" title=\"我们开始吧\"></a>我们开始吧</h2><p>要创建我们的项目，请打开 <code>Xcode 9</code> 并创建一个新的 <code>single-view application</code> 。然后命名您的项目，并确保选择 <code>Swift</code> 作为您的语言。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/working-scanner-03.png\" alt=\"\"></p>\n<h2 id=\"设计消息视图\"><a href=\"#设计消息视图\" class=\"headerlink\" title=\"设计消息视图\"></a>设计消息视图</h2><p>为达到目的，我们需要制作用户界面（UI），供用户进行交互。我们先创建一个<code>导航控制器</code>。点击 <code>Main.storyboard</code> 并选择<code>View-Controller</code>。然后，转到<code>status-Bar</code>，然后单击<code>Editor</code>&gt;<code>embed in</code>&gt;<code>Navigation Controller</code>。这会在<code>View-Controller</code>的顶部创建一个导航栏。您可以选择一个合适的标题。我起的标题为 <code>Message in a Bottle</code>。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/working-scanner-04.png\" alt=\"\"></p>\n<p>接下来，拖动<code>UIButton</code>并将其放在 <code>View-Controller</code> 的底部。将按钮的文本更改为<code>扫描</code>，并根据需要进行初始化。添加扫描按钮后，利用<code>UILabel</code>添加背景标题。</p>\n<p><strong>现在我们的应用应该是这样的：</strong></p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/working-scanner-05.png\" alt=\"\"></p>\n<h2 id=\"设置扫描和消息\"><a href=\"#设置扫描和消息\" class=\"headerlink\" title=\"设置扫描和消息\"></a>设置扫描和消息</h2><p>现在我们已经做好了基础设置，接下来我们将为<code>按钮</code>和<code>标签</code>通过拖线设置属性，并为<code>按钮</code>设置点击行为。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/working-scanner-06.png\" alt=\"\"></p>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> UIKit</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> messageLabel: <span class=\"type\">UILabel</span>!</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</div><div class=\"line\">        <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceiveMemoryWarning</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.didReceiveMemoryWarning()</div><div class=\"line\">        <span class=\"comment\">// Dispose of any resources that can be recreated.</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">scanPressed</span><span class=\"params\">(<span class=\"number\">_</span> sender: Any)</span></span> &#123;</div><div class=\"line\">        <span class=\"comment\">// this is our newly created IBAction</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"设置应用程序权限和隐私\"><a href=\"#设置应用程序权限和隐私\" class=\"headerlink\" title=\"设置应用程序权限和隐私\"></a>设置应用程序权限和隐私</h2><p>接下来，在我们真正开始研究我们的 <code>NFC</code> 实现之前，我们需要设置我们的应用权限。</p>\n<blockquote>\n<p>注意：您必须非常仔细地关注此部分，否则您的应用配置将无法正常工作。此外，您将需要付费的开发者帐户。</p>\n</blockquote>\n<hr>\n<h4 id=\"App-ID\"><a href=\"#App-ID\" class=\"headerlink\" title=\"App ID\"></a>App ID</h4><p>首先，请转到 <code>developer.apple.com</code> 登录您的帐户，一旦您进入 <code>account</code> 面板，请转到 <code>Certificates , Identifiers &amp; Profiles</code> 标签页。在<code>Identifiers</code>下，单击<code>App IDs</code>。然后点击 <code>（+）</code>注册一个新的<code>App ID</code>。<code>App ID</code>说明应简单（例如<code>NFC</code>）。<br>填入 <code>Explicit App ID</code> 和  <code>Bundle ID</code> 。 必须与您在 <code>Xcode</code> 项目中使用的<code>Bundle ID</code> 完全一致，就是<code>com.YOURDOMAIN.Message-in-a-Bottle</code>。一旦你把你的<code>Bundle ID</code>放入，向下滚动并检测服务列表。点击下一步，确保您的确认页面与我的相似：</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/working-scanner-07.png\" alt=\"\"></p>\n<h4 id=\"Provisioning-Profiles\"><a href=\"#Provisioning-Profiles\" class=\"headerlink\" title=\"Provisioning Profiles\"></a>Provisioning Profiles</h4><p>完成设置后，我们需要为此应用程序创建一个新的<code>配置文件</code>。转到 <code>Provisioning Profiles</code> 选项卡，然后单击 <code>all</code>。然后，单击<code>（+）</code>创建一个新的<code>配置文件</code>。选择<code>iOS Development</code>，继续选择 <code>App ID</code>的名称（我的是<code>NFC</code>），继续选择您使用的<code>证书</code>，添加想要测试此应用程序的任何手机。命名新建的<code>配置文件</code>，我们就生成了一个新的有效的<code>配置文件</code>。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/working-scanner-08.png\" alt=\"\"></p>\n<blockquote>\n<p>此处解释一下什么是 <code>配置文件</code> ？ <code>配置文件</code> 要验证在所选设备上运行的特定的应用。这样，您可以确认在设备上运行的应用程序可追溯出处并确保安全。<br>所以我们也需要为我们的 <code>App</code> 选择特定的 <code>配置文件</code> 。为此，请返回 <code>Xcode</code> &gt; <code>build setting</code> &gt; 禁用 <code>Automatically manage signing</code> 。对于 <code>Debug</code>和 <code>Release</code>，选择下拉菜单并选择 <code>Download profile</code>。找到对应的相关配置文件，前期准备工作就完成了！</p>\n</blockquote>\n<h4 id=\"App-Entitlements\"><a href=\"#App-Entitlements\" class=\"headerlink\" title=\"App Entitlements\"></a>App Entitlements</h4><p> 然而，<code>Xcode</code> 团队尚未启用 <code>CoreNFC</code> 的自动授权。现在，下载此预构建的<a href=\"https://raw.githubusercontent.com/appcoda/CoreNFCDemo/master/NFC.entitlements\" target=\"_blank\" rel=\"external\">授权文件</a>，并将文件位置放在 <code>Project</code>&gt; <code>build setting</code> &gt; <code>Code Signing Entitlement</code> 的文本框中。</p>\n<p>我们预计苹果将在不久的将来更新此功能，但现在这个步骤不可避免。所以如果发布了一个新的测试版本，可以回到这个教程重新测试。</p>\n<h4 id=\"App-Privacy\"><a href=\"#App-Privacy\" class=\"headerlink\" title=\"App Privacy\"></a>App Privacy</h4><p>打开 <code>Info.plist</code> 并右键单击以添加一行。在 <code>Key</code> 列中，打开下拉菜单并选择 <code>Privacy - NFC Scan Usage Description</code>。在 <code>value</code> 中设置自定义的提示信息。我们对 <code>plist</code> 文件的更新允许我们的 <code>App</code> 获取访问 <code>NFC</code> 的必要权限。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/working-scanner-09.png\" alt=\"\"></p>\n<h2 id=\"实现CoreNFC\"><a href=\"#实现CoreNFC\" class=\"headerlink\" title=\"实现CoreNFC\"></a>实现CoreNFC</h2><p>接下来让我们来看看有趣的部分！我们将继续向 <code>ViewController.swift</code> 添加几行代码。但在我们写代码之前，需要提一下一个让我调试了几个小时的问题。</p>\n<p>目前 <code>CoreNFC</code> 框架尚未编译进 <code>iOS</code> 模拟器。这意味着如果你尝试<code>import CoreNFC</code> 你会得到一个错误，说没有 <code>CoreNFC</code> 模块。简单的修复方法就是主动选择您的 iPhone 或 通用设备。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> UIKit</div><div class=\"line\"><span class=\"keyword\">import</span> CoreNFC </div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">NFCNDEFReaderSessionDelegate</span> </span>&#123; </div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> messageLabel: <span class=\"type\">UILabel</span>!</div><div class=\"line\">    <span class=\"keyword\">var</span> nfcSession: <span class=\"type\">NFCNDEFReaderSession</span>?</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</div><div class=\"line\">        <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceiveMemoryWarning</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.didReceiveMemoryWarning()</div><div class=\"line\">        <span class=\"comment\">// Dispose of any resources that can be recreated.</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">scanPressed</span><span class=\"params\">(<span class=\"number\">_</span> sender: Any)</span></span> &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readerSession</span><span class=\"params\">(<span class=\"number\">_</span> session: NFCNDEFReaderSession, didInvalidateWithError error: Error)</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"The session was invalidated: \\(error.localizedDescription)\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readerSession</span><span class=\"params\">(<span class=\"number\">_</span> session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage])</span></span> &#123;</div><div class=\"line\">        <span class=\"comment\">// Parse the card's information</span></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>我们只需要再添加两行代码就可以启动 <code>NFC reader</code> 。更新我们之前创建的 <code>scanPressed</code> 方法来调用NFCNDEFReaderSession初始化器。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">scanPressed</span><span class=\"params\">(<span class=\"number\">_</span> sender: Any)</span></span> &#123;</div><div class=\"line\"></div><div class=\"line\">    nfcSession = <span class=\"type\">NFCNDEFReaderSession</span>.<span class=\"keyword\">init</span>(delegate: <span class=\"keyword\">self</span>, queue: <span class=\"literal\">nil</span>, invalidateAfterFirstRead: <span class=\"literal\">true</span>)</div><div class=\"line\">    nfcSession?.begin()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/working-scanner-10.png\" alt=\"\"></p>\n<p>如果您的程序在运行时出现 <code>Session is invalidated unexpectedly</code> 错误，请返回并再次检查 <code>设置权限和隐私</code> 部分。</p>\n<h2 id=\"解析消息记录\"><a href=\"#解析消息记录\" class=\"headerlink\" title=\"解析消息记录\"></a>解析消息记录</h2><p>首先，我们来看看 <code>func readerSession(_ session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage])</code></p>\n<p>我们可以通过打印<code>messages</code> 的第一个元素来认识它。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">( </div><div class=\"line\">    // Payload one (There's only one payload in this card)</div><div class=\"line\">    \"TNF=1, /* Type Name Format */</div><div class=\"line\">    Payload Type=&lt;55&gt;,</div><div class=\"line\">    Payload ID=&lt;&gt;,</div><div class=\"line\">    Payload=&lt;0048656c 6c6f21&gt;\" /* What we're really interested in */</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<pre><code>`messages` 是一个 存储`NFCNDEFMessages` 数据格式数组，在 `NFC` 会话无效之前，我们执行的每次扫描都有一个数组，而在我们扫描后，会话会自动失效。我们只需要关注数组中的一个对象。\n</code></pre><p><code>messages[0]</code> 是一个 <code>NFCNDEFMessage</code>，它包含一个 <code>NFCNDEFPayload</code>。<br><code>messages[0].records</code> 是一个 <code>NFCNDEFPayload</code> 数组，因为 <code>NDEF卡</code> 可以包含多个 <code>payLoad</code>。</p>\n<p><strong>单一 <code>NFCNDEFPayload</code> 包含4项信息：</strong></p>\n<ol>\n<li>identifier</li>\n<li>type</li>\n<li>typeNameFormat</li>\n<li>payload是一个 <code>Data</code> 类型的对象</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readerSession</span><span class=\"params\">(<span class=\"number\">_</span> session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage])</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"string\">\"\"</span></div><div class=\"line\">    <span class=\"keyword\">for</span> payload <span class=\"keyword\">in</span> messages[<span class=\"number\">0</span>].records &#123;</div><div class=\"line\">        result += <span class=\"type\">String</span>.<span class=\"keyword\">init</span>(data: payload.payload.advanced(by: <span class=\"number\">3</span>), encoding: .utf8)! <span class=\"comment\">// 1</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"type\">DispatchQueue</span>.main.async &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.messageLabel.text = result</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p><strong>此处有几个问题。为什么要前进3？DispatchQueue的内容是什么？</strong></p>\n<p>为什么 <code>NFC</code> 标签总是以 <code>enHello</code> 或 <code>enMessage</code> 开头。在对 <code>NDEF</code> 规范和法规进行了一些研究后发现：</p>\n<blockquote>\n<p>所有语言代码必须根据 <code>RFC 3066</code> 完成。语言代码不能省略。语言代码长度被编码在状态字节的六个最低有效位中。因此，通过使用值 <code>0x3F</code> 屏蔽状态字节很容易找到。</p>\n</blockquote>\n<p>第3行将 <code>payload</code> 从 <code>data</code> 类型转换为可读的 <code>string</code> 字符串。”</p>\n<p>关于这个问题 <code>DispatchQueue</code>，在<code>readerSession</code> 中 <code>messageLabel</code> 是不可访问的。所以我们要返回主线程，给 <code>messageLabel</code> 赋值，这也是线程间通信的一个最简单的方法。</p>\n<p>这是最终的样式：</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/working-scanner-11.gif\" alt=\"\"></p>\n","excerpt":"在2017的WWDC,苹果终于发布了众多开发者期待已久的系统级框架 CoreNFC。可能你对于NFC是什么并不是很了解，简而言之，NFC（近场通信）就是当两台硬件设备相距4cm以内时可以实现互相通信。NFC在商业上的应用是把NFC芯片集成到各类卡片中，极大的加强安全性。目前 CoreNFC 只支持一种格式：NFC Data Exchange Format，简称NDEF(常被用于平板电脑和智能手机中)。","categories":[],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://yoursite.com/tags/翻译/"}]},{"title":"Obj-C灵魂-Runtime","date":"2017-07-12T02:11:14.000Z","path":"2017/07/12/Obj-C灵魂-Runtime/","text":"Obj-C之所以被称之为动态语言，完全是因为Runtime库，Runtime库是由C语言和汇编语言所写的，它在C语言的基础上，为Obj-C增加了面向对象的特征。同时借鉴SmallTalk增加了消息转发。说透彻了就是我们所写的所有Obj-C代码，都会通过Runtime库转换为C语言的代码。针对这么一个大家无时不刻都在使用的类库，是有必要深入了解一下的。 1.数据结构及常用名词解释之所以开篇将一些数据的结构组成以及常用的名词解释，是为了大家在后续的过程中不会懵逼，咱们也不着急，那就一步步，踏踏实实的看。 1.Class 我们通常所说的 Class，实际上是指向 objc_class 结构体的指针，objc_class在 objc_class里定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct objc_class &#123; Class isa; // is a kind of的意思#if !__OBJC2__ Class super_class; // 获取父类 const char *name; // 类名 long version; // 类的版本号 long info; // 理解为类的相关信息 long instance_size; // 实例的大小 struct objc_ivar_list *ivars; // 获取成员变量列表 struct objc_method_list **methodLists; // 获取方法列表 struct objc_cache *cache; // 方法缓存列表 struct objc_protocol_list *protocols; // 获取协议列表#endif&#125;;// 获取类名const char * class_getName ( Class class);// 获取父类Class class_getSuperclass ( Class class );// 判断给定的Class是否是一个元类BOOL class_isMetaClass ( Class class );// 获取实例大小size_t class_getInstanceSize ( Class class );// 获取类中指定名称实例成员变量的信息Ivar class_getInstanceVariable ( Class class, const char *name );// 获取类成员变量的信息Ivar class_getClassVariable ( Class class, const char *name );// 添加成员变量BOOL class_addIvar ( Class class, const char *name, size_t size, uint8_t alignment, const char *types );// 获取整个成员变量列表Ivar * class_copyIvarList ( Class class, unsigned int *outCount );// 添加协议BOOL class_addProtocol ( Class cls, Protocol *protocol );// 返回类是否实现指定的协议BOOL class_conformsToProtocol ( Class cls, Protocol *protocol );// 获取版本号int class_getVersion ( Class cls );// 设置版本号void class_setVersion ( Class cls, int version ); 2.Object123struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY; // 指向所属的类&#125;; 3.Method123456789101112131415161718192021222324252627struct objc_method &#123; SEL method_name; // Hased MethodName char *method_types; // TypeEncoding IMP method_imp; // Implemention&#125;;// 添加方法BOOL class_addMethod ( Class class, SEL name, IMP imp, const char *types );// 获取实例方法Method class_getInstanceMethod ( Class class, SEL name );// 获取类方法Method class_getClassMethod ( Class class, SEL name );// 获取所有方法的数组Method * class_copyMethodList ( Class class, unsigned int *outCount );// 替代方法的实现IMP class_replaceMethod ( Class class, SEL name, IMP imp, const char *types );// 返回方法的具体实现IMP class_getMethodImplementation ( Class class, SEL name );IMP class_getMethodImplementation_stret ( Class class, SEL name );// 类实例是否响应指定的selectorBOOL class_respondsToSelector ( Class class, SEL sel ); 4.Property1234567891011// 获取指定的属性objc_property_t class_getProperty ( Class class, const char *name );// 获取属性列表objc_property_t * class_copyPropertyList ( Class class, unsigned int *outCount );// 为类添加属性BOOL class_addProperty ( Class class, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );// 替换类的属性void class_replaceProperty ( Class class, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount ); 2.方法调用流程 1.objc在向一个对象发送消息时，发生了什么？Obj-C采用的是消息转发机制来实现方法的调用。 12345678910111213141516171819// 定义了一个Person类，有一个最简单的吃东西的方法@interface Person : NSObject- (void)eat:(NSString *)foodName andCount:(int)count;@end#import \"Person.h\"@implementation Person- (void)eat:(NSString *)foodName andCount:(int *)count &#123; NSLog(@\"Person eat %d-%@\",count,foodName); &#125;@end 我们在VC中调用这个方法 12345Person *person = [[Person alloc] init];[person eat:@\"potatoo\" andCount:5];// 实际上调用的是一下方法，如果有多个参数，在后面依次排开objc_msgsend(person,@selector(eat:andCount:),5); 我们根据上面的图片可以推导出： 1.对象会根据自己的isa指针找到自己所属的类。 2.从当前类 Method_List 中，查找对应的 SEL(方法名Hash化)。 3.如果查找不到就到当前类的父类中查找。 4.向上的链条一直找不到就会报出崩溃。 但是你可能会感到很疑惑，每次调用方法都必须到自己的当前类，父类以及更上的层级去遍历岂不是很耗费时间，所以我们可以引出objc_Cache,objc_Cache会把最常用的方法存储起来，以method_name作为Key值，以method_imp作为value值进行存储，这样下一次就会优先查找objc_cache了，大大提高了效率。 12345struct objc_cache &#123; unsigned int mask; unsigned int occupied; Method buckets[1];&#125;;","content":"<blockquote>\n<p><code>Obj-C</code>之所以被称之为动态语言，完全是因为<code>Runtime</code>库，<code>Runtime</code>库是由<code>C语言</code>和<code>汇编语言</code>所写的，它在<code>C语言</code>的基础上，为<code>Obj-C</code>增加了面向对象的特征。同时借鉴<code>SmallTalk</code>增加了消息转发。说透彻了就是我们所写的所有<code>Obj-C</code>代码，都会通过<code>Runtime库</code>转换为<code>C语言</code>的代码。针对这么一个大家无时不刻都在使用的类库，是有必要深入了解一下的。</p>\n</blockquote>\n<h3 id=\"1-数据结构及常用名词解释\"><a href=\"#1-数据结构及常用名词解释\" class=\"headerlink\" title=\"1.数据结构及常用名词解释\"></a>1.数据结构及常用名词解释</h3><p>之所以开篇将一些数据的结构组成以及常用的名词解释，是为了大家在后续的过程中不会懵逼，咱们也不着急，那就一步步，踏踏实实的看。</p>\n<h5 id=\"1-Class\"><a href=\"#1-Class\" class=\"headerlink\" title=\"1.Class\"></a>1.Class</h5><p> 我们通常所说的 <strong>Class</strong>，实际上是指向 <strong>objc_class</strong> 结构体的指针，<strong>objc_class</strong>在 <strong>objc_class</strong>里定义如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> objc_class &#123;</div><div class=\"line\">    Class isa;                                  <span class=\"comment\">// is a kind of的意思</span></div><div class=\"line\"><span class=\"meta\">#if !__OBJC2__</span></div><div class=\"line\">    Class super_class;                          <span class=\"comment\">// 获取父类</span></div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;                           <span class=\"comment\">// 类名</span></div><div class=\"line\">    <span class=\"keyword\">long</span> version;                               <span class=\"comment\">// 类的版本号</span></div><div class=\"line\">    <span class=\"keyword\">long</span> info;                                  <span class=\"comment\">// 理解为类的相关信息</span></div><div class=\"line\">    <span class=\"keyword\">long</span> instance_size;                         <span class=\"comment\">// 实例的大小</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars;               <span class=\"comment\">// 获取成员变量列表</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists;      <span class=\"comment\">// 获取方法列表</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache;                   <span class=\"comment\">// 方法缓存列表</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols;       <span class=\"comment\">// 获取协议列表</span></div><div class=\"line\"><span class=\"meta\">#endif</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取类名</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * class_getName ( Class <span class=\"keyword\">class</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取父类</span></div><div class=\"line\">Class class_getSuperclass ( Class <span class=\"keyword\">class</span> );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 判断给定的Class是否是一个元类</span></div><div class=\"line\"><span class=\"built_in\">BOOL</span> class_isMetaClass ( Class <span class=\"keyword\">class</span> );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取实例大小</span></div><div class=\"line\">size_t class_getInstanceSize ( Class <span class=\"keyword\">class</span> );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取类中指定名称实例成员变量的信息</span></div><div class=\"line\">Ivar class_getInstanceVariable ( Class <span class=\"keyword\">class</span>, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取类成员变量的信息</span></div><div class=\"line\">Ivar class_getClassVariable ( Class <span class=\"keyword\">class</span>, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 添加成员变量</span></div><div class=\"line\"><span class=\"built_in\">BOOL</span> class_addIvar ( Class <span class=\"keyword\">class</span>, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, size_t size, uint8_t alignment, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取整个成员变量列表</span></div><div class=\"line\">Ivar * class_copyIvarList ( Class <span class=\"keyword\">class</span>, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *outCount );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 添加协议</span></div><div class=\"line\"><span class=\"built_in\">BOOL</span> class_addProtocol ( Class cls, Protocol *protocol );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 返回类是否实现指定的协议</span></div><div class=\"line\"><span class=\"built_in\">BOOL</span> class_conformsToProtocol ( Class cls, Protocol *protocol );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取版本号</span></div><div class=\"line\"><span class=\"keyword\">int</span> class_getVersion ( Class cls );</div><div class=\"line\"><span class=\"comment\">// 设置版本号</span></div><div class=\"line\"><span class=\"keyword\">void</span> class_setVersion ( Class cls, <span class=\"keyword\">int</span> version );</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h5 id=\"2-Object\"><a href=\"#2-Object\" class=\"headerlink\" title=\"2.Object\"></a>2.Object</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;           <span class=\"comment\">// 指向所属的类</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h5 id=\"3-Method\"><a href=\"#3-Method\" class=\"headerlink\" title=\"3.Method\"></a>3.Method</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> objc_method &#123;  </div><div class=\"line\">    SEL method_name;                            <span class=\"comment\">// Hased MethodName</span></div><div class=\"line\">    <span class=\"keyword\">char</span> *method_types;                         <span class=\"comment\">// TypeEncoding</span></div><div class=\"line\">    IMP method_imp;                             <span class=\"comment\">// Implemention</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 添加方法</span></div><div class=\"line\"><span class=\"built_in\">BOOL</span> class_addMethod ( Class <span class=\"keyword\">class</span>, SEL name, IMP imp, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取实例方法</span></div><div class=\"line\">Method class_getInstanceMethod ( Class <span class=\"keyword\">class</span>, SEL name );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取类方法</span></div><div class=\"line\">Method class_getClassMethod ( Class <span class=\"keyword\">class</span>, SEL name );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取所有方法的数组</span></div><div class=\"line\">Method * class_copyMethodList ( Class <span class=\"keyword\">class</span>, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *outCount );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 替代方法的实现</span></div><div class=\"line\">IMP class_replaceMethod ( Class <span class=\"keyword\">class</span>, SEL name, IMP imp, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 返回方法的具体实现</span></div><div class=\"line\">IMP class_getMethodImplementation ( Class <span class=\"keyword\">class</span>, SEL name );</div><div class=\"line\">IMP class_getMethodImplementation_stret ( Class <span class=\"keyword\">class</span>, SEL name );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 类实例是否响应指定的selector</span></div><div class=\"line\"><span class=\"built_in\">BOOL</span> class_respondsToSelector ( Class <span class=\"keyword\">class</span>, SEL sel );</div></pre></td></tr></table></figure>\n<h5 id=\"4-Property\"><a href=\"#4-Property\" class=\"headerlink\" title=\"4.Property\"></a>4.Property</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取指定的属性</span></div><div class=\"line\">objc_property_t class_getProperty ( Class <span class=\"keyword\">class</span>, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取属性列表</span></div><div class=\"line\">objc_property_t * class_copyPropertyList ( Class <span class=\"keyword\">class</span>, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *outCount );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 为类添加属性</span></div><div class=\"line\"><span class=\"built_in\">BOOL</span> class_addProperty ( Class <span class=\"keyword\">class</span>, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">const</span> objc_property_attribute_t *attributes, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> attributeCount );</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 替换类的属性</span></div><div class=\"line\"><span class=\"keyword\">void</span> class_replaceProperty ( Class <span class=\"keyword\">class</span>, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">const</span> objc_property_attribute_t *attributes, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> attributeCount );</div></pre></td></tr></table></figure>\n<h3 id=\"2-方法调用流程\"><a href=\"#2-方法调用流程\" class=\"headerlink\" title=\"2.方法调用流程\"></a>2.方法调用流程</h3><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/Runtime/Runtime1.png\" alt=\"\"></p>\n<h5 id=\"1-objc在向一个对象发送消息时，发生了什么？\"><a href=\"#1-objc在向一个对象发送消息时，发生了什么？\" class=\"headerlink\" title=\"1.objc在向一个对象发送消息时，发生了什么？\"></a>1.objc在向一个对象发送消息时，发生了什么？</h5><p>Obj-C采用的是<strong>消息转发机制</strong>来实现方法的调用。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义了一个Person类，有一个最简单的吃东西的方法</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Person</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)eat:(<span class=\"built_in\">NSString</span> *)foodName andCount:(<span class=\"keyword\">int</span>)count;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Person.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Person</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)eat:(<span class=\"built_in\">NSString</span> *)foodName andCount:(<span class=\"keyword\">int</span> *)count &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Person eat %d-%@\"</span>,count,foodName);</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>我们在VC中调用这个方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person *person = [[Person alloc] init];</div><div class=\"line\">[person eat:<span class=\"string\">@\"potatoo\"</span> andCount:<span class=\"number\">5</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 实际上调用的是一下方法，如果有多个参数，在后面依次排开</span></div><div class=\"line\">objc_msgsend(person,<span class=\"keyword\">@selector</span>(eat:andCount:),<span class=\"number\">5</span>);</div></pre></td></tr></table></figure>\n<p>我们根据上面的图片可以推导出：</p>\n<ul>\n<li>1.对象会根据自己的isa指针找到自己所属的类。</li>\n<li>2.从当前类 Method_List 中，查找对应的 SEL(方法名Hash化)。</li>\n<li>3.如果查找不到就到当前类的父类中查找。</li>\n<li>4.向上的链条一直找不到就会报出崩溃。</li>\n</ul>\n<p>但是你可能会感到很疑惑，每次调用方法都必须到自己的当前类，父类以及更上的层级去遍历岂不是很耗费时间，所以我们可以引出<code>objc_Cache</code>,<code>objc_Cache</code>会把最常用的方法存储起来，以<code>method_name</code>作为<code>Key</code>值，以<code>method_imp</code>作为<code>value</code>值进行存储，这样下一次就会优先查找<code>objc_cache</code>了，大大提高了效率。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> objc_cache &#123;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> mask;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> occupied;</div><div class=\"line\">    Method buckets[<span class=\"number\">1</span>];</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n","excerpt":"Obj-C之所以被称之为动态语言，完全是因为Runtime库，Runtime库是由C语言和汇编语言所写的，它在C语言的基础上，为Obj-C增加了面向对象的特征。同时借鉴SmallTalk增加了消息转发。说透彻了就是我们所写的所有Obj-C代码，都会通过Runtime库转换为C语言的代码。针对这么一个大家无时不刻都在使用的类库，是有必要深入了解一下的。 1.数据结构及常用名词解释之所以开篇将一些数据的结构组成以及常用的名词解释，是为了大家在后续的过程中不会懵逼，咱们也不着急，那就一步步，踏踏实实的看。 1.Class 我们通常所说的 Class，实际上是指向 objc_class 结构体的指针，objc_class在 objc_class里定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct objc_class &#123; Class isa; // is a kind of的意思#if !__OBJC2__ Class super_class; // 获取父类 const char *name; // 类名 long version; // 类的版本号 long info; // 理解为类的相关信息 long instance_size; // 实例的大小 struct objc_ivar_list *ivars; // 获取成员变量列表 struct objc_method_list **methodLists; // 获取方法列表 struct objc_cache *cache; // 方法缓存列表 struct objc_protocol_list *protocols; // 获取协议列表#endif&#125;;// 获取类名const char * class_getName ( Class class);// 获取父类Class class_getSuperclass ( Class class );// 判断给定的Class是否是一个元类BOOL class_isMetaClass ( Class class );// 获取实例大小size_t class_getInstanceSize ( Class class );// 获取类中指定名称实例成员变量的信息Ivar class_getInstanceVariable ( Class class, const char *name );// 获取类成员变量的信息Ivar class_getClassVariable ( Class class, const char *name );// 添加成员变量BOOL class_addIvar ( Class class, const char *name, size_t size, uint8_t alignment, const char *types );// 获取整个成员变量列表Ivar * class_copyIvarList ( Class class, unsigned int *outCount );// 添加协议BOOL class_addProtocol ( Class cls, Protocol *protocol );// 返回类是否实现指定的协议BOOL class_conformsToProtocol ( Class cls, Protocol *protocol );// 获取版本号int class_getVersion ( Class cls );// 设置版本号void class_setVersion ( Class cls, int version );","categories":[],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"http://yoursite.com/tags/Runtime/"}]},{"title":"KVO知识小结","date":"2017-07-06T05:56:14.000Z","path":"2017/07/06/KVO知识小结/","text":"1.认识KVO KVO类似于观察者模式，我们利用简单的代码来了解什么是KVO。 12345678910111213// 注册一个Person类#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property (nonatomic,copy) NSString *name;@end// 再注册一个Dog类#import &lt;Foundation/Foundation.h&gt;@interface Dog : NSObject@property (nonatomic,copy ) NSString *name;@end 我们在ViewController中引入头文件，并创建两个全局的属性。我们希望Person作为Dog的观察者，当Dog的name属性发生变化的时候，Person可以第一时间知道。这时我们就可以运用KVO的技术。 12345678910111213141516 Person *p = [Person new]; self.p = p; Dog *dog = [Dog new]; self.dog = dog;// 成为其他对象的观察者要进行注册// KeyPath代表监听对象的具体属性// Observe就是观察者喽// Options可以指定管擦得值得新旧等// Context可以是任何对象，可以向观察者传递信息，也可以用指定的标识对不同的观察者进行区分 [dog addObserver:p forKeyPath:@\"name\" options:(NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld) context:nil]; dog.name = @\"旺财\"; 监听选项Options是由枚举NSKeyValueObservingOptions定义的，他决定了哪些值可以被传入到观察者内部实现的方法中。 定义如下： 123456789101112131415161718enum &#123; // 提供新值 NSKeyValueObservingOptionNew = 0x01, // 提供旧值 NSKeyValueObservingOptionOld = 0x02, // 添加观察者时立即发送一个通知给观察者， // 并且是在注册观察者方法返回之前 NSKeyValueObservingOptionInitial = 0x04, // 如果指定，则在每次修改属性时，会在修改通知被发送之前预先发送一条通知给观察者， // 这与-willChangeValueForKey:被触发的时间是相对应的。 // 这样，在每次修改属性时，实际上是会发送两条通知。 NSKeyValueObservingOptionPrior = 0x08 &#125;;typedef NSUInteger NSKeyValueObservingOptions;// 选项值可以支持多个选项 注册之后，我们要在观察者内部实现如下方法 1234567891011121314151617// 此时，当被观察者的属性发生变更，观察者就会自动调用如下方法- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; // keyPath被观察的属性值 NSLog(@\"keyPath = %@\",keyPath); // object被观察的对象 NSLog(@\"object = %@\",object); // 被观察属性值得变化，后面还会讲 NSLog(@\"change = %@\",change); // 上下文，也可以是任意的额外数据 // 这个Context的作用十分重要，我在后面会强调 NSLog(@\"context = %@\",context);&#125;// 我们通过这个方法，可以得到一些关键信息 Change选项，它记录了被监听属性的变化情况。可以通过key来获取值： 123456789101112131415161718192021222324252627// 属性变化的类型，是一个NSNumber对象，包含NSKeyValueChange枚举相关的值NSString *const NSKeyValueChangeKindKey;// 属性的新值。当NSKeyValueChangeKindKey是 NSKeyValueChangeSetting，// 且添加观察的方法设置了NSKeyValueObservingOptionNew时，我们能获取到属性的新值。// 如果NSKeyValueChangeKindKey是NSKeyValueChangeInsertion或者NSKeyValueChangeReplacement，// 且指定了NSKeyValueObservingOptionNew时，则我们能获取到一个NSArray对象，包含被插入的对象或// 用于替换其它对象的对象。NSString *const NSKeyValueChangeNewKey;// 属性的旧值。当NSKeyValueChangeKindKey是 NSKeyValueChangeSetting，// 且添加观察的方法设置了NSKeyValueObservingOptionOld时，我们能获取到属性的旧值。// 如果NSKeyValueChangeKindKey是NSKeyValueChangeRemoval或者NSKeyValueChangeReplacement，// 且指定了NSKeyValueObservingOptionOld时，则我们能获取到一个NSArray对象，包含被移除的对象或// 被替换的对象。NSString *const NSKeyValueChangeOldKey;// 如果NSKeyValueChangeKindKey的值是NSKeyValueChangeInsertion、NSKeyValueChangeRemoval// 或者NSKeyValueChangeReplacement，则这个key对应的值是一个NSIndexSet对象，// 包含了被插入、移除或替换的对象的索引NSString *const NSKeyValueChangeIndexesKey;// 当指定了NSKeyValueObservingOptionPrior选项时，在属性被修改的通知发送前，// 会先发送一条通知给观察者。我们可以使用NSKeyValueChangeNotificationIsPriorKey// 来获取到通知是否是预先发送的，如果是，获取到的值总是@(YES)NSString *const NSKeyValueChangeNotificationIsPriorKey; NSKeyValueChangeKindKey的值取自于NSKeyValueChange，这是一个枚举值，定义如下 1234567891011121314enum &#123; // 设置一个新值。被监听的属性可以是一个对象，也可以是一对一关系的属性或一对多关系的属性。 NSKeyValueChangeSetting = 1, // 表示一个对象被插入到一对多关系的属性。 NSKeyValueChangeInsertion = 2, // 表示一个对象被从一对多关系的属性中移除。 NSKeyValueChangeRemoval = 3, // 表示一个对象在一对多的关系的属性中被替换 NSKeyValueChangeReplacement = 4&#125;;typedef NSUInteger NSKeyValueChange; 注意，观察者在不需要使用的时候一定要移除，否则会产生崩溃 1234- (void)dealloc &#123; [self.dog removeObserver:self.p forKeyPath:@\"name\"];&#125; 通过上面简要的代码示例，我们可以得知，时运观察者只需要实现简单的几步。 注册观察者 观察者实现相应的方法 移除观察者 2.KVC和KVO的实现原理KVC和KVO是基于强大的Runtime来实现的。其中使用到的技术就是isa-swilling,isa-swilling这项技术也是一个重点，我们会在后续的Runtime部分会讲到。如果有看到此处不明白的同学也请保持耐心。 网上有一篇文章针对实现原理写的很好，链接在此。 整体来说就是，当某个类的对象第一次被观察时，系统会在运行期间动态的为这个类创建一个派生类，假如被监听类名为ClassA，那么派生类的名称就为NSKVONotifying_ClassA。 1.原有对象的isa指针会指向全新的派生类，派生类为了混淆，避免别人知道他不是原来的类，所以派生类重写了Class的类方法。 2.同时重写了Dealloc方法，用于资源的销毁处理。 3.还重写了_isKVOA,这个是一个标记，用于标示这个类是遵守KVO机制的。 4.最关键的是重写了被监听属性的Setter方法，这是实现KVO的关键。至于为什么，后面会讲解到。 简单的画了张图，可能会有助于理解。 我们上面讲重写了被观察对象属性的Setter方法是十分关键的，这就要说起另外两个十分重要的方法 123456789101112// 在属性值即将被修改的时候，会调用这个方法- (void)willChangeValueForKey:(NSString *)key;// 在属性值已经被修改的时候，会调用这个方法- (void)didChangeValueForKey:(NSString *)key;// didChangeValueForKey:方法会显式的调用- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; &#125; 其实我个人猜测，重写Setter方法内部应该这样实现的 123[self willChangeValueForKey:@\"name\"];[super setName:name];[self didChangeValueForKey:@\"name\"]; 说到这里，相信你应该完整的明白KVO的实现机制了。 12// 这才是KVO机制触发的关键- (void)didChangeValueForKey:(NSString *)key; 3.调用KVO的三种方法综合上面KVO的实现原理，我们可以得出如下结论： 1.使用了KVC使用了KVC，如果有访问器方法，则运行时会在访问器方法中调用will/didChangeValueForKey:方法；没用访问器方法，运行时会在setValue:forKey方法中调用will/didChangeValueForKey:方法。 2.有访问器方法运行时会重写访问器方法调用will/didChangeValueForKey:方法。因此，直接调用访问器方法改变属性值时，KVO也能监听到。 3.直接调用显式调用will/didChangeValueForKey:方法。 4.KVO自动通知、手动通知通常意义下我们使用的都是自动通知，注册观察者之后，当触发will/didChangeValueForKey:方法后，观察者对象的- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context { }方法会被调用。 如果像实现手动通知，我们需要借助一个额外的方法 1+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key 这个方法默认返回YES,用来标记Key指定的属性是否支持KVO，如果返回值为NO，则需要我们手动更新。 我们还是用我们最上面的例子，监听Person的name属性，不过这次我们采取手动通知的方式。 12345678910111213141516171819#import \"Person.h\"@implementation Person+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123; BOOL automaic = NO; if ([key isEqualToString:@\"name\"]) &#123; automaic = NO; &#125; else &#123; // 此处需要注意，没有被处理的其他属性要调用父类的原有方法 automaic = [super automaticallyNotifiesObserversForKey:key]; &#125; return automaic;&#125;@end 这样我们就已经标记好当Person的name属性发生改变时，手动发送通知，代码如下： 1234567891011121314@implementation Person- (void)setName:(NSString *)name &#123; if(name != _name)// 加一处判断，如果值相同，就无需发送通知了 &#123; // 我们需要在值修改前调用`will...`方法 [self willChangeValueForKey:@\"name\"]; _name = name; // 我们还需要在修改后调用`did...`方法，显式调用观察者的方法 [self didChangeValueForKey:@\"name\"]; &#125;&#125;@end 手动发送通知一对一的操作方法如上，如果是一对多的案例，则可以使用如下方法 12345- (void)willChange:(NSKeyValueChange)change valuesAtIndexes:(NSIndexSet *)indexes forKey:(NSString *)key- (void)didChange:(NSKeyValueChange)change valuesAtIndexes:(NSIndexSet *)indexes forKey:(NSString *)key - (void)willChangeValueForKey:(NSString *)key withSetMutation:(NSKeyValueSetMutationKind)mutationKind usingObjects:(NSSet *)objects- (void)didChangeValueForKey:(NSString *)key withSetMutation:(NSKeyValueSetMutationKind)mutationKind usingObjects:(NSSet *)objects 5.注册依赖键实际开发过程中可能会遇到这种场景，某个变量的值取决于其他的值。 我们还是看一个例子吧： 1234567891011121314151617181920212223242526272829303132333435// 声明一个Person类，有三个属性#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property (nonatomic,copy) NSString *fullName;@property (nonatomic,copy) NSString *firstName;@property (nonatomic,copy) NSString *lastName;@end// 其中 fullName 取决于 firstName 和 lastName的值.// 同时如果 firstName 和 lastName发生改变的话,fullName也会受到影响。#import \"Person.h\"@implementation Person// 注册 fullName依赖于 firstName 和 lastName+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingFullName &#123; return [NSSet setWithObjects:@\"firstName\",@\"lastName\",nil];&#125;- (NSString *)fullName &#123; NSString *tempName = _fullName; if (_firstName || _lastName) &#123; tempName = [NSString stringWithFormat:@\"%@-%@\",_firstName,_lastName]; &#125; return tempName;&#125; 回到Controller： 1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; Person *p = [Person new]; self.p = p; [self.p addObserver:self forKeyPath:NSStringFromSelector(@selector(name)) options:NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:ContextMark]; self.p.fullName = @\"lilei\"; NSLog(@\"fullName = %@\",self.p.fullName); self.p.firstName = @\"lala\"; NSLog(@\"fullName = %@\",self.p.fullName); self.p.lastName = @\"papa\"; NSLog(@\"fullName = %@\",self.p.fullName);&#125;// 打印结果如下fullName = lileifullName = lala-(null)fullName = lala-papa 6.KVO使用中的”坑” 最近我在看这方面资料的时候，发现大家都以 tableView和ContentOffset作为例子。咱们就用这个最常见的控件来说明一下吧。 1.keyPath为字符串众所周知，KVO里面的KeyPath是NSString类型，结合Obj-C动态语言的特性，在编译时是不做检查的，只有运行到执行的时候，才会动态的去方法列表、实例变量列表中去查找，所以一旦我们写错了KeyPath，不运行的时候很难发现。 基于这个问题，我们用以下的方法规避 12// 这样就不会写错了NSStringFromSelector(@selector(contentSize)) 2.多层继承、共用同一个回调方法假如父类的控制器监听了tableView的ContentOffset属性，同时该控制器还监听了其他控件的一些属性，但是同一个对象或者控制器作为多个对象属性的观察者，实际上最后调用的都是同一个回调方法- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context { }，这样写极其容易混淆，所以我们为了解决这个问题，把代码写成如下的样子 12345678910- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if (object == _tableView &amp;&amp; [keyPath isEqualToString:@\"contentOffset\"]) &#123; [self doSomethingWhenContentOffsetChanges]; &#125; &#125; 但是光这样写是不全面的，因为当前的这个类很可能有父类，并且它的父类可能绑定了一些其他的KVO,上面的代码只有一个条件判断，一旦不成立，此次KVO的触发操作也就断了。而当前类无法捕捉的这个KVO事件很可能就在它的父类里，或者是父类的父类，上述操作，将这一链条截断，所以正确的方法应该如下： 1234567891011121314151617- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if (object == _tableView &amp;&amp; [keyPath isEqualToString:@\"contentOffset\"]) &#123; [self doSomethingWhenContentOffsetChanges]; &#125; else &#123; [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; &#125;&#125; 这样做这一链条就完整的保留了。 3.观察者的注销上面的方法做完之后还是有隐患的。我们知道KVO不用的时候是需要注销的。我们知道当你对同一个KVO注销两次的时候，系统默认是抛出异常的。 你可能会好奇，什么时候我会对同一个Observer注销多次呢？ 这个时候我们可以想一下我们注销Observer的时机，是不是多在Dealloc方法中？ 在Obj-C中，有很多系统的方法被重写时需要调用super xxxxxxx等方法，这是Obj-C的继承关系决定的。 例如： 1234567891011// 在重写init方法时，我们要调用一下父类的init方法- (instancetype)init &#123; [super init];&#125;// 布局子控件时，要调用一下父类的layoutSubviews方法- (void)layoutSubviews &#123; [super layoutSubviews];&#125; 还有些方法，不需要调用父类的方法，自动就会帮你调用，就如我们所说的Dealloc。其实只有在ARC模式下才不需要调用父类，MRC下的Dealloc还是要手动调用super dealloc的。 所以我们在注销观察者的时候就这么写 1234- (void)dealloc &#123; [_tableView removeObserver:self forKeyPath:@\"contentOffset\"];&#125; 假设我们有三个类 ClassA（父类），ClassB（子类），ClassC（孙子类）。这三个类都作为观察者，观察tableView的contentOffset属性。 如果我们在ClassC（孙子类）的Dealloc方法中释放观察者 1234- (void)dealloc &#123; [_tableView removeObserver:self forKeyPath:@\"contentOffset\"];&#125; 当ClassC（孙子类）的Dealloc执行完毕后，就会自动去ClassB（子类）的Dealloc方法中，释放观察者 1234- (void)dealloc &#123; [_tableView removeObserver:self forKeyPath:@\"contentOffset\"];&#125; 这个时候就出现崩溃了，因为我们在前面提到过这样会导致相同的removeObserver被执行两次，于是导致crash。 4.正确写法针对这种类型的Crash，我们就要谈一下在注册Observer似的一个关键的参数Context，之前我是不知道这个Context是做啥用的，对于KVO的使用只是流于表面，所以对于这个神秘的Context的作用一直没有深究，现在我们将使用Context来为每一个Observer做区分，避免多次调用相同的removeObserver。 KVO的三个关键方法 12345678910// 注册观察者- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;// 观察者响应方法- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context;// 移除观察者（有两个方法）- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context NS_AVAILABLE(10_7, 5_0);- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; 相比细心的同学已经看出来了，我们在注册、响应、移除的三个步骤里，都可以找到Context这个关键字。所以为了保持注册、响应、移除的一致性，正确的写法应该如下： 12345678910111213141516171819202122232425262728// 首先我们应在使用KVO的类中，创建一个独一无二的Context，用来和其他类进行区分static Void *ContextMark = &amp;ContextMark;// 接下来注册的时候用 [_tableView addObserver:self forKeyPath:NSStringFromSelector(@selector(contentSize)) options:(NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld) context:ContextMark]; // 响应的时候用- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; if (context == ContextMark) &#123; // do someThing &#125; else &#123; [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; &#125;&#125;// 注销的时候用- (void)dealloc &#123; [_tableView removeObserver:self forKeyPath:NSStringFromSelector(@selector(contentSize)) context:ContextMark];&#125; 如果还不放心，也可以使用@try @catch去捕获异常 7.总结 KVO这套 API 真麻烦~","content":"<h3 id=\"1-认识KVO\"><a href=\"#1-认识KVO\" class=\"headerlink\" title=\"1.认识KVO\"></a>1.认识KVO</h3><blockquote>\n<p><code>KVO</code>类似于观察者模式，我们利用简单的代码来了解什么是<code>KVO</code>。</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//  注册一个Person类</span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Person</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 再注册一个Dog类</span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Dog</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>  ) <span class=\"built_in\">NSString</span> *name;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>我们在<code>ViewController</code>中引入头文件，并创建两个全局的属性。我们希望<code>Person</code>作为<code>Dog</code>的观察者，当<code>Dog</code>的<code>name</code>属性发生变化的时候，<code>Person</code>可以第一时间知道。这时我们就可以运用<code>KVO</code>的技术。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"> Person *p = [Person new];</div><div class=\"line\"> <span class=\"keyword\">self</span>.p = p;</div><div class=\"line\"> Dog *dog = [Dog new];</div><div class=\"line\"> <span class=\"keyword\">self</span>.dog = dog;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 成为其他对象的观察者要进行注册</span></div><div class=\"line\"><span class=\"comment\">// KeyPath代表监听对象的具体属性</span></div><div class=\"line\"><span class=\"comment\">// Observe就是观察者喽</span></div><div class=\"line\"><span class=\"comment\">// Options可以指定管擦得值得新旧等</span></div><div class=\"line\"><span class=\"comment\">// Context可以是任何对象，可以向观察者传递信息，也可以用指定的标识对不同的观察者进行区分</span></div><div class=\"line\"> [dog addObserver:p</div><div class=\"line\">       forKeyPath:<span class=\"string\">@\"name\"</span></div><div class=\"line\">          options:(<span class=\"built_in\">NSKeyValueObservingOptionNew</span> | <span class=\"built_in\">NSKeyValueObservingOptionOld</span>)</div><div class=\"line\">          context:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\"> dog.name = <span class=\"string\">@\"旺财\"</span>;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>监听选项<code>Options</code>是由枚举<code>NSKeyValueObservingOptions</code>定义的，他决定了哪些值可以被传入到观察者内部实现的方法中。</p>\n<p>定义如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">enum</span> &#123;</div><div class=\"line\">\t   <span class=\"comment\">// 提供新值</span></div><div class=\"line\">   \t<span class=\"built_in\">NSKeyValueObservingOptionNew</span> = <span class=\"number\">0x01</span>,</div><div class=\"line\">   \t</div><div class=\"line\">   \t<span class=\"comment\">// 提供旧值</span></div><div class=\"line\">   \t<span class=\"built_in\">NSKeyValueObservingOptionOld</span> = <span class=\"number\">0x02</span>,</div><div class=\"line\">   \t</div><div class=\"line\">   \t<span class=\"comment\">// 添加观察者时立即发送一个通知给观察者，</span></div><div class=\"line\">   \t<span class=\"comment\">// 并且是在注册观察者方法返回之前</span></div><div class=\"line\">   \t<span class=\"built_in\">NSKeyValueObservingOptionInitial</span> = <span class=\"number\">0x04</span>,</div><div class=\"line\">   \t</div><div class=\"line\">   \t<span class=\"comment\">// 如果指定，则在每次修改属性时，会在修改通知被发送之前预先发送一条通知给观察者，</span></div><div class=\"line\">   \t<span class=\"comment\">// 这与-willChangeValueForKey:被触发的时间是相对应的。</span></div><div class=\"line\">   \t<span class=\"comment\">// 这样，在每次修改属性时，实际上是会发送两条通知。</span></div><div class=\"line\">   \t<span class=\"built_in\">NSKeyValueObservingOptionPrior</span> = <span class=\"number\">0x08</span> </div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NSUInteger</span> <span class=\"built_in\">NSKeyValueObservingOptions</span>;</div><div class=\"line\"><span class=\"comment\">//  选项值可以支持多个选项</span></div></pre></td></tr></table></figure>\n<p>注册之后，我们要在观察者内部实现如下方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 此时，当被观察者的属性发生变更，观察者就会自动调用如下方法</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSKeyValueChangeKey</span>,<span class=\"keyword\">id</span>&gt; *)change context:(<span class=\"keyword\">void</span> *)context &#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// keyPath被观察的属性值</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"keyPath = %@\"</span>,keyPath);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// object被观察的对象</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"object = %@\"</span>,object);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 被观察属性值得变化，后面还会讲</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"change = %@\"</span>,change);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 上下文，也可以是任意的额外数据</span></div><div class=\"line\">    <span class=\"comment\">// 这个Context的作用十分重要，我在后面会强调</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"context = %@\"</span>,context);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 我们通过这个方法，可以得到一些关键信息</span></div></pre></td></tr></table></figure>\n<p><code>Change</code>选项，它记录了被监听属性的变化情况。可以通过key来获取值：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 属性变化的类型，是一个NSNumber对象，包含NSKeyValueChange枚举相关的值</span></div><div class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">NSKeyValueChangeKindKey</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 属性的新值。当NSKeyValueChangeKindKey是 NSKeyValueChangeSetting，</span></div><div class=\"line\"><span class=\"comment\">// 且添加观察的方法设置了NSKeyValueObservingOptionNew时，我们能获取到属性的新值。</span></div><div class=\"line\"><span class=\"comment\">// 如果NSKeyValueChangeKindKey是NSKeyValueChangeInsertion或者NSKeyValueChangeReplacement，</span></div><div class=\"line\"><span class=\"comment\">// 且指定了NSKeyValueObservingOptionNew时，则我们能获取到一个NSArray对象，包含被插入的对象或</span></div><div class=\"line\"><span class=\"comment\">// 用于替换其它对象的对象。</span></div><div class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">NSKeyValueChangeNewKey</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 属性的旧值。当NSKeyValueChangeKindKey是 NSKeyValueChangeSetting，</span></div><div class=\"line\"><span class=\"comment\">// 且添加观察的方法设置了NSKeyValueObservingOptionOld时，我们能获取到属性的旧值。</span></div><div class=\"line\"><span class=\"comment\">// 如果NSKeyValueChangeKindKey是NSKeyValueChangeRemoval或者NSKeyValueChangeReplacement，</span></div><div class=\"line\"><span class=\"comment\">// 且指定了NSKeyValueObservingOptionOld时，则我们能获取到一个NSArray对象，包含被移除的对象或</span></div><div class=\"line\"><span class=\"comment\">// 被替换的对象。</span></div><div class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">NSKeyValueChangeOldKey</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 如果NSKeyValueChangeKindKey的值是NSKeyValueChangeInsertion、NSKeyValueChangeRemoval</span></div><div class=\"line\"><span class=\"comment\">// 或者NSKeyValueChangeReplacement，则这个key对应的值是一个NSIndexSet对象，</span></div><div class=\"line\"><span class=\"comment\">// 包含了被插入、移除或替换的对象的索引</span></div><div class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">NSKeyValueChangeIndexesKey</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 当指定了NSKeyValueObservingOptionPrior选项时，在属性被修改的通知发送前，</span></div><div class=\"line\"><span class=\"comment\">// 会先发送一条通知给观察者。我们可以使用NSKeyValueChangeNotificationIsPriorKey</span></div><div class=\"line\"><span class=\"comment\">// 来获取到通知是否是预先发送的，如果是，获取到的值总是@(YES)</span></div><div class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">NSKeyValueChangeNotificationIsPriorKey</span>;</div></pre></td></tr></table></figure>\n<p><code>NSKeyValueChangeKindKey</code>的值取自于<code>NSKeyValueChange</code>，这是一个枚举值，定义如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">enum</span> &#123;</div><div class=\"line\">\t<span class=\"comment\">// 设置一个新值。被监听的属性可以是一个对象，也可以是一对一关系的属性或一对多关系的属性。</span></div><div class=\"line\">   \t<span class=\"built_in\">NSKeyValueChangeSetting</span> = <span class=\"number\">1</span>,</div><div class=\"line\">   \t</div><div class=\"line\">   \t<span class=\"comment\">// 表示一个对象被插入到一对多关系的属性。</span></div><div class=\"line\">   \t<span class=\"built_in\">NSKeyValueChangeInsertion</span> = <span class=\"number\">2</span>,</div><div class=\"line\">   \t</div><div class=\"line\">   \t<span class=\"comment\">// 表示一个对象被从一对多关系的属性中移除。</span></div><div class=\"line\">   \t<span class=\"built_in\">NSKeyValueChangeRemoval</span> = <span class=\"number\">3</span>,</div><div class=\"line\">   \t</div><div class=\"line\">   \t<span class=\"comment\">// 表示一个对象在一对多的关系的属性中被替换</span></div><div class=\"line\">   \t<span class=\"built_in\">NSKeyValueChangeReplacement</span> = <span class=\"number\">4</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NSUInteger</span> <span class=\"built_in\">NSKeyValueChange</span>;</div></pre></td></tr></table></figure>\n<p>注意，观察者在不需要使用的时候一定要移除，否则会产生崩溃</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span>.dog removeObserver:<span class=\"keyword\">self</span>.p forKeyPath:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过上面简要的代码示例，我们可以得知，时运观察者只需要实现简单的几步。</p>\n<ol>\n<li>注册观察者</li>\n<li>观察者实现相应的方法</li>\n<li>移除观察者</li>\n</ol>\n<h3 id=\"2-KVC和KVO的实现原理\"><a href=\"#2-KVC和KVO的实现原理\" class=\"headerlink\" title=\"2.KVC和KVO的实现原理\"></a>2.KVC和KVO的实现原理</h3><p><code>KVC</code>和<code>KVO</code>是基于强大的<code>Runtime</code>来实现的。其中使用到的技术就是<code>isa-swilling</code>,<code>isa-swilling</code>这项技术也是一个重点，我们会在后续的<code>Runtime</code>部分会讲到。如果有看到此处不明白的同学也请保持耐心。</p>\n<p>网上有一篇文章针对实现原理写的很好，<a href=\"http://blog.csdn.net/kesalin/article/details/8194240\" target=\"_blank\" rel=\"external\">链接在此</a>。</p>\n<p>整体来说就是，当某个类的对象第一次被观察时，系统会在运行期间动态的为这个类创建一个派生类，假如被监听类名为<code>ClassA</code>，那么派生类的名称就为<code>NSKVONotifying_ClassA</code>。</p>\n<p>1.原有对象的<code>isa</code>指针会指向全新的派生类，派生类为了混淆，避免别人知道他不是原来的类，所以派生类重写了<code>Class</code>的类方法。</p>\n<p>2.同时重写了<code>Dealloc</code>方法，用于资源的销毁处理。</p>\n<p>3.还重写了<code>_isKVOA</code>,这个是一个标记，用于标示这个类是遵守<code>KVO</code>机制的。</p>\n<p>4.最关键的是重写了被监听属性的<code>Setter</code>方法，这是实现<code>KVO</code>的关键。至于为什么，后面会讲解到。</p>\n<p>简单的画了张图，可能会有助于理解。<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/Interview-QA-Senior/2.png\" alt=\"\"></p>\n<p>我们上面讲重写了被观察对象属性的<code>Setter</code>方法是十分关键的，这就要说起另外两个十分重要的方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在属性值即将被修改的时候，会调用这个方法</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)willChangeValueForKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 在属性值已经被修改的时候，会调用这个方法</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)didChangeValueForKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// didChangeValueForKey:方法会显式的调用</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath </div><div class=\"line\">                      ofObject:(<span class=\"keyword\">id</span>)object </div><div class=\"line\">                        change:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSKeyValueChangeKey</span>,<span class=\"keyword\">id</span>&gt; *)change </div><div class=\"line\">                       context:(<span class=\"keyword\">void</span> *)context &#123;</div><div class=\"line\">                       &#125;</div></pre></td></tr></table></figure>\n<p>其实我个人猜测，重写<code>Setter</code>方法内部应该这样实现的</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span> willChangeValueForKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">[<span class=\"keyword\">super</span> setName:name];</div><div class=\"line\">[<span class=\"keyword\">self</span> didChangeValueForKey:<span class=\"string\">@\"name\"</span>];</div></pre></td></tr></table></figure>\n<p>说到这里，相信你应该完整的明白KVO的实现机制了。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 这才是KVO机制触发的关键</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)didChangeValueForKey:(<span class=\"built_in\">NSString</span> *)key;</div></pre></td></tr></table></figure>\n<h3 id=\"3-调用KVO的三种方法\"><a href=\"#3-调用KVO的三种方法\" class=\"headerlink\" title=\"3.调用KVO的三种方法\"></a>3.调用KVO的三种方法</h3><p>综合上面KVO的实现原理，我们可以得出如下结论：</p>\n<h5 id=\"1-使用了KVC\"><a href=\"#1-使用了KVC\" class=\"headerlink\" title=\"1.使用了KVC\"></a>1.使用了KVC</h5><p>使用了<code>KVC</code>，如果有<code>访问器方法</code>，则运行时会在访问器方法中调用<code>will/didChangeValueForKey:</code>方法；<br>没用访问器方法，运行时会在<code>setValue:forKey</code>方法中调用<code>will/didChangeValueForKey:</code>方法。</p>\n<h5 id=\"2-有访问器方法\"><a href=\"#2-有访问器方法\" class=\"headerlink\" title=\"2.有访问器方法\"></a>2.有访问器方法</h5><p>运行时会重写访问器方法调用<code>will/didChangeValueForKey:</code>方法。<br>因此，直接调用访问器方法改变属性值时，KVO也能监听到。</p>\n<h5 id=\"3-直接调用\"><a href=\"#3-直接调用\" class=\"headerlink\" title=\"3.直接调用\"></a>3.直接调用</h5><p>显式调用<code>will/didChangeValueForKey:</code>方法。</p>\n<h3 id=\"4-KVO自动通知、手动通知\"><a href=\"#4-KVO自动通知、手动通知\" class=\"headerlink\" title=\"4.KVO自动通知、手动通知\"></a>4.KVO自动通知、手动通知</h3><p>通常意义下我们使用的都是自动通知，注册观察者之后，当触发<code>will/didChangeValueForKey:</code>方法后，观察者对象的<code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change  context:(void *)context { }</code>方法会被调用。</p>\n<p>如果像实现手动通知，我们需要借助一个额外的方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"built_in\">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class=\"built_in\">NSString</span> *)key</div></pre></td></tr></table></figure>\n<p>这个方法默认返回<code>YES</code>,用来标记<code>Key</code>指定的属性是否支持<code>KVO</code>，如果返回值为<code>NO</code>，则需要我们手动更新。</p>\n<p>我们还是用我们最上面的例子，监听<code>Person</code>的<code>name</code>属性，不过这次我们采取手动通知的方式。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Person.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Person</span></span></div><div class=\"line\"></div><div class=\"line\">+ (<span class=\"built_in\">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class=\"built_in\">NSString</span> *)key &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">BOOL</span> automaic = <span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([key isEqualToString:<span class=\"string\">@\"name\"</span>])</div><div class=\"line\">    &#123;</div><div class=\"line\">        automaic = <span class=\"literal\">NO</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// 此处需要注意，没有被处理的其他属性要调用父类的原有方法</span></div><div class=\"line\">        automaic = [<span class=\"keyword\">super</span> automaticallyNotifiesObserversForKey:key];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> automaic;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这样我们就已经标记好当<code>Person</code>的<code>name</code>属性发生改变时，手动发送通知，代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Person</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span>(name != _name)<span class=\"comment\">// 加一处判断，如果值相同，就无需发送通知了</span></div><div class=\"line\">    &#123;   </div><div class=\"line\">        <span class=\"comment\">// 我们需要在值修改前调用`will...`方法</span></div><div class=\"line\">        [<span class=\"keyword\">self</span> willChangeValueForKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">        _name = name;</div><div class=\"line\">        <span class=\"comment\">// 我们还需要在修改后调用`did...`方法，显式调用观察者的方法</span></div><div class=\"line\">        [<span class=\"keyword\">self</span> didChangeValueForKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>手动发送通知一对一的操作方法如上，如果是一对多的案例，则可以使用如下方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)willChange:(<span class=\"built_in\">NSKeyValueChange</span>)change valuesAtIndexes:(<span class=\"built_in\">NSIndexSet</span> *)indexes forKey:(<span class=\"built_in\">NSString</span> *)key</div><div class=\"line\">- (<span class=\"keyword\">void</span>)didChange:(<span class=\"built_in\">NSKeyValueChange</span>)change valuesAtIndexes:(<span class=\"built_in\">NSIndexSet</span> *)indexes forKey:(<span class=\"built_in\">NSString</span> *)key</div><div class=\"line\">  </div><div class=\"line\">- (<span class=\"keyword\">void</span>)willChangeValueForKey:(<span class=\"built_in\">NSString</span> *)key withSetMutation:(<span class=\"built_in\">NSKeyValueSetMutationKind</span>)mutationKind usingObjects:(<span class=\"built_in\">NSSet</span> *)objects</div><div class=\"line\">- (<span class=\"keyword\">void</span>)didChangeValueForKey:(<span class=\"built_in\">NSString</span> *)key withSetMutation:(<span class=\"built_in\">NSKeyValueSetMutationKind</span>)mutationKind usingObjects:(<span class=\"built_in\">NSSet</span> *)objects</div></pre></td></tr></table></figure>\n<h3 id=\"5-注册依赖键\"><a href=\"#5-注册依赖键\" class=\"headerlink\" title=\"5.注册依赖键\"></a>5.注册依赖键</h3><p>实际开发过程中可能会遇到这种场景，某个变量的值取决于其他的值。</p>\n<p>我们还是看一个例子吧：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 声明一个Person类，有三个属性</span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Person</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *fullName;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *firstName;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *lastName;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 其中 fullName 取决于 firstName 和 lastName的值.</span></div><div class=\"line\"><span class=\"comment\">// 同时如果 firstName 和 lastName发生改变的话,fullName也会受到影响。</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Person.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Person</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 注册 fullName依赖于 firstName 和 lastName</span></div><div class=\"line\">+ (<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keyPathsForValuesAffectingFullName &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSSet</span> setWithObjects:<span class=\"string\">@\"firstName\"</span>,<span class=\"string\">@\"lastName\"</span>,<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)fullName &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSString</span> *tempName = _fullName;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (_firstName || _lastName)</div><div class=\"line\">    &#123;</div><div class=\"line\">        tempName = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@-%@\"</span>,_firstName,_lastName];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> tempName;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>回到Controller：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    </div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    Person *p = [Person new];</div><div class=\"line\">    <span class=\"keyword\">self</span>.p = p;</div><div class=\"line\">    </div><div class=\"line\">    [<span class=\"keyword\">self</span>.p  addObserver:<span class=\"keyword\">self</span></div><div class=\"line\">        forKeyPath:<span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(name))</div><div class=\"line\">           options:<span class=\"built_in\">NSKeyValueObservingOptionOld</span> | <span class=\"built_in\">NSKeyValueObservingOptionNew</span></div><div class=\"line\">           context:ContextMark];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">self</span>.p.fullName = <span class=\"string\">@\"lilei\"</span>;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"fullName = %@\"</span>,<span class=\"keyword\">self</span>.p.fullName);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">self</span>.p.firstName = <span class=\"string\">@\"lala\"</span>;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"fullName = %@\"</span>,<span class=\"keyword\">self</span>.p.fullName);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">self</span>.p.lastName = <span class=\"string\">@\"papa\"</span>;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"fullName = %@\"</span>,<span class=\"keyword\">self</span>.p.fullName);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 打印结果如下</span></div><div class=\"line\">fullName = lilei</div><div class=\"line\">fullName = lala-(null)</div><div class=\"line\">fullName = lala-papa</div></pre></td></tr></table></figure>\n<h3 id=\"6-KVO使用中的”坑”\"><a href=\"#6-KVO使用中的”坑”\" class=\"headerlink\" title=\"6.KVO使用中的”坑”\"></a>6.KVO使用中的”坑”</h3><blockquote>\n<p>最近我在看这方面资料的时候，发现大家都以 <code>tableView</code>和<code>ContentOffset</code>作为例子。咱们就用这个最常见的控件来说明一下吧。</p>\n</blockquote>\n<h5 id=\"1-keyPath为字符串\"><a href=\"#1-keyPath为字符串\" class=\"headerlink\" title=\"1.keyPath为字符串\"></a>1.keyPath为字符串</h5><p>众所周知，KVO里面的<code>KeyPath</code>是<code>NSString</code>类型，结合<code>Obj-C</code>动态语言的特性，在编译时是不做检查的，只有运行到执行的时候，才会动态的去<code>方法列表</code>、<code>实例变量列表</code>中去查找，所以一旦我们写错了<code>KeyPath</code>，不运行的时候很难发现。</p>\n<p>基于这个问题，我们用以下的方法规避</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 这样就不会写错了</span></div><div class=\"line\"><span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(contentSize))</div></pre></td></tr></table></figure>\n<h5 id=\"2-多层继承、共用同一个回调方法\"><a href=\"#2-多层继承、共用同一个回调方法\" class=\"headerlink\" title=\"2.多层继承、共用同一个回调方法\"></a>2.多层继承、共用同一个回调方法</h5><p>假如父类的控制器监听了<code>tableView</code>的<code>ContentOffset</code>属性，同时该控制器还监听了其他控件的一些属性，但是同一个对象或者控制器作为多个对象属性的观察者，实际上最后调用的都是同一个回调方法<code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change  context:(void *)context { }</code>，这样写极其容易混淆，所以我们为了解决这个问题，把代码写成如下的样子</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath </div><div class=\"line\">                      ofObject:(<span class=\"keyword\">id</span>)object</div><div class=\"line\">                        change:(<span class=\"built_in\">NSDictionary</span> *)change </div><div class=\"line\">                       context:(<span class=\"keyword\">void</span> *)context</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (object == _tableView &amp;&amp; [keyPath isEqualToString:<span class=\"string\">@\"contentOffset\"</span>]) </div><div class=\"line\">    &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> doSomethingWhenContentOffsetChanges];</div><div class=\"line\"> 　　&#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是光这样写是不全面的，因为当前的这个类很可能有父类，并且它的父类可能绑定了一些其他的KVO,上面的代码只有一个条件判断，一旦不成立，此次KVO的触发操作也就断了。而当前类无法捕捉的这个KVO事件很可能就在它的父类里，或者是父类的父类，上述操作，将这一链条截断，所以正确的方法应该如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath </div><div class=\"line\">                      ofObject:(<span class=\"keyword\">id</span>)object</div><div class=\"line\">                        change:(<span class=\"built_in\">NSDictionary</span> *)change </div><div class=\"line\">                       context:(<span class=\"keyword\">void</span> *)context</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (object == _tableView &amp;&amp; [keyPath isEqualToString:<span class=\"string\">@\"contentOffset\"</span>]) </div><div class=\"line\">    &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> doSomethingWhenContentOffsetChanges];</div><div class=\"line\"> 　　&#125; </div><div class=\"line\"> 　　<span class=\"keyword\">else</span></div><div class=\"line\"> 　　&#123;</div><div class=\"line\"> 　　    [<span class=\"keyword\">super</span> observeValueForKeyPath:keyPath </div><div class=\"line\"> 　　                         ofObject:object </div><div class=\"line\"> 　　                           change:change </div><div class=\"line\"> 　　                          context:context];</div><div class=\"line\"> 　　&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样做这一链条就完整的保留了。</p>\n<h5 id=\"3-观察者的注销\"><a href=\"#3-观察者的注销\" class=\"headerlink\" title=\"3.观察者的注销\"></a>3.观察者的注销</h5><p>上面的方法做完之后还是有隐患的。我们知道KVO不用的时候是需要注销的。我们知道当你对同一个KVO注销两次的时候，系统默认是抛出异常的。</p>\n<p>你可能会好奇，什么时候我会对同一个<code>Observer</code>注销多次呢？</p>\n<p>这个时候我们可以想一下我们注销<code>Observer</code>的时机，是不是多在<code>Dealloc</code>方法中？</p>\n<p>在<code>Obj-C</code>中，有很多系统的方法被重写时需要调用<code>super xxxxxxx</code>等方法，这是<code>Obj-C</code>的继承关系决定的。</p>\n<p>例如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在重写init方法时，我们要调用一下父类的init方法</span></div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)init &#123;</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">super</span> init];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 布局子控件时，要调用一下父类的layoutSubviews方法</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)layoutSubviews &#123;</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">super</span> layoutSubviews];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还有些方法，不需要调用父类的方法，自动就会帮你调用，就如我们所说的<code>Dealloc</code>。其实只有在<code>ARC</code>模式下才不需要调用父类，<code>MRC</code>下的<code>Dealloc</code>还是要手动调用<code>super dealloc</code>的。</p>\n<p>所以我们在注销观察者的时候就这么写</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</div><div class=\"line\"></div><div class=\"line\">    [_tableView removeObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"contentOffset\"</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假设我们有三个类 <code>ClassA（父类）</code>，<code>ClassB（子类）</code>，<code>ClassC（孙子类）</code>。这三个类都作为观察者，观察<code>tableView</code>的<code>contentOffset</code>属性。</p>\n<p>如果我们在<code>ClassC（孙子类）</code>的<code>Dealloc</code>方法中释放观察者</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</div><div class=\"line\"></div><div class=\"line\">    [_tableView removeObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"contentOffset\"</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当<code>ClassC（孙子类）</code>的<code>Dealloc</code>执行完毕后，就会自动去<code>ClassB（子类）</code>的<code>Dealloc</code>方法中，释放观察者</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</div><div class=\"line\"></div><div class=\"line\">    [_tableView removeObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"contentOffset\"</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个时候就出现崩溃了，因为我们在前面提到过这样会导致相同的removeObserver被执行两次，于是导致crash。</p>\n<h5 id=\"4-正确写法\"><a href=\"#4-正确写法\" class=\"headerlink\" title=\"4.正确写法\"></a>4.正确写法</h5><p>针对这种类型的Crash，我们就要谈一下在注册<code>Observer</code>似的一个关键的参数<code>Context</code>，之前我是不知道这个<code>Context</code>是做啥用的，对于<code>KVO</code>的使用只是流于表面，所以对于这个神秘的<code>Context</code>的作用一直没有深究，现在我们将使用<code>Context</code>来为每一个<code>Observer</code>做区分，避免多次调用相同的<code>removeObserver</code>。</p>\n<p>KVO的三个关键方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//  注册观察者</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)addObserver:(<span class=\"built_in\">NSObject</span> *)observer forKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath options:(<span class=\"built_in\">NSKeyValueObservingOptions</span>)options context:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> *)context;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 观察者响应方法</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)object change:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSKeyValueChangeKey</span>, <span class=\"keyword\">id</span>&gt; *)change context:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> *)context;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 移除观察者（有两个方法）</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObserver:(<span class=\"built_in\">NSObject</span> *)observer forKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath context:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> *)context <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_7, <span class=\"number\">5</span>_0);</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObserver:(<span class=\"built_in\">NSObject</span> *)observer forKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath;</div></pre></td></tr></table></figure>\n<p>相比细心的同学已经看出来了，我们在<strong>注册</strong>、<strong>响应</strong>、<strong>移除</strong>的三个步骤里，都可以找到<code>Context</code>这个关键字。所以为了保持<strong>注册</strong>、<strong>响应</strong>、<strong>移除</strong>的一致性，正确的写法应该如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 首先我们应在使用KVO的类中，创建一个独一无二的Context，用来和其他类进行区分</span></div><div class=\"line\"><span class=\"keyword\">static</span> Void *ContextMark = &amp;ContextMark;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 接下来注册的时候用</span></div><div class=\"line\"> [_tableView addObserver:<span class=\"keyword\">self</span></div><div class=\"line\">              forKeyPath:<span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(contentSize))</div><div class=\"line\">                 options:(<span class=\"built_in\">NSKeyValueObservingOptionNew</span> | <span class=\"built_in\">NSKeyValueObservingOptionOld</span>)</div><div class=\"line\">                 context:ContextMark];</div><div class=\"line\">                 </div><div class=\"line\"><span class=\"comment\">// 响应的时候用</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSKeyValueChangeKey</span>,<span class=\"keyword\">id</span>&gt; *)change context:(<span class=\"keyword\">void</span> *)context &#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (context == ContextMark)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// do someThing</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">    &#123;</div><div class=\"line\">        [<span class=\"keyword\">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 注销的时候用</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</div><div class=\"line\">    [_tableView removeObserver:<span class=\"keyword\">self</span> </div><div class=\"line\">                    forKeyPath:<span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(contentSize)) </div><div class=\"line\">                       context:ContextMark];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果还不放心，也可以使用<code>@try @catch</code>去捕获异常</p>\n<h3 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7.总结\"></a>7.总结</h3><p><img src=\"http://imgsrc.baidu.com/forum/w=580/sign=bdaac71373094b36db921be593cd7c00/5635b9096b63f624e76700cf8244ebf81b4ca3ea.jpg\" alt=\"\"></p>\n<p><code>KVO</code>这套 API 真麻烦<del>~</del>  </p>\n","excerpt":"1.认识KVO KVO类似于观察者模式，我们利用简单的代码来了解什么是KVO。 12345678910111213// 注册一个Person类#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property (nonatomic,copy) NSString *name;@end// 再注册一个Dog类#import &lt;Foundation/Foundation.h&gt;@interface Dog : NSObject@property (nonatomic,copy ) NSString *name;@end 我们在ViewController中引入头文件，并创建两个全局的属性。我们希望Person作为Dog的观察者，当Dog的name属性发生变化的时候，Person可以第一时间知道。这时我们就可以运用KVO的技术。 12345678910111213141516 Person *p = [Person new]; self.p = p; Dog *dog = [Dog new]; self.dog = dog;// 成为其他对象的观察者要进行注册// KeyPath代表监听对象的具体属性// Observe就是观察者喽// Options可以指定管擦得值得新旧等// Context可以是任何对象，可以向观察者传递信息，也可以用指定的标识对不同的观察者进行区分 [dog addObserver:p forKeyPath:@\"name\" options:(NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld) context:nil]; dog.name = @\"旺财\";","categories":[],"tags":[{"name":"知识总结","slug":"知识总结","permalink":"http://yoursite.com/tags/知识总结/"}]},{"title":"KVC知识小结","date":"2017-06-17T02:15:31.000Z","path":"2017/06/17/KVC知识小结/","text":"关于KVC和KVO,我之前的总结文章有写过，但是实际上我在平日工作里，KVC和KVO使用的相对较少，不是KVC和KVO的功能不够强大，这实际上和项目的架构有比较大的关系，以前的我对于KVC和KVO的使用也是趋于表面，没有探究其内部真正的实现原理和进阶用法，这次总结正好给了我很好的学习机会，在此深入的总结一下KVC和KVO吧。 KVC，即是指 NSKeyValueCoding，一个非正式的 Protocol，提供一种机制来间接访问对象的属性。KVO 就是基于 KVC 实现的关键技术之一。 KVC在iOS中的定义Objective-C中KVC的定义是对NSObject的扩展来实现的。所以对于所有继承了NSObject在类型，都可以使用KVC，下面是KVC最为重要的四个方法 1234- (nullable id)valueForKey:(NSString *)key; //直接通过Key来取值- (void)setValue:(nullable id)value forKey:(NSString *)key; //通过Key来设值- (nullable id)valueForKeyPath:(NSString *)keyPath; //通过KeyPath来取值- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; //通过KeyPath来设值 一般来讲，Obj-C 对象中都会有一些属性。如代码所示 12345678910#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject/** name */@property (nonatomic,copy ) NSString *name;/** Address */@property (nonatomic,copy ) NSString *address;@end 上面的Person对象所拥有的两个属性，以 KVC的角度来看，就是Person对象的name,address这两个属性分别有一个Value对应他们的Key值。 Key 是一个字符串类型。 Value 可以为任何类型。 KVC 为存取值提供了两个最基础的方法。 123456789Person *man = [Person new];// 存值[man setValue:@\"LiMing\" forKey:@\"name\"];// 取值NSString *name = [man valueForKey:@\"name\"];NSLog(@\"%@\",name); KVC 为了便于使用还提供了另外两个方法。 假设我们之前创建的这个对象有一个配偶，配偶也是一个Person对象,此时我们想在man这里读出woman的name属性 可以这样操作 1234567891011Person *woman = [Person new];man.spouse = woman;[man setValue:@\"Lily\" forKeyPath:@\"spouse.name\"];NSLog(@\"%@\",[man valueForKeyPath:@\"spouse.name\"]);// Key 与 KeyPath 要区分开来// Key 可以让你从一个对象中获取值// KeyPath 可以让你通过连续的多个Key获取值，着多个key值用点号 “.” 分割连接起来 简单对比一下 1234// 结果一样的，但是用 KeyPath 更简单[man valueForKeyPath:@\"spouse.name\"][[man valueForKey:@\"spouse\"] valueForKey:@\"name\"]; KVC寻找Key值过程KVC在某种程度上提供了访问器的替代方案，不过只要有可能，KVC也是在访问器方法的帮助下工作。KVC按照以下顺序寻找Key值。 1.赋值当程序调用 1- (void)setValue:(nullable id)value forKey:(NSString *)key; 1.优先寻找访问器方法程序会优先调用setKey的属性值方法，代码直接通过Setter方法完成设置。这里的key值指的是成员变量名，Key值首字母大写要符合Setter和Getter方法的命名规则。 2.寻找_key如果没有找到setKey的访问器方法，KVC机制会检查 1+ (BOOL)accessInstanceVariablesDirectly 的返回值是否为NO，此方法默认返回的是YES。如果开发者重写了该方法让这个返回值为NO时，接下来KVC会直接调用 1- (void)setValue:(id)value forUndefinedKey:(NSString *)key 这个时候如果你不做其他操作，就要报出异常了，所以一般人都不会这么做。 接下来KVC机制会搜索该类里面有没有_key的成员变量，无论你是在声明文件中定义，还是在实现文件中定义，也无论使用了什么样的属性修饰符，只要存在着_key命名的变量，KVC都可以对该成员变量赋值。 3.寻找_isKey如果该类即没有setKey：的访问器方法，也没有_key成员变量，KVC机制会搜索_isKey的成员变量。 4.寻找Key和isKey和上面一样，如果该类即没有setKey：的访问器方法，也没有_key和_isKey成员变量，KVC机制再会继续搜索key和isKey的成员变量。再给它们赋值。 如果上面列出的方法或者成员变量都不存在，系统将会执行该对象的setValue：forUNdefinedKey：方法，默认是抛出异常。 如果开发者想让这个类禁用KVC里，那么重写+ (BOOL)accessInstanceVariablesDirectly方法让其返回NO即可，这样的话如果KVC没有找到set&lt;Key&gt;:属性名时，会直接用setValue：forUNdefinedKey：方法。 2.取值当程序调用 1- (nullable id)valueForKey:(NSString *)key; 1.优先查找访问器的方法首先按getKey、key、isKey的顺序查找getter方法，找到直接调用。如果是bool、int等内建值类型，会做NSNumber的转换。 2.有序集合中查找上面的getter没有找到，查找countOfKey、objectInKeyAtIndex:、KeyAtIndexes格式的方法。如果countOfKey和另外两个方法中的一个找到，那么就会返回一个可以响应NSArray所有方法的代理集合。发送给这个代理集合的NSArray消息方法，就会以countOfKey、objectInKeyAtIndex:、KeyAtIndexes这几个方法组合的形式调用。还有一个可选的 getKey:range: 方法。 3.无序集合中查找还没查到，那么查找countOfKey、enumeratorOfKey、memberOfKey:格式的方法。如果这三个方法都找到，那么就返回一个可以响应NSSet所有方法的代理集合。发送给这个代理集合的NSSet消息方法，就会以countOfKey、enumeratorOfKey、memberOfKey:组合的形式调用。 4.搜索成员变量名还是没查到，那么如果类方法accessInstanceVariablesDirectly返回YES，那么按_key，_isKey，key，iskey的顺序直接搜索成员名。 5.报出异常再找不到，调用ValueForUndefinedKey:，默认报出异常 针对集合的KVC我们上面讲的KVC是一对一关系,比如Person类中的name属性。但也有一对多的关系，比如Person中有一个friendsName属性，保存的是一个人的所有朋友的名字，这时候就需要集合来处理了。 对于集合类的处理，我们有两种选择 1.通过KVC将集合类先取出，然后在针对集合进行处理2.采用KVC提供的模板方法有序集合这里面的Key，就是被监听的属性名称 12345678910111213141516171819202122-countOfKey //必须实现，对应于NSArray的基本方法count: - objectInKeyAtIndex:- keyAtIndexes: //这两个必须实现一个，对应于 NSArray 的方法 objectAtIndex: 和 objectsAtIndexes: - getKey:range: //不是必须实现的，但实现后可以提高性能，其对应于 NSArray 方法 - getObjects:range: - insertObject:inKeyAtIndex: - insertKey:atIndexes: //两个必须实现一个，类似于 NSMutableArray 的方法 insertObject:atIndex: 和 insertObjects:atIndexes: - removeObjectFromKeyAtIndex: - removeKeyAtIndexes: //两个必须实现一个，类似于 NSMutableArray 的方法 removeObjectAtIndex: 和 removeObjectsAtIndexes: - replaceObjectInKeyAtIndex:withObject: - replaceKeyAtIndexes:withKey: //可选的，如果在此类操作上有性能问题，就需要考虑实现之 无序集合12345678910111213141516171819202122- countOfKey //必须实现，对应于NSArray的基本方法count: - objectInKeyAtIndex: - keyAtIndexes: //这两个必须实现一个，对应于 NSArray 的方法 objectAtIndex: 和 objectsAtIndexes:- getKey:range: //不是必须实现的，但实现后可以提高性能，其对应于 NSArray 方法 - getObjects:range: - insertObject:inKeyAtIndex: - insertKey:atIndexes://两个必须实现一个，类似于 NSMutableArray 的方法 insertObject:atIndex: 和 insertObjects:atIndexes: - removeObjectFromKeyAtIndex: - removeKeyAtIndexes: //两个必须实现一个，类似于 NSMutableArray 的方法 removeObjectAtIndex: 和 removeObjectsAtIndexes:- replaceObjectInKeyAtIndex:withObject: - replaceKeyAtIndexes:withKey: //这两个都是可选的，如果在此类操作上有性能问题，就需要考虑实现之 KVC对基本数据类型和结构体的支持1.对基本数据类型会以 NSNumber 进行包装123456789101112131415+ (NSNumber *)numberWithChar:(char)value; + (NSNumber *)numberWithUnsignedChar:(unsigned char)value; + (NSNumber *)numberWithShort:(short)value; + (NSNumber *)numberWithUnsignedShort:(unsigned short)value; + (NSNumber *)numberWithInt:(int)value; + (NSNumber *)numberWithUnsignedInt:(unsigned int)value; + (NSNumber *)numberWithLong:(long)value; + (NSNumber *)numberWithUnsignedLong:(unsigned long)value; + (NSNumber *)numberWithLongLong:(long long)value; + (NSNumber *)numberWithUnsignedLongLong:(unsigned long long)value; + (NSNumber *)numberWithFloat:(float)value; + (NSNumber *)numberWithDouble:(double)value; + (NSNumber *)numberWithBool:(BOOL)value; + (NSNumber *)numberWithInteger:(NSInteger)value NS_AVAILABLE(10_5, 2_0); + (NSNumber *)numberWithUnsignedInteger:(NSUInteger)value NS_AVAILABLE(10_5, 2_0); 2.对结构体会以 NSValue 进行包装123456+ (NSValue *)valueWithCGPoint:(CGPoint)point; + (NSValue *)valueWithCGSize:(CGSize)size; + (NSValue *)valueWithCGRect:(CGRect)rect; + (NSValue *)valueWithCGAffineTransform:(CGAffineTransform)transform; + (NSValue *)valueWithUIEdgeInsets:(UIEdgeInsets)insets; + (NSValue *)valueWithUIOffset:(UIOffset)insets NS_AVAILABLE_IOS(5_0); 所有的结构体都支持以NSValue进行封装 KVC中的集合运算符 集合运算符是一个特殊的KeyPath，可以作为参数传递给valueForKeyPath：方法 1.简单的集合运算符简单的集合运算符有以下几个 @avg，@count，@max，@min，@sum5 2.对象运算符对象运算符有@distinctUnionOfObjects,@unionOfObjects,这两个运算符返回的对象都是NSArray。 1.@distinctUnionOfObjects会将集合在剔除重复对象之后返回 2.@unionOfObjects会直接返回所有对象 NSKeyValueCoding其他方法1234567891011121314151617181920+ (BOOL)accessInstanceVariablesDirectly;//默认返回YES，表示如果没有找到SetKey方法的话，会按照_key，_iskey，key，iskey的顺序搜索成员，设置成NO就会直接抛出异常。- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;//KVC提供属性值确认的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;//这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回- (nullable id)valueForUndefinedKey:(NSString *)key;//如果Key不存在，且没有KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;//和上一个方法一样，只不过是设值。- (void)setNilValueForKey:(NSString *)key;//如果你在SetValue方法时面给Value传nil，则会调用这个方法- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;//输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。 没想到光一个KVC就写了这么多的内容，而越深入写就越觉得自己写的不过是皮毛，接下来再说说KVO吧。","content":"<p>关于<code>KVC</code>和<code>KVO</code>,我之前的总结文章有写过，但是实际上我在平日工作里，<code>KVC</code>和<code>KVO</code>使用的相对较少，不是<code>KVC</code>和<code>KVO</code>的功能不够强大，这实际上和项目的架构有比较大的关系，以前的我对于<code>KVC</code>和<code>KVO</code>的使用也是趋于表面，没有探究其内部真正的实现原理和进阶用法，这次总结正好给了我很好的学习机会，在此深入的总结一下<code>KVC</code>和<code>KVO</code>吧。</p>\n<blockquote>\n<p><strong>KVC</strong>，即是指 <strong>NSKeyValueCoding</strong>，一个非正式的 <strong>Protocol</strong>，提供一种机制来间接访问对象的属性。<strong>KVO</strong> 就是基于 <strong>KVC</strong> 实现的关键技术之一。</p>\n</blockquote>\n<h3 id=\"KVC在iOS中的定义\"><a href=\"#KVC在iOS中的定义\" class=\"headerlink\" title=\"KVC在iOS中的定义\"></a>KVC在iOS中的定义</h3><p><code>Objective-C</code>中<code>KVC</code>的定义是对<code>NSObject</code>的扩展来实现的。所以对于所有继承了<code>NSObject</code>在类型，都可以使用<code>KVC</code>，下面是<code>KVC</code>最为重要的四个方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)valueForKey:(<span class=\"built_in\">NSString</span> *)key;                          <span class=\"comment\">//直接通过Key来取值</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forKey:(<span class=\"built_in\">NSString</span> *)key;          <span class=\"comment\">//通过Key来设值</span></div><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)valueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath;                  <span class=\"comment\">//通过KeyPath来取值</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath;  <span class=\"comment\">//通过KeyPath来设值</span></div></pre></td></tr></table></figure>\n<p>一般来讲，<strong>Obj-C</strong> 对象中都会有一些属性。如代码所示</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Person</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/** name */</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>  ) <span class=\"built_in\">NSString</span> *name;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/** Address */</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>  ) <span class=\"built_in\">NSString</span> *address;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>上面的<code>Person</code>对象所拥有的两个属性，以 <strong>KVC</strong>的角度来看，就是<code>Person</code>对象的<code>name</code>,<code>address</code>这两个属性分别有一个<code>Value</code>对应他们的<code>Key</code>值。</p>\n<ul>\n<li>Key 是一个字符串类型。</li>\n<li>Value 可以为任何类型。</li>\n</ul>\n<p>KVC 为存取值提供了两个最基础的方法。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person *man = [Person new];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 存值</span></div><div class=\"line\">[man setValue:<span class=\"string\">@\"LiMing\"</span> forKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 取值</span></div><div class=\"line\"><span class=\"built_in\">NSString</span> *name = [man valueForKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,name);</div></pre></td></tr></table></figure>\n<p>KVC 为了便于使用还提供了另外两个方法。</p>\n<p>假设我们之前创建的这个对象有一个配偶，配偶也是一个Person对象,此时我们想在<code>man</code>这里读出<code>woman</code>的<code>name</code>属性</p>\n<p>可以这样操作</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person *woman = [Person new];</div><div class=\"line\"></div><div class=\"line\">man.spouse = woman;</div><div class=\"line\"></div><div class=\"line\">[man setValue:<span class=\"string\">@\"Lily\"</span> forKeyPath:<span class=\"string\">@\"spouse.name\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,[man valueForKeyPath:<span class=\"string\">@\"spouse.name\"</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//  Key 与 KeyPath 要区分开来</span></div><div class=\"line\"><span class=\"comment\">//  Key 可以让你从一个对象中获取值</span></div><div class=\"line\"><span class=\"comment\">//  KeyPath  可以让你通过连续的多个Key获取值，着多个key值用点号 “.” 分割连接起来</span></div></pre></td></tr></table></figure>\n<p>简单对比一下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//  结果一样的，但是用 KeyPath 更简单</span></div><div class=\"line\">[man valueForKeyPath:<span class=\"string\">@\"spouse.name\"</span>]</div><div class=\"line\"></div><div class=\"line\">[[man valueForKey:<span class=\"string\">@\"spouse\"</span>] valueForKey:<span class=\"string\">@\"name\"</span>];</div></pre></td></tr></table></figure>\n<h3 id=\"KVC寻找Key值过程\"><a href=\"#KVC寻找Key值过程\" class=\"headerlink\" title=\"KVC寻找Key值过程\"></a>KVC寻找Key值过程</h3><p>KVC在某种程度上提供了访问器的替代方案，不过只要有可能，KVC也是在访问器方法的帮助下工作。KVC按照以下顺序寻找Key值。</p>\n<h4 id=\"1-赋值\"><a href=\"#1-赋值\" class=\"headerlink\" title=\"1.赋值\"></a>1.赋值</h4><p>当程序调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forKey:(<span class=\"built_in\">NSString</span> *)key;</div></pre></td></tr></table></figure>\n<h5 id=\"1-优先寻找访问器方法\"><a href=\"#1-优先寻找访问器方法\" class=\"headerlink\" title=\"1.优先寻找访问器方法\"></a>1.优先寻找访问器方法</h5><p>程序会优先调用<code>setKey</code>的属性值方法，代码直接通过<code>Setter</code>方法完成设置。这里的<code>key</code>值指的是成员变量名，<code>Key</code>值首字母大写要符合<code>Setter</code>和<code>Getter</code>方法的命名规则。</p>\n<h5 id=\"2-寻找-key\"><a href=\"#2-寻找-key\" class=\"headerlink\" title=\"2.寻找_key\"></a>2.寻找_key</h5><p>如果没有找到<code>setKey</code>的访问器方法，<code>KVC</code>机制会检查</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"built_in\">BOOL</span>)accessInstanceVariablesDirectly</div></pre></td></tr></table></figure>\n<p>的返回值是否为<code>NO</code>，此方法默认返回的是<code>YES</code>。如果开发者重写了该方法让这个返回值为<code>NO</code>时，接下来<code>KVC</code>会直接调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">id</span>)value forUndefinedKey:(<span class=\"built_in\">NSString</span> *)key</div></pre></td></tr></table></figure>\n<p>这个时候如果你不做其他操作，就要报出异常了，所以一般人都不会这么做。</p>\n<p>接下来<code>KVC</code>机制会搜索该类里面有没有<code>_key</code>的成员变量，无论你是在声明文件中定义，还是在实现文件中定义，也无论使用了什么样的属性修饰符，只要存在着<code>_key</code>命名的变量，<code>KVC</code>都可以对该成员变量赋值。</p>\n<h5 id=\"3-寻找-isKey\"><a href=\"#3-寻找-isKey\" class=\"headerlink\" title=\"3.寻找_isKey\"></a>3.寻找_isKey</h5><p>如果该类即没有<code>setKey：</code>的访问器方法，也没有<code>_key</code>成员变量，<code>KVC</code>机制会搜索<code>_isKey</code>的成员变量。</p>\n<h5 id=\"4-寻找Key和isKey\"><a href=\"#4-寻找Key和isKey\" class=\"headerlink\" title=\"4.寻找Key和isKey\"></a>4.寻找Key和isKey</h5><p>和上面一样，如果该类即没有<code>setKey：</code>的访问器方法，也没有<code>_key</code>和<code>_isKey</code>成员变量，<code>KVC</code>机制再会继续搜索<code>key</code>和<code>isKey</code>的成员变量。再给它们赋值。</p>\n<p>如果上面列出的方法或者成员变量都不存在，系统将会执行该对象的<code>setValue：forUNdefinedKey：</code>方法，默认是抛出异常。</p>\n<p>如果开发者想让这个类禁用<code>KVC</code>里，那么重写<code>+ (BOOL)accessInstanceVariablesDirectly</code>方法让其返回NO即可，这样的话如果<code>KVC</code>没有找到<code>set&lt;Key&gt;:</code>属性名时，会直接用<code>setValue：forUNdefinedKey：</code>方法。</p>\n<h4 id=\"2-取值\"><a href=\"#2-取值\" class=\"headerlink\" title=\"2.取值\"></a>2.取值</h4><p>当程序调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)valueForKey:(<span class=\"built_in\">NSString</span> *)key;</div></pre></td></tr></table></figure>\n<h5 id=\"1-优先查找访问器的方法\"><a href=\"#1-优先查找访问器的方法\" class=\"headerlink\" title=\"1.优先查找访问器的方法\"></a>1.优先查找访问器的方法</h5><p>首先按<code>getKey</code>、<code>key</code>、<code>isKey</code>的顺序查找<code>getter</code>方法，找到直接调用。如果是<code>bool</code>、<code>int</code>等内建值类型，会做<code>NSNumber</code>的转换。</p>\n<h5 id=\"2-有序集合中查找\"><a href=\"#2-有序集合中查找\" class=\"headerlink\" title=\"2.有序集合中查找\"></a>2.有序集合中查找</h5><p>上面的<code>getter</code>没有找到，查找<code>countOfKey</code>、<code>objectInKeyAtIndex:</code>、<code>KeyAtIndexes</code>格式的方法。<br>如果<code>countOfKey</code>和另外两个方法中的一个找到，那么就会返回一个可以响应<code>NSArray</code>所有方法的代理集合。发送给这个代理集合的<code>NSArray</code>消息方法，就会以<code>countOfKey</code>、<code>objectInKeyAtIndex:</code>、<code>KeyAtIndexes</code>这几个方法组合的形式调用。还有一个可选的 <code>getKey:range:</code> 方法。</p>\n<h5 id=\"3-无序集合中查找\"><a href=\"#3-无序集合中查找\" class=\"headerlink\" title=\"3.无序集合中查找\"></a>3.无序集合中查找</h5><p>还没查到，那么查找<code>countOfKey</code>、<code>enumeratorOfKey</code>、<code>memberOfKey:</code>格式的方法。<br>如果这三个方法都找到，那么就返回一个可以响应NSSet所有方法的代理集合。发送给这个代理集合的<code>NSSet</code>消息方法，就会以<code>countOfKey</code>、<code>enumeratorOfKey</code>、<code>memberOfKey:</code>组合的形式调用。</p>\n<h5 id=\"4-搜索成员变量名\"><a href=\"#4-搜索成员变量名\" class=\"headerlink\" title=\"4.搜索成员变量名\"></a>4.搜索成员变量名</h5><p>还是没查到，那么如果类方法<code>accessInstanceVariablesDirectly</code>返回<code>YES</code>，那么按<code>_key</code>，<code>_isKey</code>，<code>key</code>，<code>iskey</code>的顺序直接搜索成员名。</p>\n<h5 id=\"5-报出异常\"><a href=\"#5-报出异常\" class=\"headerlink\" title=\"5.报出异常\"></a>5.报出异常</h5><p>再找不到，调用<code>ValueForUndefinedKey:</code>，默认报出异常</p>\n<h3 id=\"针对集合的KVC\"><a href=\"#针对集合的KVC\" class=\"headerlink\" title=\"针对集合的KVC\"></a>针对集合的KVC</h3><p>我们上面讲的<code>KVC</code>是一对一关系,比如<code>Person</code>类中的<code>name</code>属性。但也有一对多的关系，比如<code>Person</code>中有一个<code>friendsName</code>属性，保存的是一个人的所有朋友的名字，这时候就需要集合来处理了。</p>\n<p>对于集合类的处理，我们有两种选择</p>\n<h4 id=\"1-通过KVC将集合类先取出，然后在针对集合进行处理\"><a href=\"#1-通过KVC将集合类先取出，然后在针对集合进行处理\" class=\"headerlink\" title=\"1.通过KVC将集合类先取出，然后在针对集合进行处理\"></a>1.通过KVC将集合类先取出，然后在针对集合进行处理</h4><h4 id=\"2-采用KVC提供的模板方法\"><a href=\"#2-采用KVC提供的模板方法\" class=\"headerlink\" title=\"2.采用KVC提供的模板方法\"></a>2.采用KVC提供的模板方法</h4><h5 id=\"有序集合\"><a href=\"#有序集合\" class=\"headerlink\" title=\"有序集合\"></a>有序集合</h5><p>这里面的<strong>Key</strong>，就是被监听的属性名称</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">-countOfKey  </div><div class=\"line\"><span class=\"comment\">//必须实现，对应于NSArray的基本方法count:  </span></div><div class=\"line\"></div><div class=\"line\">- objectInKeyAtIndex:</div><div class=\"line\">- keyAtIndexes:  </div><div class=\"line\"><span class=\"comment\">//这两个必须实现一个，对应于 NSArray 的方法 objectAtIndex: 和 objectsAtIndexes: </span></div><div class=\"line\"> </div><div class=\"line\">- getKey:range:  </div><div class=\"line\"><span class=\"comment\">//不是必须实现的，但实现后可以提高性能，其对应于 NSArray 方法 </span></div><div class=\"line\">- getObjects:range:  </div><div class=\"line\">  </div><div class=\"line\">- insertObject:inKeyAtIndex:  </div><div class=\"line\">- insertKey:atIndexes:  </div><div class=\"line\"><span class=\"comment\">//两个必须实现一个，类似于 NSMutableArray 的方法 insertObject:atIndex: 和 insertObjects:atIndexes:  </span></div><div class=\"line\"></div><div class=\"line\">- removeObjectFromKeyAtIndex:  </div><div class=\"line\">- removeKeyAtIndexes:  </div><div class=\"line\"><span class=\"comment\">//两个必须实现一个，类似于 NSMutableArray 的方法 removeObjectAtIndex: 和 removeObjectsAtIndexes:  </span></div><div class=\"line\"></div><div class=\"line\">- replaceObjectInKeyAtIndex:withObject:  </div><div class=\"line\">- replaceKeyAtIndexes:withKey:  </div><div class=\"line\"><span class=\"comment\">//可选的，如果在此类操作上有性能问题，就需要考虑实现之</span></div></pre></td></tr></table></figure>\n<h5 id=\"无序集合\"><a href=\"#无序集合\" class=\"headerlink\" title=\"无序集合\"></a>无序集合</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">- countOfKey </div><div class=\"line\"><span class=\"comment\">//必须实现，对应于NSArray的基本方法count: </span></div><div class=\"line\"> </div><div class=\"line\">- objectInKeyAtIndex:  </div><div class=\"line\">- keyAtIndexes:  </div><div class=\"line\"><span class=\"comment\">//这两个必须实现一个，对应于 NSArray 的方法 objectAtIndex: 和 objectsAtIndexes:</span></div><div class=\"line\"></div><div class=\"line\">- getKey:range:  </div><div class=\"line\"><span class=\"comment\">//不是必须实现的，但实现后可以提高性能，其对应于 NSArray 方法 </span></div><div class=\"line\">- getObjects:range:  </div><div class=\"line\">  </div><div class=\"line\">- insertObject:inKeyAtIndex:  </div><div class=\"line\">- insertKey:atIndexes:</div><div class=\"line\"><span class=\"comment\">//两个必须实现一个，类似于 NSMutableArray 的方法 insertObject:atIndex: 和 insertObjects:atIndexes:  </span></div><div class=\"line\"></div><div class=\"line\">- removeObjectFromKeyAtIndex:  </div><div class=\"line\">- removeKeyAtIndexes:  </div><div class=\"line\"><span class=\"comment\">//两个必须实现一个，类似于 NSMutableArray 的方法 removeObjectAtIndex: 和 removeObjectsAtIndexes:</span></div><div class=\"line\"></div><div class=\"line\">- replaceObjectInKeyAtIndex:withObject:  </div><div class=\"line\">- replaceKeyAtIndexes:withKey:  </div><div class=\"line\"><span class=\"comment\">//这两个都是可选的，如果在此类操作上有性能问题，就需要考虑实现之</span></div></pre></td></tr></table></figure>\n<h3 id=\"KVC对基本数据类型和结构体的支持\"><a href=\"#KVC对基本数据类型和结构体的支持\" class=\"headerlink\" title=\"KVC对基本数据类型和结构体的支持\"></a>KVC对基本数据类型和结构体的支持</h3><h5 id=\"1-对基本数据类型会以-NSNumber-进行包装\"><a href=\"#1-对基本数据类型会以-NSNumber-进行包装\" class=\"headerlink\" title=\"1.对基本数据类型会以 NSNumber 进行包装\"></a>1.对基本数据类型会以 NSNumber 进行包装</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"built_in\">NSNumber</span> *)numberWithChar:(<span class=\"keyword\">char</span>)value;  </div><div class=\"line\">+ (<span class=\"built_in\">NSNumber</span> *)numberWithUnsignedChar:(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>)value;  </div><div class=\"line\">+ (<span class=\"built_in\">NSNumber</span> *)numberWithShort:(<span class=\"keyword\">short</span>)value;  </div><div class=\"line\">+ (<span class=\"built_in\">NSNumber</span> *)numberWithUnsignedShort:(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span>)value;  </div><div class=\"line\">+ (<span class=\"built_in\">NSNumber</span> *)numberWithInt:(<span class=\"keyword\">int</span>)value;  </div><div class=\"line\">+ (<span class=\"built_in\">NSNumber</span> *)numberWithUnsignedInt:(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)value;  </div><div class=\"line\">+ (<span class=\"built_in\">NSNumber</span> *)numberWithLong:(<span class=\"keyword\">long</span>)value;  </div><div class=\"line\">+ (<span class=\"built_in\">NSNumber</span> *)numberWithUnsignedLong:(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)value;  </div><div class=\"line\">+ (<span class=\"built_in\">NSNumber</span> *)numberWithLongLong:(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)value;  </div><div class=\"line\">+ (<span class=\"built_in\">NSNumber</span> *)numberWithUnsignedLongLong:(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)value;  </div><div class=\"line\">+ (<span class=\"built_in\">NSNumber</span> *)numberWithFloat:(<span class=\"keyword\">float</span>)value;  </div><div class=\"line\">+ (<span class=\"built_in\">NSNumber</span> *)numberWithDouble:(<span class=\"keyword\">double</span>)value;  </div><div class=\"line\">+ (<span class=\"built_in\">NSNumber</span> *)numberWithBool:(<span class=\"built_in\">BOOL</span>)value;  </div><div class=\"line\">+ (<span class=\"built_in\">NSNumber</span> *)numberWithInteger:(<span class=\"built_in\">NSInteger</span>)value <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_5, <span class=\"number\">2</span>_0);  </div><div class=\"line\">+ (<span class=\"built_in\">NSNumber</span> *)numberWithUnsignedInteger:(<span class=\"built_in\">NSUInteger</span>)value <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_5, <span class=\"number\">2</span>_0);</div></pre></td></tr></table></figure>\n<h5 id=\"2-对结构体会以-NSValue-进行包装\"><a href=\"#2-对结构体会以-NSValue-进行包装\" class=\"headerlink\" title=\"2.对结构体会以 NSValue 进行包装\"></a>2.对结构体会以 NSValue 进行包装</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"built_in\">NSValue</span> *)valueWithCGPoint:(<span class=\"built_in\">CGPoint</span>)point;  </div><div class=\"line\">+ (<span class=\"built_in\">NSValue</span> *)valueWithCGSize:(<span class=\"built_in\">CGSize</span>)size;  </div><div class=\"line\">+ (<span class=\"built_in\">NSValue</span> *)valueWithCGRect:(<span class=\"built_in\">CGRect</span>)rect;  </div><div class=\"line\">+ (<span class=\"built_in\">NSValue</span> *)valueWithCGAffineTransform:(<span class=\"built_in\">CGAffineTransform</span>)transform;  </div><div class=\"line\">+ (<span class=\"built_in\">NSValue</span> *)valueWithUIEdgeInsets:(<span class=\"built_in\">UIEdgeInsets</span>)insets;  </div><div class=\"line\">+ (<span class=\"built_in\">NSValue</span> *)valueWithUIOffset:(<span class=\"built_in\">UIOffset</span>)insets <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">5</span>_0);</div></pre></td></tr></table></figure>\n<p>所有的结构体都支持以<code>NSValue</code>进行封装</p>\n<h3 id=\"KVC中的集合运算符\"><a href=\"#KVC中的集合运算符\" class=\"headerlink\" title=\"KVC中的集合运算符\"></a>KVC中的集合运算符</h3><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/Interview-QA-Senior/1.png\" alt=\"\"></p>\n<p>集合运算符是一个特殊的<code>KeyPath</code>，可以作为参数传递给<code>valueForKeyPath：</code>方法</p>\n<h5 id=\"1-简单的集合运算符\"><a href=\"#1-简单的集合运算符\" class=\"headerlink\" title=\"1.简单的集合运算符\"></a>1.简单的集合运算符</h5><p>简单的集合运算符有以下几个 <code>@avg</code>，<code>@count</code>，<code>@max</code>，<code>@min</code>，<code>@sum5</code></p>\n<h5 id=\"2-对象运算符\"><a href=\"#2-对象运算符\" class=\"headerlink\" title=\"2.对象运算符\"></a>2.对象运算符</h5><p>对象运算符有<code>@distinctUnionOfObjects</code>,<br><code>@unionOfObjects</code>,这两个运算符返回的对象都是<code>NSArray</code>。</p>\n<p>1.<code>@distinctUnionOfObjects</code>会将集合在剔除重复对象之后返回</p>\n<p>2.<code>@unionOfObjects</code>会直接返回所有对象</p>\n<h3 id=\"NSKeyValueCoding其他方法\"><a href=\"#NSKeyValueCoding其他方法\" class=\"headerlink\" title=\"NSKeyValueCoding其他方法\"></a>NSKeyValueCoding其他方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"built_in\">BOOL</span>)accessInstanceVariablesDirectly;</div><div class=\"line\"><span class=\"comment\">//默认返回YES，表示如果没有找到SetKey方法的话，会按照_key，_iskey，key，iskey的顺序搜索成员，设置成NO就会直接抛出异常。</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)validateValue:(<span class=\"keyword\">inout</span> <span class=\"keyword\">id</span> __<span class=\"keyword\">nullable</span> * __<span class=\"keyword\">nonnull</span>)ioValue forKey:(<span class=\"built_in\">NSString</span> *)inKey error:(<span class=\"keyword\">out</span> <span class=\"built_in\">NSError</span> **)outError;</div><div class=\"line\"><span class=\"comment\">//KVC提供属性值确认的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">NSMutableArray</span> *)mutableArrayValueForKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\"><span class=\"comment\">//这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)valueForUndefinedKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\"><span class=\"comment\">//如果Key不存在，且没有KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forUndefinedKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\"><span class=\"comment\">//和上一个方法一样，只不过是设值。</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setNilValueForKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\"><span class=\"comment\">//如果你在SetValue方法时面给Value传nil，则会调用这个方法</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *, <span class=\"keyword\">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keys;</div><div class=\"line\"><span class=\"comment\">//输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。</span></div></pre></td></tr></table></figure>\n<p>没想到光一个<code>KVC</code>就写了这么多的内容，而越深入写就越觉得自己写的不过是皮毛，接下来再说说<code>KVO</code>吧。</p>\n","excerpt":"关于KVC和KVO,我之前的总结文章有写过，但是实际上我在平日工作里，KVC和KVO使用的相对较少，不是KVC和KVO的功能不够强大，这实际上和项目的架构有比较大的关系，以前的我对于KVC和KVO的使用也是趋于表面，没有探究其内部真正的实现原理和进阶用法，这次总结正好给了我很好的学习机会，在此深入的总结一下KVC和KVO吧。 KVC，即是指 NSKeyValueCoding，一个非正式的 Protocol，提供一种机制来间接访问对象的属性。KVO 就是基于 KVC 实现的关键技术之一。 KVC在iOS中的定义Objective-C中KVC的定义是对NSObject的扩展来实现的。所以对于所有继承了NSObject在类型，都可以使用KVC，下面是KVC最为重要的四个方法 1234- (nullable id)valueForKey:(NSString *)key; //直接通过Key来取值- (void)setValue:(nullable id)value forKey:(NSString *)key; //通过Key来设值- (nullable id)valueForKeyPath:(NSString *)keyPath; //通过KeyPath来取值- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; //通过KeyPath来设值 一般来讲，Obj-C 对象中都会有一些属性。如代码所示 12345678910#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject/** name */@property (nonatomic,copy ) NSString *name;/** Address */@property (nonatomic,copy ) NSString *address;@end","categories":[],"tags":[{"name":"知识总结","slug":"知识总结","permalink":"http://yoursite.com/tags/知识总结/"}]},{"title":"UIStackView教程","date":"2017-06-16T01:41:42.000Z","path":"2017/06/16/UIStackView教程/","text":"这是一篇挺老的文章，主要就是介绍在iOS9时推出的控件UIStackView。我发现网上的资料并不算多，而AppCoda的这一篇就浅显易懂，所以决定翻译一下，再写个Demo。 UIStackView 简介开始这个教程的话，我们会讲一些iOS9的新特性，iOS最近推出的新版本带来了很多新的特性，而新推出的UIStackView应该引起开发者第一时间的关注。据我所知，一些开发者认为使用AutoLayout去设计一些复杂的用户界面是十分困难的。UIStackView就是帮助开发者将这些复杂页面的设计工作变得更简单。 UIStackView为布局一组控件提供了线性的布局页面，这组控件可以垂直显示，也可以水平显示。当View被加入到UIStackView,你不再需要为它设置约束。UIStackView会自动管理子控件的布局并为他们添加约束。这也就意味着，子控件可以去适应不同的屏幕尺寸。 再进一步讲，你可以将一个UIStackView放进另一个UIStackView中以实现更为复杂的用户界面的设计工作。当然千万不要被我误导，UIStackView并不意味着你再也不必和约束打交道，你至少是要为UIStackView设置约束的。UIStackView只是节省了你为每一个界面元素添加约束的时间，同时你在UIStackView中添加和删除约束将变得超级简单。 Xcode 7提供了两种方式去使用UIStackView。你可以在对象库拖一个UIStackView然后放进StoryBoard中，UIStackView有水平和垂直两种，然后你可以拖拽一些视图控件，例如Label,Button,image等直接放入UIStackView。或者，你也可以利用在自动布局工具栏中Stack选项。利用这种方法，你可以选择两个或者多个视图控件，直接点击Stack。Interface Builder会将这些试图对象加入到UIStackView并且重新指定他们的大小。说到此处如果你还没有明白UIStackView，那也不要担心。在这个教程中，我们会展示这两种方法。只需要继续阅读，然后在一瞬间，你会 怦 的一下就懂了。 The Demo App首先我们要预览一下我们即将构建的App，在这个教程中，我们会展示在Interface中利用UIStackView如何构建这个App。 当然你不用UIStackView也可以构建一个这样的页面，但是正如你所见，UIStackView完全改变了你进行页面布局的方式。这个教程无需任何代码，我们将专注于利用Interface Builder来构建这个用户界面。 添加 UIStackView打开 Xcode 7 ，然后打开main.storyBoard。从右侧的对象库面板中，往storyBoard中拖一个垂直方向的UIStackView。UIStackView可以分别管理水平方向和垂直方向的子控件。因为我们想要布局的ImageViews是垂直方向的，所以我们选择一个垂直方向的UIStackView。 接下来从控件库往外拖一个Imageview，当你把Imageview拖拽到StackView里，Imageview会自动调整尺寸，重复上面的步骤，我们再往StackView里面添加两个imageView,这时候神奇的一幕发生了，当你把另外两个imageView添加到StackView里面时，StackView会自动给这两个imageView进行垂直布局，并为他们添加上了约束条件。是不是很酷？ 为 UIStackView 添加约束StackView为开发者节省了为每一个界面元素添加约束的时间，但是你必须要为你的StackView添加约束条件，接下来我们将为刚才添加到是图中的StackView添加约束 设置StackView与父控件顶部、左侧、右侧的距离 设置StackView的高度占父控件高度的70% 现在，我们选中StackView并点击Pin按钮。设置距离顶部、左侧、右侧的距离各自分别为10，0，0。并且把这三个约束加上。 现在StackView的位置，并不满足我们的约束条件，你需要点击警告去修复这个问题。 想设置高度的约束，到文档大纲视图。按住Control键，从StackView拖线到View上面，松开后，选择Equal Height. 这样设置以后，StackView的高度就与使徒的View相等。然而我们只需要让StackView的高度是视图的View的70%。所以选择StackView的Height属性，然后到属性面板，把Mutiplier的值从1.0变成0.7。 设置StackView属性值StackView看起来并没有像预期一样，一旦你使用了StackView，你可以通过修改StackView的属性值来改变它的外观。 Axis是坐标轴，负责水平还是垂直。alignment是对齐方式。 Distribution决定了StackView中子控件的尺寸和位置。它默认被设置为Fill。在这个例子里，StackView要尽可能的利用有限的空间去适配它的子控件。接下来我们将选项改为Fill Equally。StackView会自动将里面的子控件重新布局为大小相等的控件。 Space选项允许你通过修改该选项，调解两个控件之间的距离，此处将值改为10。 设置图片接下来为三个ImageView设置图片 现在可以把程序跑起来看看效果，在不同的模拟器，UI都可以很好的适配各种设备。StackView已经自动帮你添加好了布局。实际上你可以通过页面调试选项，来查看为ImageView添加的布局。 用嵌套的方式布局控件还有一些Lable和Button需要添加到页面上，如图所示，拖两个Lable到StackView的正下方，上面的标签字号为30. 然后选中两个Lable，点击stack选项，将这两个控件合并为一个StackView。 接下来添加两个按钮，一个Like,一个Share。把这两个控件合并为一个StackView，设置间距为 5，方向水平。 把按钮的StackView拖进Label的StackView中，选中顶部的Nature标签和Buttonde StackView,点击stack选项,将他们两个合并为一个StackView，设置方向为水平 选中这个StackView，将对齐方式调整为First BaseLine,沿第一个对象的基线对齐，然后给Lable和Button加一个20的间距。 这样，我们只需要利用 StackView 的嵌套，就可以实现我们想得到的布局。 最后，我们实现了用StackView包裹ImageView,同时也实现了StackView包裹Label和Button。将顶部、左侧、右侧各自设置值为 8，0，0。 为了确保Label的描述文字可以正好适配，将Label的行数改为0，文字的Line break设置为文字包裹。这样你就完成了界面的设计。 现在可以把程序跑起来看一下效果 如果横屏，效果是这样的： 看起来还可以，但是如果横屏时图片是水平排列那就更好了： 利用*Size Class 构建自适应的 StackView为了实现 iPhone 在横屏时显示不同的布局，我们需要让StackView是自适应。在 iOS8，介绍过 Size Class 的概念，下面的表格介绍了不同的 iOS 设备以及他们相对应的 Size Class。 你可以利用 Size Class 提供一个指定的布局去覆写之前的布局设计。在这个例子中，我们需要将StackView的方向在以下两种情况下，由垂直变为水平。 宽度紧凑 - 高度紧凑 宽度宽松 - 高度紧凑 接下来选择我们的StackView,然后打开属性面板，点击Axis边上的+号。 选择 任意宽度 , 高度紧凑，并把StackView的方向设置为水平方向。 然后。。。。。。就妥了！ 总结在这个教程中，对StackView进行了简单介绍，为大家做了一个Demo，以及如何使用这个全新的组件。StackView这种流线型的布局方式，让你在布局时只需要使用很少的约束。 Apple的工程师也是推荐优先使用StackView，实在不行在用原生的约束。 我自己做了一个简单的Demo，地址如下 ： https://github.com/liberalisman/StackView-Demo","content":"<p>这是一篇挺老的文章，主要就是介绍在<code>iOS9</code>时推出的控件<code>UIStackView</code>。我发现网上的资料并不算多，而<code>AppCoda</code>的这一篇就浅显易懂，所以决定翻译一下，再写个<code>Demo</code>。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/1.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"UIStackView-简介\"><a href=\"#UIStackView-简介\" class=\"headerlink\" title=\"UIStackView 简介\"></a>UIStackView 简介</h3><p>开始这个教程的话，我们会讲一些<code>iOS9</code>的新特性，<code>iOS</code>最近推出的新版本带来了很多新的特性，而新推出的<code>UIStackView</code>应该引起开发者第一时间的关注。据我所知，一些开发者认为使用<code>AutoLayout</code>去设计一些复杂的用户界面是十分困难的。<code>UIStackView</code>就是帮助开发者将这些复杂页面的设计工作变得更简单。</p>\n<p><code>UIStackView</code>为布局一组控件提供了线性的布局页面，这组控件可以<strong>垂直显示</strong>，也可以<strong>水平显示</strong>。当<code>View</code>被加入到<code>UIStackView</code>,你不再需要为它设置约束。<code>UIStackView</code>会自动管理子控件的布局并为他们添加约束。这也就意味着，子控件可以去适应不同的屏幕尺寸。</p>\n<p>再进一步讲，你可以将一个<code>UIStackView</code>放进另一个<code>UIStackView</code>中以实现更为复杂的用户界面的设计工作。当然千万不要被我误导，<code>UIStackView</code>并不意味着你再也不必和约束打交道，你至少是要为<code>UIStackView</code>设置约束的。<code>UIStackView</code>只是节省了你为每一个界面元素添加约束的时间，同时你在<code>UIStackView</code>中添加和删除约束将变得超级简单。</p>\n<p><code>Xcode 7</code>提供了两种方式去使用<code>UIStackView</code>。你可以在<code>对象库</code>拖一个<code>UIStackView</code>然后放进<code>StoryBoard</code>中，<code>UIStackView</code>有<strong>水平</strong>和<strong>垂直</strong>两种，然后你可以拖拽一些<strong>视图控件</strong>，例如<code>Label</code>,<code>Button</code>,<code>image</code>等直接放入<code>UIStackView</code>。或者，你也可以利用在自动布局工具栏中<code>Stack</code>选项。利用这种方法，你可以选择两个或者多个视图控件，直接点击<code>Stack</code>。<code>Interface Builder</code>会将这些试图对象加入到<code>UIStackView</code>并且重新指定他们的大小。说到此处如果你还没有明白<code>UIStackView</code>，那也不要担心。在这个教程中，我们会展示这两种方法。只需要继续阅读，然后在一瞬间，你会  <strong>怦</strong>  的一下就懂了。</p>\n<h3 id=\"The-Demo-App\"><a href=\"#The-Demo-App\" class=\"headerlink\" title=\"The Demo App\"></a>The Demo App</h3><p>首先我们要预览一下我们即将构建的App，在这个教程中，我们会展示在<code>Interface</code>中利用<code>UIStackView</code>如何构建这个<strong>App</strong>。<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/2.png\" alt=\"\"></p>\n<p>当然你不用<code>UIStackView</code>也可以构建一个这样的页面，但是正如你所见，<code>UIStackView</code>完全改变了你进行页面布局的方式。这个教程无需任何代码，我们将专注于利用<code>Interface Builder</code>来构建这个用户界面。</p>\n<h3 id=\"添加-UIStackView\"><a href=\"#添加-UIStackView\" class=\"headerlink\" title=\"添加 UIStackView\"></a>添加 UIStackView</h3><p>打开 <code>Xcode 7</code> ，然后打开<code>main.storyBoard</code>。从右侧的对象库面板中，往<code>storyBoard</code>中拖一个垂直方向的<code>UIStackView</code>。<code>UIStackView</code>可以分别管理<strong>水平方向</strong>和<strong>垂直方向</strong>的子控件。因为我们想要布局的<code>ImageViews</code>是垂直方向的，所以我们选择一个垂直方向的<code>UIStackView</code>。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/3.png\" alt=\"\"></p>\n<p>接下来从控件库往外拖一个<code>Imageview</code>，当你把<code>Imageview</code>拖拽到<code>StackView</code>里，<code>Imageview</code>会自动调整尺寸，重复上面的步骤，我们再往<code>StackView</code>里面添加两个<code>imageView</code>,这时候神奇的一幕发生了，当你把另外两个<code>imageView</code>添加到<code>StackView</code>里面时，<code>StackView</code>会自动给这两个<code>imageView</code>进行垂直布局，并为他们添加上了约束条件。是不是很酷？</p>\n<h3 id=\"为-UIStackView-添加约束\"><a href=\"#为-UIStackView-添加约束\" class=\"headerlink\" title=\"为 UIStackView 添加约束\"></a>为 UIStackView 添加约束</h3><p><code>StackView</code>为开发者节省了为每一个界面元素添加约束的时间，但是你必须要为你的<code>StackView</code>添加约束条件，接下来我们将为刚才添加到是图中的<code>StackView</code>添加约束</p>\n<ul>\n<li>设置<code>StackView</code>与父控件顶部、左侧、右侧的距离</li>\n<li>设置<code>StackView</code>的高度占父控件高度的70%</li>\n</ul>\n<p>现在，我们选中<code>StackView</code>并点击<code>Pin</code>按钮。设置距离顶部、左侧、右侧的距离各自分别为10，0，0。并且把这三个约束加上。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/4.png\" alt=\"\"></p>\n<p>现在<code>StackView</code>的位置，并不满足我们的约束条件，你需要点击警告去修复这个问题。</p>\n<p>想设置高度的约束，到文档大纲视图。按住<code>Control</code>键，从<code>StackView</code>拖线到<code>View</code>上面，松开后，选择<code>Equal Height</code>.</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/5.png\" alt=\"\"></p>\n<p>这样设置以后，<code>StackView</code>的高度就与使徒的<code>View</code>相等。然而我们只需要让<code>StackView</code>的高度是视图的<code>View</code>的70%。所以选择<code>StackView</code>的<code>Height</code>属性，然后到<code>属性面板</code>，把<code>Mutiplier</code>的值从<code>1.0</code>变成<code>0.7</code>。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/6.png\" alt=\"\"></p>\n<h3 id=\"设置StackView属性值\"><a href=\"#设置StackView属性值\" class=\"headerlink\" title=\"设置StackView属性值\"></a>设置StackView属性值</h3><p><code>StackView</code>看起来并没有像预期一样，一旦你使用了<code>StackView</code>，你可以通过修改<code>StackView</code>的属性值来改变它的外观。</p>\n<p><code>Axis</code>是坐标轴，负责水平还是垂直。<br><code>alignment</code>是对齐方式。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/7.png\" alt=\"\"></p>\n<p><code>Distribution</code>决定了<code>StackView</code>中子控件的尺寸和位置。它默认被设置为<code>Fill</code>。在这个例子里，<code>StackView</code>要尽可能的利用有限的空间去适配它的子控件。接下来我们将选项改为<code>Fill Equally</code>。<code>StackView</code>会自动将里面的子控件重新布局为大小相等的控件。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/8.png\" alt=\"\"></p>\n<p><code>Space</code>选项允许你通过修改该选项，调解两个控件之间的距离，此处将值改为10。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/9.png\" alt=\"\"></p>\n<h3 id=\"设置图片\"><a href=\"#设置图片\" class=\"headerlink\" title=\"设置图片\"></a>设置图片</h3><p>接下来为三个<code>ImageView</code>设置图片</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/10.png\" alt=\"\"></p>\n<p>现在可以把程序跑起来看看效果，在不同的模拟器，UI都可以很好的适配各种设备。<code>StackView</code>已经自动帮你添加好了布局。实际上你可以通过<code>页面调试</code>选项，来查看为<code>ImageView</code>添加的布局。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/11.png\" alt=\"\"></p>\n<h3 id=\"用嵌套的方式布局控件\"><a href=\"#用嵌套的方式布局控件\" class=\"headerlink\" title=\"用嵌套的方式布局控件\"></a>用嵌套的方式布局控件</h3><p>还有一些<code>Lable</code>和<code>Button</code>需要添加到页面上，如图所示，拖两个<code>Lable</code>到<code>StackView</code>的正下方，上面的标签字号为30.</p>\n<p>然后选中两个<code>Lable</code>，点击<code>stack</code>选项，将这两个控件合并为一个<code>StackView</code>。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/12.gif\" alt=\"\"></p>\n<p>接下来添加两个按钮，一个<code>Like</code>,一个<code>Share</code>。把这两个控件合并为一个<code>StackView</code>，设置间距为 5，方向水平。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/13.png\" alt=\"\"></p>\n<p>把按钮的<code>StackView</code>拖进<code>Label</code>的<code>StackView</code>中，选中顶部的<code>Nature</code>标签和<code>Button</code>de <code>StackView</code>,点击<code>stack</code>选项,将他们两个合并为一个<code>StackView</code>，设置方向为水平</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/14.gif\" alt=\"\"></p>\n<p>选中这个<code>StackView</code>，将对齐方式调整为<code>First BaseLine</code>,沿第一个对象的基线对齐，然后给<code>Lable</code>和<code>Button</code>加一个20的间距。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/15.png\" alt=\"\"></p>\n<p>这样，我们只需要利用 <code>StackView</code> 的嵌套，就可以实现我们想得到的布局。</p>\n<p>最后，我们实现了用<code>StackView</code>包裹<code>ImageView</code>,同时也实现了<code>StackView</code>包裹<code>Label</code>和<code>Button</code>。将顶部、左侧、右侧各自设置值为 8，0，0。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/16.png\" alt=\"\"></p>\n<p>为了确保<code>Label</code>的描述文字可以正好适配，将<code>Label</code>的行数改为0，文字的<code>Line break</code>设置为文字包裹。这样你就完成了界面的设计。</p>\n<p>现在可以把程序跑起来看一下效果</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/17.png\" alt=\"\"></p>\n<p>如果横屏，效果是这样的：</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/18.png\" alt=\"\"></p>\n<p>看起来还可以，但是如果横屏时图片是水平排列那就更好了：</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/19.png\" alt=\"\"></p>\n<h3 id=\"利用-Size-Class-构建自适应的-StackView\"><a href=\"#利用-Size-Class-构建自适应的-StackView\" class=\"headerlink\" title=\"利用*Size Class 构建自适应的 StackView\"></a>利用*Size Class 构建自适应的 StackView</h3><p>为了实现 <code>iPhone</code> 在横屏时显示不同的布局，我们需要让<code>StackView</code>是自适应。在 <code>iOS8</code>，介绍过 <code>Size Class</code>  的概念，下面的表格介绍了不同的 <code>iOS</code> 设备以及他们相对应的 <code>Size Class</code>。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/20.png\" alt=\"\"></p>\n<p>你可以利用 <code>Size Class</code> 提供一个指定的布局去覆写之前的布局设计。在这个例子中，我们需要将<code>StackView</code>的方向在以下两种情况下，由垂直变为水平。</p>\n<ul>\n<li>宽度紧凑 - 高度紧凑</li>\n<li>宽度宽松 - 高度紧凑</li>\n</ul>\n<p>接下来选择我们的<code>StackView</code>,然后打开<code>属性面板</code>，点击<code>Axis</code>边上的<code>+</code>号。</p>\n<p>选择 <code>任意宽度</code> , <code>高度紧凑</code>，并把<code>StackView</code>的方向设置为<code>水平方向</code>。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/UIStackView%E6%95%99%E7%A8%8B/21.gif\" alt=\"\"></p>\n<p>然后。。。。。。就妥了！</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在这个教程中，对<code>StackView</code>进行了简单介绍，为大家做了一个Demo，以及如何使用这个全新的组件。<code>StackView</code>这种流线型的布局方式，让你在布局时只需要使用很少的约束。</p>\n<p><strong>Apple</strong>的工程师也是推荐优先使用<code>StackView</code>，实在不行在用原生的约束。</p>\n<p>我自己做了一个简单的Demo，地址如下 ： <a href=\"https://github.com/liberalisman/StackView-Demo\" target=\"_blank\" rel=\"external\">https://github.com/liberalisman/StackView-Demo</a></p>\n","excerpt":"这是一篇挺老的文章，主要就是介绍在iOS9时推出的控件UIStackView。我发现网上的资料并不算多，而AppCoda的这一篇就浅显易懂，所以决定翻译一下，再写个Demo。","categories":[],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://yoursite.com/tags/翻译/"}]},{"title":"Interview-Question & Answer （初级篇)","date":"2017-06-15T08:21:10.000Z","path":"2017/06/15/Interview-Question/","text":"此篇是根据知名博主 J-Knight 所提供的面试题目，所整理的答案，感谢 J-Knight 的分享，点击查看原文。 另外，我写此文的目的在于和广大的iOS开发者进行沟通交流，里面的内容有自己的理解，也有很大一部分参照网上的解释。很感谢之前的分享者，文末会附上相关的链接。如果在本文有理解不正确的地方，也希望大家多多指正。 面试题分为三个部分，我们先从基础开始。 基础1. 为什么说Objective-C是一门动态的语言？其实Objective-C是一门动态语言的用运行时Runtime可以更好地说明，但我看后面还有关于运行时的问题，在此处就先不展开了。 1. 动态类型：例如“id”类型，动态类型属于弱类型，在运行时才决定消息的接收者 2. 动态绑定：程序在运行时需要调用什么代码是在运行时决定的，而不是在编译时。 3. 动态载入：程序在运行时的代码模块以及相关资源是在运行时添加的，而不是启动时就加载所有资源 2.简要概括一下 MVC 和 MVVM，MVP三种模式。MVC MVC模式所有的模块通信都是单向的 1. `View`传递指令给`Controller` 2. `Controller` 完成业务逻辑后，要求 `Model` 改变状态 3. `Model` 将新的数据发送到 `View`，用户得到反馈 还有一种是Controller直接接受指令 MVPMVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。 各部分之间的通信，都是双向的。 View 与 Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。 MVVMMVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。 3.为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别?1.首先，为什么代理要用weak？其实就是循环引用！！！我们一般在声明一个协议的时候，会定义一个代理属性，如果代理用的比较溜就会知道，一般都是别的类成为当前协议的代理，也就是说，代理实际是外部的一个类。代理属性的销毁不由当前协议类控制，而是由外部代理者自己控制。如果在定义代理属性时，使用Strong，外界就无法销毁代理属性，造成循环引用，无法释放。 2.代理的delegate和dataSource有什么区别。delegate 和 dataSource 常见于UITableView和UICollectionView。dataSource是数据源，决定了显示多少个区域，每个区域显示多少行，每行现实的具体内容,头部,尾部视图等。delegate是交互行为的代理,比如点击，取消选中，是否高亮等等。 关于这个问题我有一些疑惑，比如delegate里面也有决定头部视图显示什么，尾部视图显示什么的方法，按我的理解应该在DataSource才对，请大家指教。 3.block和代理的区别?Block是带有局部变量的匿名函数，是一个代码段，Block更面向结果，他适合与状态无关的操作，例如直接返回某些值得时候，就比较适合用Block。 delegate回调则更加面向过程，例如执行的回调需要几个不同的步骤，这个时候使用delegate则更为合适 4.属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？@dynamic关键字和@synthesize关键字是用来做什么的？想深入了解，可以看一下详细的总结 : https://github.com/liberalisman/2018-Interview-Preparation#04-property 1.实质就是 ivar（实例变量）、存取方法（access method ＝ getter + setter）。@property 的本质. 1@property = ivar + getter + setter; 2.属性可以拥有的特质分为四类: 原子性— nonatomic 特质,在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为atomic的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。 读/写权限—readwrite(读写)、readonly (只读) 内存管理语义—assign、strong、 weak、unsafe_unretained、copy 方法名 - getter= 、setter= 3.属性的默认关键字:1@property (atomic，strong,readwrite) UIView *view; 4.“自动合成”( autosynthesis) 完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。也可以在类的实现代码里通过@synthesize 语法来指定实例变量的名字. 5.@dynamic 告诉编译器,属性的setter与getter方法由用户自己实现，不自动生成。 如果@synthesize和@dynamic都没写，那么默认的就是 1234@syntheszie var = _var;// @synthesize的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。// @dynamic告诉编译器,属性的setter与getter方法由用户自己实现，不自动生成。 6.为了搞清属性是怎么实现的,反编译相关的代码,大致生成了五个东西12345678910111213141. OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。2. setter 与 getter 方法对应的实现函数3. ivar_list ：成员变量列表4. method_list ：方法列表5. prop_list ：属性列表也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转. 5.NSString为什么要用copy关键字，如果用strong会有什么问题？NSString有可变的子类NSMutableString。因为父类指针可以指向子类，所以避免NSMutableString给NSString赋值，所以用Copy修饰。 Copy作为指针拷贝，是浅拷贝，保证了内容不会发生变化。此时如果使用Strong会在内存中新复制出一份。 但是如果可以保证，传过来的形参肯定不是NSMutableString的话，那么用Strong就可以，因为避免了Copy一次，反而提高了效率。 6.如何令自己所写的对象具有拷贝功能?简单说就是遵守NSCopying,NSMutableCopying协议 并且实现(id)copyWithZone:(NSZone *)zone和(id)mutableCopyWithZone:(NSZone *)zone两个方法即可。 深入了解可看我的其他文章。 7.可变集合类 和 不可变集合类的 copy 和 mutablecopy 有什么区别？如果是集合是内容复制的话，集合里面的元素也是内容复制么？ 源对象类型 拷贝方式 副本对象类型 是否有新的对象 NSArray Copy NSArray NO NSMutableArray Copy NSArray YES NSMutableArray MutableCopy NSMutableArray YES NSArray MutableCopy NSMutableArray YES 如果是集合内容复制，它的内容复制也分两种，一种是单层复制，一种是完全复制。上表的后三种全都是单层内容复制，只有最外面的容器被复制了，里面存储对象的指针地址不变。 8.为什么IBOutlet修饰的UIView使用weak关键字？关于IBOutlet修饰的属性究竟是使用strong还是weak,网上的不同意见还是挺多的。 但我认为这可以分为两种情况： 1.如果从storyBoard或者nib拖出来的插座属性是storyBoard或者nib所直接拥有的，这个时候应该使用Strong修饰 2.如果是一个storyBoard或者nib的子控件再添加子控件,这个时候就应该用weak。 这么说可能比较不好理解。 此图控制器的View拖出来的线就是strong。而如果往View上再次添加子控件的话，拖出来的线就是weak。 9.nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？1.nonatomic和atomic的区别？atomic-原子性 默认的属性 保证CPU在别的线程来访问这个属性之前，先执行完当前线程 速度较慢，因为要保证整体完成。 nonatomic-非原子性 非默认的属性 线程不安全，如果两个线程同时访问，会出问题 速度快 2.atomic是绝对的线程安全么？如果不是，那应该如何实现？很遗憾，并不是。。虽然atomic-原子性能保证不同的线程同时访问一个属性的时候，它的Setter和getter方法会有序执行，但如果此时有另一个线程调用该属性的Release方法，还是会出问题的，因为atomic-原子性只能管好它的Setter和getter方法。 再者开锁是很耗性能的，所以在移动端，一般使用nonatomic,而Mac OS不涉及到性能瓶颈，所在在Mac OS上使用atomic。 至于在iOS上保证属性在不同线程间访问的绝对安全，这块儿我暂时没有研究过，希望知道的朋友指教。 10.UICollectionView自定义layout如何实现？自定义Layout需要实现以下几个步骤。 1234567891011121314151617181920212223// 1.collectionView每次需要重新布局(初始, layout 被设置为invalidated ...)的时候会首先调用这个方法prepareLayout()func prepareLayout()// 2.然后会调用layoutAttributesForElementsInRect(rect: CGRect)方法获取到rect范围内的cell的所有布局, 这个rect大家可以打印出来看下, 和collectionView的bounds不一样, size可能比collectionView大一些, 这样设计也许是为了缓冲func layoutAttributesForElementsInRect(rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]?// 3.当collectionView的bounds变化的时候会调用shouldInvalidateLayoutForBoundsChange(newBounds: CGRect)这个方法public func shouldInvalidateLayoutForBoundsChange(newBounds: CGRect) -&gt; Bool// 4.需要设置collectionView 的滚动范围 collectionViewContentSize()// 自定义的时候, 必须重写这个方法, 并且返回正确的滚动范围, collectionView才能正常的滚动public func collectionViewContentSize() -&gt; CGSize// 5.以下方法, Apple建议我们也重写, 返回正确的自定义对象的布局,因为有时候当collectionView执行一些操作(delete insert reload)等系统会调用这些方法获取布局, 如果没有重写, 可能发生意想不到的效果 // 自定义cell布局的时候重写public func layoutAttributesForItemAtIndexPath(indexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes?// 自定义SupplementaryView的时候重写public func layoutAttributesForSupplementaryViewOfKind(elementKind: String, atIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes?// 自定义DecorationView的时候重写public func layoutAttributesForDecorationViewOfKind(elementKind: String, atIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes?// 6.这个方法是当collectionView将停止滚动的时候调用,得到最终偏移量。我们可以重写它来实现, collectionView停在指定的位置(比如照片浏览的时候, 你可以通过这个实现居中显示照片...)public func targetContentOffsetForProposedContentOffset(proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint) -&gt; CGPoint 11.用StoryBoard开发界面有什么弊端？如何避免？其实关于用StoryBoard还是纯代码的开发方式，争吵声一直都存在，其实我个人并不反感StoryBoard,反而还挺喜欢。开发速度快，如果协调好，可以减轻很多工作量。不过关于StoryBoard这个话题如果展开的话还是比较大，建议大家读一下。喵神最近写的一篇文章，附上原文链接，有异议的话也欢迎大家积极讨论。 12.进程和线程的区别？同步异步的区别？并行和并发的区别？1.进程和线程的区别？ 进程:进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。 线程：线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。1个进程要想执行任务，必须得有线程，例如默认就是主线程。 2.同步异步的区别？ 同步函数：不具备开线程的能力，只能串行按顺序执行任务 异步函数：具备开线程的能力，但并不是只要是异步函数就会开线程。 3.并行和并发的区别？ 并行：并行即同时执行。比如同时开启3条线程分别执行三个不同人物，这些任务执行时同时进行的。 并发：并发指在同一时间里，CPU只能处理1条线程，只有1条线程在工作（执行）。多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。 13.线程间通信？1.NSThread12345// 第一种方式。[self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES];// 第二种方式[self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES]; 2.GCD12345678910111213141516171819//0.获取一个全局的队列dispatch_queue_t queue = dispatch_get_global_queue(0, 0);//1.先开启一个线程，把下载图片的操作放在子线程中处理dispatch_async(queue, ^&#123; //2.下载图片 NSURL *url = [NSURL URLWithString:@\"http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg\"]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; NSLog(@\"下载操作所在的线程--%@\",[NSThread currentThread]); //3.回到主线程刷新UI dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; //打印查看当前线程 NSLog(@\"刷新UI---%@\",[NSThread currentThread]); &#125;);&#125;);// GCD通过嵌套就可以实现线程间的通信。 3.NSOperationQueue123456789101112131415161718//1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc]init];//2.使用简便方法封装操作并添加到队列中[queue addOperationWithBlock:^&#123; //3.在该block中下载图片 NSURL *url = [NSURL URLWithString:@\"http://news.51sheyuan.com/uploads/allimg/111001/133442IB-2.jpg\"]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; NSLog(@\"下载图片操作--%@\",[NSThread currentThread]); //4.回到主线程刷新UI [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; self.imageView.image = image; NSLog(@\"刷新UI操作---%@\",[NSThread currentThread]); &#125;];&#125;]; 14.GCD的一些常用的函数？1.栅栏函数（控制任务的执行顺序）1234dispatch_barrier_async(queue, ^&#123; NSLog(@\"barrier\");&#125;); 2.延迟执行（延迟·控制在哪个线程执行）123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@\"---%@\",[NSThread currentThread]);&#125;); 3.一次性代码12345static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; NSLog(@\"-----\");&#125;); 4.快速迭代（开多个线程并发完成迭代操作）12dispatch_apply(subpaths.count, queue, ^(size_t index) &#123;&#125;); 5.队列组（同栅栏函数）12345678dispatch_group_t group = dispatch_group_create();// 队列组中的任务执行完毕之后，执行该函数dispatch_group_notify(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block);// 进入群组和离开群组dispatch_group_enter(group);//执行该函数后，后面异步执行的block会被gruop监听dispatch_group_leave(group);//异步block中，所有的任务都执行完毕，最后离开群组//注意：dispatch_group_enter|dispatch_group_leave必须成对使用 15.如何使用队列来避免资源抢夺？可以用串行队列或者是同步锁。保证在同一时间内，只有一条线程在访问资源。 16.数据持久化的几个方案 plist文件（属性列表） preference（偏好设置） NSKeyedArchiver（归档） SQLite 3 CoreData（FMDB） 在此不展开了，篇幅比较大，详情见我另一篇文章 17.说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？1.应用程序启动，并进行初始化时候调用该方法： 12- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; &#125; 2、应用进入前台并处于活动状态时候调用： 1- (void)applicationDidBecomeActive:(UIApplication *)application &#123;&#125; 3、应用从活动状态进入到非活动状态： 1- (void)applicationWillResignActive:(UIApplication *)application &#123;&#125; 4、应用进入到后台时候调用的方法:applicationDidEnterBackground： 1- (void)applicationDidEnterBackground:(UIApplication *)application &#123;&#125; 5、应用进入到前台时候调用的方法: 1- (void)applicationWillEnterForeground:(UIApplication *)application &#123;&#125; 6、应用被终止的状态: 1- (void)applicationWillTerminate:(UIApplication *)application &#123;&#125; 18.NSCache优于NSDictionary的几点？在做缓存时，优先使用NSCache而不是NSDictionary,我们熟悉的框架SDWebimage就是采用的NSCache。 NSCache优点如下： 系统资源将要耗尽时，它可以自动删减缓存。 可以设置最大缓存数量。 可以设置最大占用内存值。 NSCache线程是安全的。 19.知不知道Designated Initializer？使用它的时候有什么需要注意的问题？这个问题没有想好该如何回答，希望大家指教。 20.实现description方法能取到什么效果？举例来说明吧 1.我们创建一个自定义对象123456@interface Person : NSObject@property (nonatomic,copy ) NSString *name;@property (nonatomic,copy ) NSString *hobbies;@end 2.在ViewController中，我们引用了Person类12345678910- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; Person *p = [[Person alloc] init]; p.name = @\"lili\"; p.hobbies = @\"paint\"; NSLog(@\"%@\",p);&#125; 此时打印出来的结果如图： 12017-06-15 13:12:00.471 cop[1561:258406] &lt;Person: 0x60800003dc80&gt; 是不是和你预计的效果还是差了一些？ 此时我们就需要重写对象的description方法 3.此时在Person的.m文件中，我们进行如下操作：123456789#import \"Person.h\"@implementation Person- (NSString *)description &#123; return [NSString stringWithFormat:@\"_name = %@,_hobbies = %@\",_name,_hobbies];&#125;@end 再次打印 12017-06-15 13:21:20.132 cop[1593:275015] _name = lili,_hobbies = paint 通过对比之后，大家一定就明白了 21.objc使用什么机制管理对象内存？Objective-C使用AEC自动引用计数来有效的管理内存。 他遵循的原则是，谁引用，谁销毁。 Retain,Copy,Alloc,New等必然对应Release。 初级篇完结起初乍一看感觉问题并不是很多，通过总结才发现面试官的准备十分充分，涵盖了很多方面，在总结的过程中，我也等于是复习了一遍。 目前针对初级篇的问题大致总结了一下，我看了中级以及高级的题目，大致分为以下几类： Runtime RunLoop Block KVC &amp; KVO 三方框架的源代码解析（AFN、SDWebImage…) 数据结构 再加上是基础题目里也有很多值得拓展的问题 内存管理 数据持久化 多线程 属性修饰符 内存语义。。。。 关于中高级的问题，我会每个话题单独开一篇来做仔细的分析，我心里并没有十足的把握，或许上面的回答也是漏洞百出，但是希望各位同行能多多指教，指出我的不足，在此先行谢过。 再次感谢 J-Knight 童鞋准备的面试题，针对你的题目，写一篇答案，有些唐突，望见谅。 在整理这篇答案的时候，借鉴了很多网上的资料，很杂，也很难一一列出。 但是关于MVC 和 MVVM，MVP模式的那篇，借鉴了阮一峰老师的一篇文章，写的浅显易懂，十分不错。 链接在此：MVC，MVP 和 MVVM 的图示 还有喵神的关于storyBoard那篇 链接在此：再看关于 Storyboard 的一些争论","content":"<p>此篇是根据知名博主 <a href=\"http://weibo.com/u/1929625262?from=feed&amp;loc=nickname\" target=\"_blank\" rel=\"external\">J-Knight</a> 所提供的面试题目，所整理的答案，感谢 <a href=\"http://weibo.com/u/1929625262?from=feed&amp;loc=nickname\" target=\"_blank\" rel=\"external\">J-Knight</a> 的分享，<a href=\"https://juejin.im/post/5938dfdb8d6d810058481572?utm_source=weibo&amp;utm_campaign=user。\" target=\"_blank\" rel=\"external\">点击查看原文。</a> </p>\n<p>另外，我写此文的目的在于和广大的<code>iOS</code>开发者进行沟通交流，里面的内容有自己的理解，也有很大一部分参照网上的解释。很感谢之前的分享者，文末会附上相关的链接。如果在本文有理解不正确的地方，也希望大家多多指正。</p>\n<p>面试题分为三个部分，我们先从基础开始。</p>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"1-为什么说Objective-C是一门动态的语言？\"><a href=\"#1-为什么说Objective-C是一门动态的语言？\" class=\"headerlink\" title=\"1. 为什么说Objective-C是一门动态的语言？\"></a>1. 为什么说Objective-C是一门动态的语言？</h3><p>其实<code>Objective-C</code>是一门动态语言的用<code>运行时Runtime</code>可以更好地说明，但我看后面还有关于<code>运行时</code>的问题，在此处就先不展开了。</p>\n<pre><code>1. 动态类型：例如“id”类型，动态类型属于弱类型，在运行时才决定消息的接收者\n2. 动态绑定：程序在运行时需要调用什么代码是在运行时决定的，而不是在编译时。\n3. 动态载入：程序在运行时的代码模块以及相关资源是在运行时添加的，而不是启动时就加载所有资源\n</code></pre><h3 id=\"2-简要概括一下-MVC-和-MVVM，MVP三种模式。\"><a href=\"#2-简要概括一下-MVC-和-MVVM，MVP三种模式。\" class=\"headerlink\" title=\"2.简要概括一下 MVC 和 MVVM，MVP三种模式。\"></a>2.简要概括一下 <strong>MVC</strong> 和 <strong>MVVM</strong>，<strong>MVP</strong>三种模式。</h3><h5 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h5><p><img src=\"http://image.beekka.com/blog/2015/bg2015020105.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p><strong><code>MVC</code>模式所有的模块通信都是单向的</strong></p>\n<pre><code>1. `View`传递指令给`Controller`\n2. `Controller` 完成业务逻辑后，要求 `Model` 改变状态\n3. `Model` 将新的数据发送到 `View`，用户得到反馈\n</code></pre><p><strong>还有一种是<code>Controller</code>直接接受指令</strong></p>\n<p><img src=\"http://image.beekka.com/blog/2015/bg2015020107.png\" alt=\"\"></p>\n<h5 id=\"MVP\"><a href=\"#MVP\" class=\"headerlink\" title=\"MVP\"></a>MVP</h5><p><strong><code>MVP</code> 模式将 <code>Controller</code> 改名为 <code>Presenter</code>，同时改变了通信方向。</strong></p>\n<p><img src=\"http://image.beekka.com/blog/2015/bg2015020109.png\" alt=\"\"></p>\n<ol>\n<li>各部分之间的通信，都是双向的。</li>\n<li><code>View</code> 与 <code>Model</code> 不发生联系，都通过 <code>Presenter</code> 传递。</li>\n<li><code>View</code> 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 <code>Presenter</code>非常厚，所有逻辑都部署在那里。</li>\n</ol>\n<h5 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h5><p><code>MVVM</code> 模式将 <code>Presenter</code> 改名为 <code>ViewModel</code>，基本上与 <code>MVP</code> 模式完全一致。<br><img src=\"http://image.beekka.com/blog/2015/bg2015020110.png\" alt=\"\"></p>\n<p>唯一的区别是，它采用<code>双向绑定（data-binding）</code>：<code>View</code>的变动，自动反映在 <code>ViewModel</code>，反之亦然。<code>Angular</code> 和 <code>Ember</code> 都采用这种模式。</p>\n<h3 id=\"3-为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别\"><a href=\"#3-为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别\" class=\"headerlink\" title=\"3.为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别?\"></a>3.为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别?</h3><h5 id=\"1-首先，为什么代理要用weak？\"><a href=\"#1-首先，为什么代理要用weak？\" class=\"headerlink\" title=\"1.首先，为什么代理要用weak？\"></a>1.首先，为什么代理要用weak？</h5><p><strong>其实就是循环引用！！！</strong><br>我们一般在声明一个协议的时候，会定义一个代理属性，如果代理用的比较溜就会知道，一般都是别的类成为当前协议的代理，也就是说，代理实际是外部的一个类。代理属性的销毁不由当前协议类控制，而是由外部代理者自己控制。<br>如果在定义代理属性时，使用<code>Strong</code>，外界就无法销毁代理属性，造成循环引用，无法释放。</p>\n<h5 id=\"2-代理的delegate和dataSource有什么区别。\"><a href=\"#2-代理的delegate和dataSource有什么区别。\" class=\"headerlink\" title=\"2.代理的delegate和dataSource有什么区别。\"></a>2.代理的delegate和dataSource有什么区别。</h5><p><code>delegate</code> 和 <code>dataSource</code> 常见于<code>UITableView</code>和<code>UICollectionView</code>。<br><code>dataSource</code>是数据源，决定了显示多少个<code>区域</code>，每个区域显示多少<code>行</code>，每行现实的<code>具体内容</code>,<code>头部,尾部</code>视图等。<br><code>delegate</code>是交互行为的代理,比如<code>点击</code>，<code>取消选中</code>，<code>是否高亮</code>等等。</p>\n<p>关于这个问题我有一些疑惑，比如<code>delegate</code>里面也有决定头部视图显示什么，尾部视图显示什么的方法，按我的理解应该在<code>DataSource</code>才对，请大家指教。</p>\n<h5 id=\"3-block和代理的区别\"><a href=\"#3-block和代理的区别\" class=\"headerlink\" title=\"3.block和代理的区别?\"></a>3.block和代理的区别?</h5><p><code>Block</code>是带有局部变量的匿名函数，是一个代码段，<code>Block</code>更面向结果，他适合与状态无关的操作，例如直接返回某些值得时候，就比较适合用<code>Block</code>。</p>\n<p><code>delegate</code>回调则更加面向过程，例如执行的回调需要几个不同的步骤，这个时候使用<code>delegate</code>则更为合适</p>\n<h3 id=\"4-属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？-dynamic关键字和-synthesize关键字是用来做什么的？\"><a href=\"#4-属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？-dynamic关键字和-synthesize关键字是用来做什么的？\" class=\"headerlink\" title=\"4.属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？@dynamic关键字和@synthesize关键字是用来做什么的？\"></a>4.属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？@dynamic关键字和@synthesize关键字是用来做什么的？</h3><p>想深入了解，可以看一下详细的总结 : <a href=\"https://github.com/liberalisman/2018-Interview-Preparation#04-property\" target=\"_blank\" rel=\"external\">https://github.com/liberalisman/2018-Interview-Preparation#04-property</a></p>\n<h5 id=\"1-实质就是-ivar（实例变量）、存取方法（access-method-＝-getter-setter）。\"><a href=\"#1-实质就是-ivar（实例变量）、存取方法（access-method-＝-getter-setter）。\" class=\"headerlink\" title=\"1.实质就是 ivar（实例变量）、存取方法（access method ＝ getter + setter）。\"></a>1.实质就是 ivar（实例变量）、存取方法（access method ＝ getter + setter）。</h5><p>@property 的本质.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> = ivar + <span class=\"keyword\">getter</span> + <span class=\"keyword\">setter</span>;</div></pre></td></tr></table></figure>\n<h5 id=\"2-属性可以拥有的特质分为四类\"><a href=\"#2-属性可以拥有的特质分为四类\" class=\"headerlink\" title=\"2.属性可以拥有的特质分为四类:\"></a>2.属性可以拥有的特质分为四类:</h5><ul>\n<li><p><strong>原子性— nonatomic</strong> 特质,在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性<code>(atomicity)</code>。如果属性具备 <code>nonatomic</code> 特质，则不使用<code>自旋锁</code>。请注意，尽管没有名为<code>atomic</code>的特质(如果某属性不具备 <code>nonatomic</code> 特质，那它就是“原子的” ( <code>atomic</code>) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</p>\n</li>\n<li><p><strong>读/写权限</strong>—readwrite(读写)、readonly (只读)</p>\n</li>\n<li><p><strong>内存管理语义</strong>—assign、strong、 weak、unsafe_unretained、copy</p>\n</li>\n<li><strong>方法名</strong> - getter=<name> 、setter=<name></name></name></li>\n</ul>\n<h5 id=\"3-属性的默认关键字\"><a href=\"#3-属性的默认关键字\" class=\"headerlink\" title=\"3.属性的默认关键字:\"></a>3.属性的默认关键字:</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (atomic，<span class=\"keyword\">strong</span>,<span class=\"keyword\">readwrite</span>) <span class=\"built_in\">UIView</span> *view;</div></pre></td></tr></table></figure>\n<h5 id=\"4-“自动合成”-autosynthesis\"><a href=\"#4-“自动合成”-autosynthesis\" class=\"headerlink\" title=\"4.“自动合成”( autosynthesis)\"></a>4.“自动合成”( autosynthesis)</h5><blockquote>\n<p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做<strong>“自动合成”(autosynthesis)</strong>。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码<strong> getter、setter</strong> 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。<br>也可以在类的实现代码里通过<strong>@synthesize</strong> 语法来指定实例变量的名字.</p>\n</blockquote>\n<h5 id=\"5-dynamic\"><a href=\"#5-dynamic\" class=\"headerlink\" title=\"5.@dynamic\"></a>5.@dynamic</h5><blockquote>\n<p>告诉编译器,属性的setter与getter方法由用户自己实现，不自动生成。</p>\n</blockquote>\n<p>如果<code>@synthesize</code>和<code>@dynamic</code>都没写，那么默认的就是</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@syntheszie var = _var;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// @synthesize的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。</span></div><div class=\"line\"><span class=\"comment\">// @dynamic告诉编译器,属性的setter与getter方法由用户自己实现，不自动生成。</span></div></pre></td></tr></table></figure>\n<h5 id=\"6-为了搞清属性是怎么实现的-反编译相关的代码-大致生成了五个东西\"><a href=\"#6-为了搞清属性是怎么实现的-反编译相关的代码-大致生成了五个东西\" class=\"headerlink\" title=\"6.为了搞清属性是怎么实现的,反编译相关的代码,大致生成了五个东西\"></a>6.为了搞清属性是怎么实现的,反编译相关的代码,大致生成了五个东西</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1.</span> OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。</div><div class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">setter</span> 与 <span class=\"keyword\">getter</span> 方法对应的实现函数</div><div class=\"line\"><span class=\"number\">3.</span> ivar_list ：成员变量列表</div><div class=\"line\"><span class=\"number\">4.</span> method_list ：方法列表</div><div class=\"line\"><span class=\"number\">5.</span> prop_list ：属性列表</div><div class=\"line\">也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,</div><div class=\"line\">在 method_list 中增加 <span class=\"keyword\">setter</span> 与 <span class=\"keyword\">getter</span> 方法的描述,</div><div class=\"line\">在属性列表中增加一个属性的描述,</div><div class=\"line\">然后计算该属性在对象中的偏移量,</div><div class=\"line\">然后给出 <span class=\"keyword\">setter</span> 与 <span class=\"keyword\">getter</span> 方法对应的实现,</div><div class=\"line\">在 <span class=\"keyword\">setter</span> 方法中从偏移量的位置开始赋值,</div><div class=\"line\">在 <span class=\"keyword\">getter</span> 方法中从偏移量开始取值,</div><div class=\"line\">为了能够读取正确字节数,</div><div class=\"line\">系统对象偏移量的指针类型进行了类型强转.</div></pre></td></tr></table></figure>\n<h3 id=\"5-NSString为什么要用copy关键字，如果用strong会有什么问题？\"><a href=\"#5-NSString为什么要用copy关键字，如果用strong会有什么问题？\" class=\"headerlink\" title=\"5.NSString为什么要用copy关键字，如果用strong会有什么问题？\"></a>5.NSString为什么要用copy关键字，如果用strong会有什么问题？</h3><p><code>NSString</code>有可变的子类<code>NSMutableString</code>。因为父类指针可以指向子类，所以避免<code>NSMutableString</code>给<code>NSString</code>赋值，所以用<code>Copy</code>修饰。</p>\n<p><code>Copy</code>作为指针拷贝，是浅拷贝，保证了内容不会发生变化。此时如果使用<code>Strong</code>会在内存中新复制出一份。</p>\n<p>但是如果可以保证，传过来的形参肯定不是<code>NSMutableString</code>的话，那么用<code>Strong</code>就可以，因为避免了<code>Copy</code>一次，反而提高了效率。</p>\n<h3 id=\"6-如何令自己所写的对象具有拷贝功能\"><a href=\"#6-如何令自己所写的对象具有拷贝功能\" class=\"headerlink\" title=\"6.如何令自己所写的对象具有拷贝功能?\"></a>6.如何令自己所写的对象具有拷贝功能?</h3><p>简单说就是遵守<code>NSCopying</code>,<code>NSMutableCopying</code>协议</p>\n<p>并且实现<code>(id)copyWithZone:(NSZone *)zone</code>和<code>(id)mutableCopyWithZone:(NSZone *)zone</code>两个方法即可。</p>\n<p>深入了解可看我的<a href=\"https://github.com/liberalisman/2018-Interview-Preparation#02-shallowcopy-deepcopy\" target=\"_blank\" rel=\"external\">其他文章</a>。</p>\n<h3 id=\"7-可变集合类-和-不可变集合类的-copy-和-mutablecopy-有什么区别？如果是集合是内容复制的话，集合里面的元素也是内容复制么？\"><a href=\"#7-可变集合类-和-不可变集合类的-copy-和-mutablecopy-有什么区别？如果是集合是内容复制的话，集合里面的元素也是内容复制么？\" class=\"headerlink\" title=\"7.可变集合类 和 不可变集合类的 copy 和 mutablecopy 有什么区别？如果是集合是内容复制的话，集合里面的元素也是内容复制么？\"></a>7.<code>可变集合类</code> 和 <code>不可变集合类</code>的 <code>copy</code> 和 <code>mutablecopy</code> 有什么区别？如果是集合是内容复制的话，集合里面的元素也是内容复制么？</h3><table>\n<thead>\n<tr>\n<th>源对象类型</th>\n<th>拷贝方式</th>\n<th>副本对象类型</th>\n<th>是否有新的对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NSArray</td>\n<td>Copy</td>\n<td>NSArray</td>\n<td>NO</td>\n</tr>\n<tr>\n<td>NSMutableArray</td>\n<td>Copy</td>\n<td>NSArray</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>NSMutableArray</td>\n<td>MutableCopy</td>\n<td>NSMutableArray</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>NSArray</td>\n<td>MutableCopy</td>\n<td>NSMutableArray</td>\n<td>YES</td>\n</tr>\n</tbody>\n</table>\n<p>如果是集合内容复制，它的内容复制也分两种，一种是<code>单层复制</code>，一种是<code>完全复制</code>。上表的后三种全都是<code>单层内容复制</code>，只有最外面的容器被复制了，里面存储对象的指针地址不变。</p>\n<h3 id=\"8-为什么IBOutlet修饰的UIView使用weak关键字？\"><a href=\"#8-为什么IBOutlet修饰的UIView使用weak关键字？\" class=\"headerlink\" title=\"8.为什么IBOutlet修饰的UIView使用weak关键字？\"></a>8.为什么IBOutlet修饰的UIView使用weak关键字？</h3><p>关于<code>IBOutlet</code>修饰的属性究竟是使用<code>strong</code>还是<code>weak</code>,网上的不同意见还是挺多的。</p>\n<p>但我认为这可以分为两种情况：</p>\n<p>1.如果从<code>storyBoard</code>或者<code>nib</code>拖出来的<code>插座属性</code>是<code>storyBoard</code>或者<code>nib</code>所直接拥有的，这个时候应该使用<code>Strong</code>修饰</p>\n<p>2.如果是一个<code>storyBoard</code>或者<code>nib</code>的<code>子控件</code>再添加<code>子控件</code>,这个时候就应该用<code>weak</code>。</p>\n<p>这么说可能比较不好理解。<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/Interview-QA/1.png\" alt=\"\"></p>\n<p>此图控制器的View拖出来的线就是<code>strong</code>。<br>而如果往<code>View</code>上再次添加子控件的话，拖出来的线就是<code>weak</code>。</p>\n<h3 id=\"9-nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？\"><a href=\"#9-nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？\" class=\"headerlink\" title=\"9.nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？\"></a>9.nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？</h3><h5 id=\"1-nonatomic和atomic的区别？\"><a href=\"#1-nonatomic和atomic的区别？\" class=\"headerlink\" title=\"1.nonatomic和atomic的区别？\"></a>1.nonatomic和atomic的区别？</h5><p><code>atomic-原子性</code></p>\n<ul>\n<li>默认的属性</li>\n<li>保证CPU在别的线程来访问这个属性之前，先执行完当前线程</li>\n<li>速度较慢，因为要保证整体完成。</li>\n</ul>\n<p><code>nonatomic-非原子性</code></p>\n<ul>\n<li>非默认的属性</li>\n<li>线程不安全，如果两个线程同时访问，会出问题</li>\n<li>速度快</li>\n</ul>\n<h5 id=\"2-atomic是绝对的线程安全么？如果不是，那应该如何实现？\"><a href=\"#2-atomic是绝对的线程安全么？如果不是，那应该如何实现？\" class=\"headerlink\" title=\"2.atomic是绝对的线程安全么？如果不是，那应该如何实现？\"></a>2.atomic是绝对的线程安全么？如果不是，那应该如何实现？</h5><p>很遗憾，并不是。。虽然<code>atomic-原子性</code>能保证不同的线程同时访问一个属性的时候，它的<code>Setter</code>和<code>getter</code>方法会有序执行，但如果此时有另一个线程调用该属性的<code>Release</code>方法，还是会出问题的，因为<code>atomic-原子性</code>只能管好它的<code>Setter</code>和<code>getter</code>方法。</p>\n<p>再者开锁是很耗性能的，所以在移动端，一般使用<code>nonatomic</code>,而<code>Mac OS</code>不涉及到性能瓶颈，所在在<code>Mac OS</code>上使用<code>atomic</code>。</p>\n<p>至于在<code>iOS</code>上保证属性在不同线程间访问的绝对安全，这块儿我暂时没有研究过，希望知道的朋友指教。</p>\n<h3 id=\"10-UICollectionView自定义layout如何实现？\"><a href=\"#10-UICollectionView自定义layout如何实现？\" class=\"headerlink\" title=\"10.UICollectionView自定义layout如何实现？\"></a>10.UICollectionView自定义layout如何实现？</h3><p>自定义<code>Layout</code>需要实现以下几个步骤。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 1.collectionView每次需要重新布局(初始, layout 被设置为invalidated ...)的时候会首先调用这个方法prepareLayout()</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">prepareLayout</span><span class=\"params\">()</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 2.然后会调用layoutAttributesForElementsInRect(rect: CGRect)方法获取到rect范围内的cell的所有布局, 这个rect大家可以打印出来看下, 和collectionView的bounds不一样, size可能比collectionView大一些, 这样设计也许是为了缓冲</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">layoutAttributesForElementsInRect</span><span class=\"params\">(rect: CGRect)</span></span> -&gt; [<span class=\"type\">UICollectionViewLayoutAttributes</span>]?</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 3.当collectionView的bounds变化的时候会调用shouldInvalidateLayoutForBoundsChange(newBounds: CGRect)这个方法</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shouldInvalidateLayoutForBoundsChange</span><span class=\"params\">(newBounds: CGRect)</span></span> -&gt; <span class=\"type\">Bool</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 4.需要设置collectionView 的滚动范围 collectionViewContentSize()</span></div><div class=\"line\"><span class=\"comment\">// 自定义的时候, 必须重写这个方法, 并且返回正确的滚动范围, collectionView才能正常的滚动</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionViewContentSize</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">CGSize</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//  5.以下方法, Apple建议我们也重写, 返回正确的自定义对象的布局,因为有时候当collectionView执行一些操作(delete insert reload)等系统会调用这些方法获取布局, 如果没有重写, 可能发生意想不到的效果    </span></div><div class=\"line\"><span class=\"comment\">// 自定义cell布局的时候重写</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">layoutAttributesForItemAtIndexPath</span><span class=\"params\">(indexPath: NSIndexPath)</span></span> -&gt; <span class=\"type\">UICollectionViewLayoutAttributes</span>?</div><div class=\"line\"><span class=\"comment\">// 自定义SupplementaryView的时候重写</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">layoutAttributesForSupplementaryViewOfKind</span><span class=\"params\">(elementKind: String, atIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class=\"type\">UICollectionViewLayoutAttributes</span>?</div><div class=\"line\"><span class=\"comment\">// 自定义DecorationView的时候重写</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">layoutAttributesForDecorationViewOfKind</span><span class=\"params\">(elementKind: String, atIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class=\"type\">UICollectionViewLayoutAttributes</span>?</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 6.这个方法是当collectionView将停止滚动的时候调用,得到最终偏移量。我们可以重写它来实现, collectionView停在指定的位置(比如照片浏览的时候, 你可以通过这个实现居中显示照片...)</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">targetContentOffsetForProposedContentOffset</span><span class=\"params\">(proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint)</span></span> -&gt; <span class=\"type\">CGPoint</span></div></pre></td></tr></table></figure>\n<h3 id=\"11-用StoryBoard开发界面有什么弊端？如何避免？\"><a href=\"#11-用StoryBoard开发界面有什么弊端？如何避免？\" class=\"headerlink\" title=\"11.用StoryBoard开发界面有什么弊端？如何避免？\"></a>11.用StoryBoard开发界面有什么弊端？如何避免？</h3><p>其实关于用<code>StoryBoard</code>还是纯代码的开发方式，争吵声一直都存在，其实我个人并不反感<code>StoryBoard</code>,反而还挺喜欢。开发速度快，如果协调好，可以减轻很多工作量。不过关于<code>StoryBoard</code>这个话题如果展开的话还是比较大，建议大家读一下。喵神最近写的一篇文章，附上<a href=\"https://onevcat.com/2017/04/storyboard-argue/\" target=\"_blank\" rel=\"external\">原文链接</a>，有异议的话也欢迎大家积极讨论。</p>\n<h3 id=\"12-进程和线程的区别？同步异步的区别？并行和并发的区别？\"><a href=\"#12-进程和线程的区别？同步异步的区别？并行和并发的区别？\" class=\"headerlink\" title=\"12.进程和线程的区别？同步异步的区别？并行和并发的区别？\"></a>12.进程和线程的区别？同步异步的区别？并行和并发的区别？</h3><h5 id=\"1-进程和线程的区别？\"><a href=\"#1-进程和线程的区别？\" class=\"headerlink\" title=\"1.进程和线程的区别？\"></a>1.进程和线程的区别？</h5><blockquote>\n<p>进程:进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。</p>\n<p>线程：线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。1个进程要想执行任务，必须得有线程，例如默认就是主线程。</p>\n</blockquote>\n<h5 id=\"2-同步异步的区别？\"><a href=\"#2-同步异步的区别？\" class=\"headerlink\" title=\"2.同步异步的区别？\"></a>2.同步异步的区别？</h5><blockquote>\n<p>同步函数：不具备开线程的能力，只能串行按顺序执行任务</p>\n<p>异步函数：具备开线程的能力，但并不是只要是异步函数就会开线程。</p>\n</blockquote>\n<h5 id=\"3-并行和并发的区别？\"><a href=\"#3-并行和并发的区别？\" class=\"headerlink\" title=\"3.并行和并发的区别？\"></a>3.并行和并发的区别？</h5><blockquote>\n<p>并行：并行即同时执行。比如同时开启3条线程分别执行三个不同人物，这些任务执行时同时进行的。</p>\n<p>并发：并发指在同一时间里，CPU只能处理1条线程，只有1条线程在工作（执行）。多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。</p>\n</blockquote>\n<h3 id=\"13-线程间通信？\"><a href=\"#13-线程间通信？\" class=\"headerlink\" title=\"13.线程间通信？\"></a>13.线程间通信？</h3><h5 id=\"1-NSThread\"><a href=\"#1-NSThread\" class=\"headerlink\" title=\"1.NSThread\"></a>1.NSThread</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 第一种方式。</span></div><div class=\"line\">[<span class=\"keyword\">self</span> performSelectorOnMainThread:<span class=\"keyword\">@selector</span>(showImage:) withObject:image waitUntilDone:<span class=\"literal\">YES</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 第二种方式</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.imageView performSelectorOnMainThread:<span class=\"keyword\">@selector</span>(setImage:) withObject:image waitUntilDone:<span class=\"literal\">YES</span>];</div></pre></td></tr></table></figure>\n<h5 id=\"2-GCD\"><a href=\"#2-GCD\" class=\"headerlink\" title=\"2.GCD\"></a>2.GCD</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//0.获取一个全局的队列</span></div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//1.先开启一个线程，把下载图片的操作放在子线程中处理</span></div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</div><div class=\"line\">   <span class=\"comment\">//2.下载图片</span></div><div class=\"line\">    <span class=\"built_in\">NSURL</span> *url = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg\"</span>];</div><div class=\"line\">    <span class=\"built_in\">NSData</span> *data = [<span class=\"built_in\">NSData</span> dataWithContentsOfURL:url];</div><div class=\"line\">    <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageWithData:data];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"下载操作所在的线程--%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">    <span class=\"comment\">//3.回到主线程刷新UI</span></div><div class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">       <span class=\"keyword\">self</span>.imageView.image = image;</div><div class=\"line\">       <span class=\"comment\">//打印查看当前线程</span></div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"刷新UI---%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// GCD通过嵌套就可以实现线程间的通信。</span></div></pre></td></tr></table></figure>\n<h5 id=\"3-NSOperationQueue\"><a href=\"#3-NSOperationQueue\" class=\"headerlink\" title=\"3.NSOperationQueue\"></a>3.NSOperationQueue</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1.创建队列</span></div><div class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2.使用简便方法封装操作并添加到队列中</span></div><div class=\"line\">[queue addOperationWithBlock:^&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//3.在该block中下载图片</span></div><div class=\"line\">    <span class=\"built_in\">NSURL</span> *url = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://news.51sheyuan.com/uploads/allimg/111001/133442IB-2.jpg\"</span>];</div><div class=\"line\">    <span class=\"built_in\">NSData</span> *data = [<span class=\"built_in\">NSData</span> dataWithContentsOfURL:url];</div><div class=\"line\">    <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageWithData:data];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"下载图片操作--%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//4.回到主线程刷新UI</span></div><div class=\"line\">    [[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.imageView.image = image;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"刷新UI操作---%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<h3 id=\"14-GCD的一些常用的函数？\"><a href=\"#14-GCD的一些常用的函数？\" class=\"headerlink\" title=\"14.GCD的一些常用的函数？\"></a>14.GCD的一些常用的函数？</h3><h5 id=\"1-栅栏函数（控制任务的执行顺序）\"><a href=\"#1-栅栏函数（控制任务的执行顺序）\" class=\"headerlink\" title=\"1.栅栏函数（控制任务的执行顺序）\"></a>1.栅栏函数（控制任务的执行顺序）</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_barrier_async(queue, ^&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"barrier\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h5 id=\"2-延迟执行（延迟·控制在哪个线程执行）\"><a href=\"#2-延迟执行（延迟·控制在哪个线程执行）\" class=\"headerlink\" title=\"2.延迟执行（延迟·控制在哪个线程执行）\"></a>2.延迟执行（延迟·控制在哪个线程执行）</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"---%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h5 id=\"3-一次性代码\"><a href=\"#3-一次性代码\" class=\"headerlink\" title=\"3.一次性代码\"></a>3.一次性代码</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</div><div class=\"line\"><span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"-----\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h5 id=\"4-快速迭代（开多个线程并发完成迭代操作）\"><a href=\"#4-快速迭代（开多个线程并发完成迭代操作）\" class=\"headerlink\" title=\"4.快速迭代（开多个线程并发完成迭代操作）\"></a>4.快速迭代（开多个线程并发完成迭代操作）</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_apply(subpaths.count, queue, ^(size_t index) &#123;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h5 id=\"5-队列组（同栅栏函数）\"><a href=\"#5-队列组（同栅栏函数）\" class=\"headerlink\" title=\"5.队列组（同栅栏函数）\"></a>5.队列组（同栅栏函数）</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_group_t group = dispatch_group_create();</div><div class=\"line\"><span class=\"comment\">// 队列组中的任务执行完毕之后，执行该函数</span></div><div class=\"line\">dispatch_group_notify(dispatch_group_t group,<span class=\"built_in\">dispatch_queue_t</span> queue,dispatch_block_t block);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 进入群组和离开群组</span></div><div class=\"line\">dispatch_group_enter(group);<span class=\"comment\">//执行该函数后，后面异步执行的block会被gruop监听</span></div><div class=\"line\">dispatch_group_leave(group);<span class=\"comment\">//异步block中，所有的任务都执行完毕，最后离开群组</span></div><div class=\"line\"><span class=\"comment\">//注意：dispatch_group_enter|dispatch_group_leave必须成对使用</span></div></pre></td></tr></table></figure>\n<h3 id=\"15-如何使用队列来避免资源抢夺？\"><a href=\"#15-如何使用队列来避免资源抢夺？\" class=\"headerlink\" title=\"15.如何使用队列来避免资源抢夺？\"></a>15.如何使用队列来避免资源抢夺？</h3><p>可以用<strong>串行队列</strong>或者是<strong>同步锁</strong>。保证在同一时间内，只有一条线程在访问资源。</p>\n<h3 id=\"16-数据持久化的几个方案\"><a href=\"#16-数据持久化的几个方案\" class=\"headerlink\" title=\"16.数据持久化的几个方案\"></a>16.数据持久化的几个方案</h3><ul>\n<li>plist文件（属性列表）</li>\n<li>preference（偏好设置）</li>\n<li>NSKeyedArchiver（归档）</li>\n<li>SQLite 3</li>\n<li>CoreData（FMDB）</li>\n</ul>\n<p>在此不展开了，篇幅比较大，详情见我<a href=\"https://github.com/liberalisman/iOS-Summary-Part1#08-ios数据持久化方案\" target=\"_blank\" rel=\"external\">另一篇文章</a></p>\n<h3 id=\"17-说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？\"><a href=\"#17-说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？\" class=\"headerlink\" title=\"17.说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？\"></a>17.说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？</h3><p>1.应用程序启动，并进行初始化时候调用该方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>2、应用进入前台并处于活动状态时候调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)applicationDidBecomeActive:(<span class=\"built_in\">UIApplication</span> *)application &#123;&#125;</div></pre></td></tr></table></figure>\n<p>3、应用从活动状态进入到非活动状态：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)applicationWillResignActive:(<span class=\"built_in\">UIApplication</span> *)application &#123;&#125;</div></pre></td></tr></table></figure>\n<p>4、应用进入到后台时候调用的方法:applicationDidEnterBackground：</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)applicationDidEnterBackground:(<span class=\"built_in\">UIApplication</span> *)application &#123;&#125;</div></pre></td></tr></table></figure>\n<p>5、应用进入到前台时候调用的方法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)applicationWillEnterForeground:(<span class=\"built_in\">UIApplication</span> *)application &#123;&#125;</div></pre></td></tr></table></figure>\n<p>6、应用被终止的状态:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)applicationWillTerminate:(<span class=\"built_in\">UIApplication</span> *)application &#123;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"18-NSCache优于NSDictionary的几点？\"><a href=\"#18-NSCache优于NSDictionary的几点？\" class=\"headerlink\" title=\"18.NSCache优于NSDictionary的几点？\"></a>18.NSCache优于NSDictionary的几点？</h3><p>在做缓存时，优先使用<code>NSCache</code>而不是<code>NSDictionary</code>,我们熟悉的框架<code>SDWebimage</code>就是采用的<code>NSCache</code>。</p>\n<p><code>NSCache</code>优点如下：</p>\n<ol>\n<li>系统资源将要耗尽时，它可以自动删减缓存。</li>\n<li>可以设置最大缓存数量。</li>\n<li>可以设置最大占用内存值。</li>\n<li><code>NSCache</code>线程是安全的。</li>\n</ol>\n<h3 id=\"19-知不知道Designated-Initializer？使用它的时候有什么需要注意的问题？\"><a href=\"#19-知不知道Designated-Initializer？使用它的时候有什么需要注意的问题？\" class=\"headerlink\" title=\"19.知不知道Designated Initializer？使用它的时候有什么需要注意的问题？\"></a>19.知不知道Designated Initializer？使用它的时候有什么需要注意的问题？</h3><p>这个问题没有想好该如何回答，希望大家指教。</p>\n<h3 id=\"20-实现description方法能取到什么效果？\"><a href=\"#20-实现description方法能取到什么效果？\" class=\"headerlink\" title=\"20.实现description方法能取到什么效果？\"></a>20.实现description方法能取到什么效果？</h3><p>举例来说明吧</p>\n<h5 id=\"1-我们创建一个自定义对象\"><a href=\"#1-我们创建一个自定义对象\" class=\"headerlink\" title=\"1.我们创建一个自定义对象\"></a>1.我们创建一个自定义对象</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Person</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>  ) <span class=\"built_in\">NSString</span> *name;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>  ) <span class=\"built_in\">NSString</span> *hobbies;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h5 id=\"2-在ViewController中，我们引用了Person类\"><a href=\"#2-在ViewController中，我们引用了Person类\" class=\"headerlink\" title=\"2.在ViewController中，我们引用了Person类\"></a>2.在<code>ViewController</code>中，我们引用了<code>Person</code>类</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    Person *p = [[Person alloc] init];</div><div class=\"line\">    </div><div class=\"line\">    p.name = <span class=\"string\">@\"lili\"</span>;</div><div class=\"line\">    </div><div class=\"line\">    p.hobbies = <span class=\"string\">@\"paint\"</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,p);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>此时打印出来的结果如图：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-06</span><span class=\"number\">-15</span> <span class=\"number\">13</span>:<span class=\"number\">12</span>:<span class=\"number\">00.471</span> cop[<span class=\"number\">1561</span>:<span class=\"number\">258406</span>] &lt;Person: <span class=\"number\">0x60800003dc80</span>&gt;</div></pre></td></tr></table></figure>\n<p><strong>是不是和你预计的效果还是差了一些？</strong></p>\n<p>此时我们就需要重写对象的<strong><code>description</code></strong>方法</p>\n<h5 id=\"3-此时在Person的-m文件中，我们进行如下操作：\"><a href=\"#3-此时在Person的-m文件中，我们进行如下操作：\" class=\"headerlink\" title=\"3.此时在Person的.m文件中，我们进行如下操作：\"></a>3.此时在<code>Person</code>的<code>.m</code>文件中，我们进行如下操作：</h5><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Person.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Person</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)description &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"_name = %@,_hobbies = %@\"</span>,_name,_hobbies];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>再次打印</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-06</span><span class=\"number\">-15</span> <span class=\"number\">13</span>:<span class=\"number\">21</span>:<span class=\"number\">20.132</span> cop[<span class=\"number\">1593</span>:<span class=\"number\">275015</span>] _name = lili,_hobbies = paint</div></pre></td></tr></table></figure>\n<p> 通过对比之后，大家一定就明白了</p>\n<h3 id=\"21-objc使用什么机制管理对象内存？\"><a href=\"#21-objc使用什么机制管理对象内存？\" class=\"headerlink\" title=\"21.objc使用什么机制管理对象内存？\"></a>21.objc使用什么机制管理对象内存？</h3><p>Objective-C使用<code>AEC自动引用计数</code>来有效的管理内存。</p>\n<p>他遵循的原则是，谁引用，谁销毁。</p>\n<p><code>Retain</code>,<code>Copy</code>,<code>Alloc</code>,<code>New</code>等必然对应<code>Release</code>。</p>\n<h3 id=\"初级篇完结\"><a href=\"#初级篇完结\" class=\"headerlink\" title=\"初级篇完结\"></a>初级篇完结</h3><p>起初乍一看感觉问题并不是很多，通过总结才发现面试官的准备十分充分，涵盖了很多方面，在总结的过程中，我也等于是复习了一遍。</p>\n<p>目前针对初级篇的问题大致总结了一下，我看了中级以及高级的题目，<strong>大致分为以下几类</strong>：</p>\n<ul>\n<li><strong>Runtime</strong></li>\n<li><strong>RunLoop</strong></li>\n<li><strong>Block</strong></li>\n<li><strong>KVC &amp; KVO</strong></li>\n<li><strong>三方框架的源代码解析（AFN、SDWebImage…)</strong></li>\n<li><strong>数据结构</strong></li>\n</ul>\n<p><strong>再加上是基础题目里也有很多值得拓展的问题</strong></p>\n<ul>\n<li><strong>内存管理</strong></li>\n<li><strong>数据持久化</strong></li>\n<li><strong>多线程</strong></li>\n<li><strong>属性修饰符</strong></li>\n<li><strong>内存语义。。。。</strong></li>\n</ul>\n<p>关于中高级的问题，我会每个话题单独开一篇来做仔细的分析，我心里并没有十足的把握，或许上面的回答也是漏洞百出，但是希望各位同行能多多指教，指出我的不足，在此先行谢过。</p>\n<p>再次感谢 <a href=\"http://weibo.com/u/1929625262?from=feed&amp;loc=nickname\" target=\"_blank\" rel=\"external\">J-Knight</a> 童鞋准备的面试题，针对你的题目，写一篇答案，有些唐突，望见谅。</p>\n<p>在整理这篇答案的时候，借鉴了很多网上的资料，很杂，也很难一一列出。</p>\n<p>但是关于<strong>MVC</strong> 和 <strong>MVVM</strong>，<strong>MVP</strong>模式的那篇，借鉴了阮一峰老师的一篇文章，写的浅显易懂，十分不错。</p>\n<p>链接在此：<a href=\"http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\" target=\"_blank\" rel=\"external\">MVC，MVP 和 MVVM 的图示</a></p>\n<p>还有喵神的关于<code>storyBoard</code>那篇</p>\n<p>链接在此：<a href=\"https://onevcat.com/2017/04/storyboard-argue/\" target=\"_blank\" rel=\"external\">再看关于 Storyboard 的一些争论</a></p>\n","excerpt":"此篇是根据知名博主 J-Knight 所提供的面试题目，所整理的答案，感谢 J-Knight 的分享，点击查看原文。 另外，我写此文的目的在于和广大的iOS开发者进行沟通交流，里面的内容有自己的理解，也有很大一部分参照网上的解释。很感谢之前的分享者，文末会附上相关的链接。如果在本文有理解不正确的地方，也希望大家多多指正。 面试题分为三个部分，我们先从基础开始。 基础1. 为什么说Objective-C是一门动态的语言？其实Objective-C是一门动态语言的用运行时Runtime可以更好地说明，但我看后面还有关于运行时的问题，在此处就先不展开了。 1. 动态类型：例如“id”类型，动态类型属于弱类型，在运行时才决定消息的接收者 2. 动态绑定：程序在运行时需要调用什么代码是在运行时决定的，而不是在编译时。 3. 动态载入：程序在运行时的代码模块以及相关资源是在运行时添加的，而不是启动时就加载所有资源 2.简要概括一下 MVC 和 MVVM，MVP三种模式。MVC","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"WWDC2016-Session724（APNS新特性）","date":"2017-06-12T05:11:20.000Z","path":"2017/06/12/WWDC2016-Session724（APNS新特性）/","text":"简要回顾 APNS是苹果的推送服务器，此篇主要讲一下2016年APNS的新特性 苹果的工程师上来就回顾了一下去年在APNS上所推出的改进，例如： 支持HTTP/2的API（采用二进制编码） 服务器通信可以做到及时响应 可以推送的文件内容扩展到了4KB 以及简化的证书管理 通过下图可以简要的看一下基于HTTP/2提供的API 客户端通过设备与APNS通信， APNS返回给客户端DeviceToken， 客户端将DeviceToken上传给我们自己的服务器。 接下来我们的服务器与APNS进行通信 每一次服务器将推送信息传递给APNS,都会附带一个DeviceToken的Request,同时APNS也会返回一个Response。 同时还简化了推送证书的管理，不论是开发环境还是发布环境，应用推送，VOIP推送以及并发推送，都用一个证书进行管理，大大的简化了流程 Token Authentication上文讲到，推送通知的时候会附带一个Token,接下来会讲这个Token认证的问题 新出的Token Authentication 简化了我们的推送服务器与APNS通信的过程 提高了安全性 创建Token很简单 不再有过多的过期证书 APNS不会在服务失效时关闭连接 每一次发送通知，都会附件一个客户端证书中的应用标识。 证书验证 和 Token验证结合上面的两张图，我们仔细的梳理一下证书验证和Token验证通信过程 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。 我们先来看看证书验证 通过开发者账号，生成一个证书 当Provider与APNS通信时，APNS会返回一个证书给Provider服务器。 Provider需要对这个证书签名并且信任，然后再将客户端证书返回给APNS。 此时APNS和Privider就构建了一个可信赖的通信通道。 再来看看Token验证 由我们的开发者账号生成一个Service Key，要包含你的Team ID,并且要为他签名 Service Key通过加密算法，生成一个加密后的Token 随后每一次Provider向APNS推送信息的时候，所发送的Request都必须有这个Token和推送的内容. 在Provider与APNS通信的过程中： 如果Token验证正确，那么接下来处理需要推送的部分，随后再返回状态码等相关信息。 如果Token验证失败，直接返回错误码信息。 构建 Token首先，到开着发中心创建一个 Service Key。 其次，利用Json Web Token构建Token。 上面一共是三个部分，每一个部分都是通过 base-64 编码过的 URL形式 12345// “alg”是加密方式，采用的是 ES256 加密// \"kid\"是 Key 的标识符，是用来给 Token 签名的// \"iss\"是Team ID 等团队信息// \"iat\"是初始化的时间戳// \"signature\"是针对上面的内容进行加密以后，再利用 Base64 加密 下图是使用HTTP/2构建的一个使用Token认证的请求下图是一个错误的Response 注意点 签名的Token需要不定期的生成，原则上是一小时，但考虑到性能因素，如果T欧肯有效就可以继续使用 Sign Key是不会失效的 如果Sign Key有错误，可以通过开发者中心进行撤销并重新创建 目前证书认证和Token认证两种方式同时有效","content":"<h2 id=\"简要回顾\"><a href=\"#简要回顾\" class=\"headerlink\" title=\"简要回顾\"></a>简要回顾</h2><blockquote>\n<p><code>APNS</code>是苹果的推送服务器，此篇主要讲一下2016年<code>APNS</code>的新特性</p>\n</blockquote>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-724/1.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>苹果的工程师上来就回顾了一下去年在<code>APNS</code>上所推出的改进，例如：</p>\n<ul>\n<li>支持<code>HTTP/2</code>的API（采用二进制编码）</li>\n<li>服务器通信可以做到及时响应</li>\n<li>可以推送的文件内容扩展到了4KB</li>\n<li>以及简化的证书管理</li>\n</ul>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-724/2.png\" alt=\"\"></p>\n<p>通过下图可以简要的看一下基于<code>HTTP/2</code>提供的<code>API</code></p>\n<ol>\n<li>客户端通过<code>设备</code>与<code>APNS</code>通信，</li>\n<li><code>APNS</code>返回给客户端<code>DeviceToken</code>，</li>\n<li>客户端将<code>DeviceToken</code>上传给我们自己的<code>服务器</code>。</li>\n<li>接下来我们的<code>服务器</code>与<code>APNS</code>进行通信</li>\n<li>每一次<code>服务器</code>将推送信息传递给<code>APNS</code>,都会附带一个<code>DeviceToken</code>的<code>Request</code>,同时<code>APNS</code>也会返回一个<code>Response</code>。</li>\n</ol>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-724/3.png\" alt=\"\"></p>\n<p>同时还简化了推送证书的管理，不论是<code>开发环境</code>还是<code>发布环境</code>，<code>应用推送</code>，<code>VOIP推送</code>以及<code>并发推送</code>，都用<code>一个证书</code>进行管理，大大的简化了流程</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-724/4.png\" alt=\"\"></p>\n<h2 id=\"Token-Authentication\"><a href=\"#Token-Authentication\" class=\"headerlink\" title=\"Token Authentication\"></a>Token Authentication</h2><p>上文讲到，推送通知的时候会附带一个<code>Token</code>,接下来会讲这个<code>Token</code>认证的问题</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-724/6.png\" alt=\"\"></p>\n<p>新出的<code>Token Authentication</code></p>\n<ol>\n<li>简化了我们的推送服务器与<code>APNS</code>通信的过程</li>\n<li>提高了安全性</li>\n<li>创建<code>Token</code>很简单</li>\n<li>不再有过多的<code>过期证书</code></li>\n<li><code>APNS</code>不会在服务失效时关闭连接</li>\n<li>每一次发送通知，都会附件一个客户端证书中的应用标识。</li>\n</ol>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-724/7.png\" alt=\"\"><br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-724/8.png\" alt=\"\"></p>\n<h3 id=\"证书验证-和-Token验证\"><a href=\"#证书验证-和-Token验证\" class=\"headerlink\" title=\"证书验证 和 Token验证\"></a>证书验证 和 Token验证</h3><p>结合上面的两张图，我们仔细的梳理一下<code>证书验证</code>和<code>Token验证</code>通信过程</p>\n<p> <strong>TLS</strong>（是“Transport Layer Security”的缩写），中文叫做“<strong>传输层安全协议</strong>”。</p>\n<p> 我们先来看看<strong>证书验证</strong></p>\n<ol>\n<li>通过<code>开发者账号</code>，生成一个<code>证书</code></li>\n<li>当<code>Provider</code>与<code>APNS</code>通信时，<code>APNS</code>会返回一个<code>证书</code>给<code>Provider</code>服务器。</li>\n<li><code>Provider</code>需要对这个<code>证书</code>签名并且信任，然后再将<code>客户端证书</code>返回给APNS。</li>\n<li>此时APNS和Privider就构建了一个可信赖的通信通道。</li>\n</ol>\n<p>再来看看<strong>Token验证</strong></p>\n<ol>\n<li>由我们的开发者账号生成一个<code>Service Key</code>，要包含你的<code>Team ID</code>,并且要为他签名</li>\n<li><code>Service Key</code>通过加密算法，生成一个加密后的<code>Token</code></li>\n</ol>\n<p>随后每一次<code>Provider</code>向<code>APNS</code>推送信息的时候，所发送的<code>Request</code>都必须有这个<code>Token</code>和<code>推送的内容</code>.</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-724/9.png\" alt=\"\"><br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-724/10.png\" alt=\"\"></p>\n<p>在<code>Provider</code>与<code>APNS</code>通信的过程中：</p>\n<ul>\n<li>如果Token验证正确，那么接下来处理需要推送的部分，随后再返回状态码等相关信息。</li>\n<li>如果Token验证失败，直接返回错误码信息。</li>\n</ul>\n<h2 id=\"构建-Token\"><a href=\"#构建-Token\" class=\"headerlink\" title=\"构建 Token\"></a>构建 Token</h2><p><strong>首先</strong>，到开着发中心创建一个 <code>Service Key</code>。<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-724/11.png\" alt=\"\"></p>\n<p><strong>其次</strong>，利用<code>Json Web Token</code>构建<code>Token</code>。<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-724/13.png\" alt=\"\"></p>\n<p>上面一共是三个部分，每一个部分都是通过 <code>base-64</code> 编码过的 <code>URL</code>形式</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//  “alg”是加密方式，采用的是 ES256 加密</span></div><div class=\"line\"><span class=\"comment\">//  \"kid\"是 Key 的标识符，是用来给 Token 签名的</span></div><div class=\"line\"><span class=\"comment\">//  \"iss\"是Team ID 等团队信息</span></div><div class=\"line\"><span class=\"comment\">//  \"iat\"是初始化的时间戳</span></div><div class=\"line\"><span class=\"comment\">//  \"signature\"是针对上面的内容进行加密以后，再利用 Base64 加密</span></div></pre></td></tr></table></figure>\n<p>下图是使用<code>HTTP/2</code>构建的一个使用<code>Token</code>认证的请求<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-724/14.png\" alt=\"\"><br>下图是一个错误的<code>Response</code><br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-724/15.png\" alt=\"\"><br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-724/16.png\" alt=\"\"></p>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><ol>\n<li>签名的Token需要不定期的生成，原则上是一小时，但考虑到性能因素，如果T欧肯有效就可以继续使用</li>\n<li><code>Sign Key</code>是不会失效的</li>\n<li>如果<code>Sign Key</code>有错误，可以通过<code>开发者中心</code>进行撤销并重新创建</li>\n<li>目前<code>证书认证</code>和<code>Token认证</code>两种方式同时有效</li>\n</ol>\n","excerpt":"简要回顾 APNS是苹果的推送服务器，此篇主要讲一下2016年APNS的新特性","categories":[],"tags":[{"name":"WWDC Session 2016","slug":"WWDC-Session-2016","permalink":"http://yoursite.com/tags/WWDC-Session-2016/"}]},{"title":"WWDC2016-Session708（高级通知）","date":"2017-06-09T03:28:49.000Z","path":"2017/06/09/WWDC2016-Session708（高级通知）/","text":"此篇我们接着Session 707接着讲,有兴趣的可以查看 : http://xiaolu520.com/2017/06/08/WWDC2016-Session707%EF%BC%88UNNotifications%EF%BC%89/ 概览 本篇主要是对UNNotification框架的扩展，以及一些高级功能的实现 主要讲三个部分 通知的用户界面多种多样。 通知可以支持附件 用户针对界面、交互的自定义 通知用户界面的多种多样iOS 10新推出的通知框架可以实现十分丰富的推送效果，可以实现图片、视频、音频、Gif动态图片的效果，同时可以实现快捷回复，自定义用户交互等一系列酷炫的效果。此处就不上图了。 通知的媒体附件 上一篇我们了解了一个全新的十分重要的概念 Service Extension。此篇会使用Service Extension来完成一些重要的功能。 众所周知，iOS的通知在改版之后支持最大的推送容量仅仅才4KB，我们想依靠推送通知实现音视频的展示显然是不切实际的，这时候我们就要用到 Service Extension。 媒体附件支持本地通知和远程通知，可以支持图片、视频、音频、Gif动态图片，而这些媒体资源会在系统内存中单独开辟出的一块儿空间存放，无需开发者进行管理，需要使用的时候，可以申请读取。 在通知推送到用户设备之前，我们需要标明这个推送的内容是可变的，同时将附件以链接的形式给my-attachment属性赋值，代码如下： 1234567&#123; aps: &#123; alert: &#123; … &#125;, mutable-content: 1 &#125; my-attachment: \"https://example.com/photo.jpg\"&#125; 在Service Extension中，可以对附件的链接进行下载操作。这样就可以实现通过Extension实现下载操作。 12345678910Public class notificationService:UNNotificationServiceExtension &#123; override public func didreceive(request:UNNotificationRequest,withContentHandler contentHandler: (UNNotificationContent) -&gt; Void)&#123; let fileURL = \"www.baidu.com\" let attachment = UNNotificationAttachment(identifier: \"image\" ,url: fileURL,options: nil) let content = request.content.mutableCopy as! UNMutableNotificationContent content.attachments = [ attachment ] contentHandler(content)&#125; 通过以上的步骤即可实现，通过Service Extension下载附件并显示出来的功能。 自定义通知样式那么针对通知的样式，我们可能会有这样或者那样的需求，我们希望通知的风格和我们的App风格一致，那么这个时候，我们就要自定义通知的UI样式。 想实现通知的自定义样式，我们会需要 通知内容的扩展（Notiﬁcation content extension） 自定义的View 无需用户交互 针对通知可以触发相应的动作 首先创建一个Notification Content 通过代码，我们就知道这个Notification Extension继承自UIViewController,其实就是VC那一层。我们一共会得到三个文件。一个VC文件，一个StoryBoard的图形化界面文件还有一个info.plist的配置文件。 VC文件中只有一个遵守UINotificationContentExtension协议的didReceive方法是必须实现的,这个方法随着通知被发送到Extension,当用户展开通知时需要更新UI,随视图控制器的生命周期方法被一起调用，通过这个方法我们获取到具体的通知，得到通知的内容以及其他信息，从而也就可以进行接下来的操作. 为了让Notification Extension知道具体是哪个通知该被扩展，你需要在info.plist文件中，对Notification Extension Category进行注册，此时注册所用的Identifier,应该和你发送通知时所用的identifier一致，这样就将这个Extension和你的Notification绑定了,当然扩展也可以关联多个类型。 如下图： 在自定义通知的过程中，会碰到一些问题： 例如，显示范围过大，或者通知会显示重复的信息。 要解决通知会显示重复的信息，这个只需要在info.plist中将默认的属性值修改了就可以。 而为了解决显示区域过大，我们要修改显示区域的范围，通过PreferedContentSize可以做到，我们可以按照自己的需要设定一个范围。但是这样还会有另外一个问题，就是通知默认是按照大尺寸出现的，出现后的一瞬间再按照PreferedContentSize所给的尺寸去更新UI，为了避免出现这种动画，只需修改另一个属性UNNotificationExtensionDefaultContentHidden。 UNNotificationExtensionDefaultContentHidden这个属性，可以保证通知界面一开始不出现，知道改为合适的尺寸直接出现，这样做就避免了通知出现一瞬间，还要更新UI。 PreferedContentSize我们需要在代理方法中自己用代码设定，也可以在info.plist利用UNNotificationExtensionInitialContentSizeRatio设置区域。 12345678910Public class notificationService:UNNotificationServiceExtension &#123; override func viewDidLoad() &#123; super.viewDidLoad() &#123; let size = view.bounds.size preferredContentSize = CGSize(width: size.width, height: size.width / 2) &#125; override public func didreceive(request:UNNotificationRequest,withContentHandler contentHandler: (UNNotificationContent) -&gt; Void)&#123; &#125; 展示通知的媒体附件我们知道通知的媒体附件被系统单独的开辟出一块儿内存空间所管理，所以当我们想要使用的时候，我们要申请读取，访问结束后要将空间关闭 1234567891011121314151617181920class NotificationViewController: UIViewController, UNNotificationContentExtension &#123; @IBOutlet var eventImage: UIImageView! func didReceive(_ notification: UNNotification) &#123; let content = notification.request.content if let attachment = content.attachments.first &#123; // 使用时申请访问 if attachment.url.startAccessingSecurityScopedResource() &#123; eventImage.image = UIImage(contentsOfFile: attachment.url.path!) // 用完了需要关闭 attachment.url.stopAccessingSecurityScopedResource() &#125; &#125; &#125;&#125; 通过通知我们可以与用户互动，用户点击了不同的选项，我们可以有不同的行为，例如接受或者拒绝。 1234567891011121314151617181920class NotificationViewController: UIViewController, UNNotificationContentExtension&#123; func didReceive(_ response: UNNotificationResponse, completionHandler done: (UNNotificationContentExtensionResponseOption) -&gt; Void) &#123; server.postEventResponse(response.actionIdentifier) &#123; if response.actionIdentifier == \"accept\" &#123; eventResponse.text = \"Going!\" eventResponse.textColor = UIColor.green() &#125; else if response.actionIdentifier == \"decline\" &#123; eventResponse.text = \"Not going :(\" eventResponse.textColor = UIColor.red() &#125; done(.dismiss) &#125; &#125;&#125; 同时也允许用户进行输入操作，同时还增加了PlaceHolder 1234567891011121314151617181920212223242526272829 private func makeEventExtensionCategory() -&gt; UNNotificationCategory &#123; let commentAction = UNTextInputNotificationAction( identifier: \"comment\", title: \"Comment\", options: [], textInputButtonTitle: \"Send\", textInputPlaceholder: \"Type here…\") return UNNotificationCategory(identifier: \"event-invite\", actions: [ acceptAction, declineAction, commentAction ], minimalActions: [ acceptAction, declineAction ], intentIdentifiers: [], options: [])&#125; // 点击后 class NotificationViewController: UIViewController, UNNotificationContentExtension &#123; func didReceive(_ response: UNNotificationResponse, completionHandler done: (UNNotificationContentExtensionResponseOption) -&gt; Void) &#123; if let textResponse = response as? UNTextInputNotificationResponse &#123; server.send(textResponse.userText) &#123; done(.dismiss) &#125; &#125; &#125;&#125; 还可以自定义inputView 123456789101112131415161718192021222324 class NotificationViewController: UIViewController, UNNotificationContentExtension // 判断能否成为第一响应者 override func canBecomeFirstResponder() -&gt; Bool &#123; return true &#125; // 重写inputView override var inputAccessoryView: UIView &#123; get &#123; return inputView &#125; &#125; func didReceive(_ response: UNNotificationResponse, completionHandler done: (UNNotificationContentExtensionResponseOption) -&gt; Void) &#123; if response.actionIdentifier == \"comment\" &#123; becomeFirstResponder() textField.becomeFirstResponder() &#125; &#125;&#125;","content":"<p>此篇我们接着<code>Session 707</code>接着讲,有兴趣的可以查看 : <a href=\"http://xiaolu520.com/2017/06/08/WWDC2016-Session707%EF%BC%88UNNotifications%EF%BC%89/\" target=\"_blank\" rel=\"external\">http://xiaolu520.com/2017/06/08/WWDC2016-Session707%EF%BC%88UNNotifications%EF%BC%89/</a></p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-708/1.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><blockquote>\n<p>本篇主要是对<code>UNNotification</code>框架的扩展，以及一些高级功能的实现</p>\n</blockquote>\n<p><strong>主要讲三个部分</strong></p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-708/2.png\" alt=\"\"></p>\n<ul>\n<li>通知的用户界面多种多样。</li>\n<li>通知可以支持附件</li>\n<li>用户针对界面、交互的自定义</li>\n</ul>\n<h2 id=\"通知用户界面的多种多样\"><a href=\"#通知用户界面的多种多样\" class=\"headerlink\" title=\"通知用户界面的多种多样\"></a>通知用户界面的多种多样</h2><p><code>iOS 10</code>新推出的通知框架可以实现十分丰富的推送效果，可以实现<code>图片</code>、<code>视频</code>、<code>音频</code>、<code>Gif动态图片</code>的效果，同时可以实现<code>快捷回复</code>，<code>自定义用户交互</code>等一系列酷炫的效果。此处就不上图了。</p>\n<h2 id=\"通知的媒体附件\"><a href=\"#通知的媒体附件\" class=\"headerlink\" title=\"通知的媒体附件\"></a>通知的媒体附件</h2><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-708/5.png\" alt=\"\"></p>\n<blockquote>\n<p>上一篇我们了解了一个全新的十分重要的概念 <code>Service Extension</code>。此篇会使用<code>Service Extension</code>来完成一些重要的功能。</p>\n</blockquote>\n<p>众所周知，<code>iOS</code>的通知在改版之后支持最大的推送容量仅仅才<code>4KB</code>，我们想依靠推送通知实现音视频的展示显然是不切实际的，这时候我们就要用到 <code>Service Extension</code>。</p>\n<p><code>媒体附件</code>支持<code>本地通知</code>和<code>远程通知</code>，可以支持<code>图片</code>、<code>视频</code>、<code>音频</code>、<code>Gif动态图片</code>，而这些媒体资源会在系统内存中<code>单独开辟</code>出的一块儿空间存放，无需开发者进行管理，需要使用的时候，可以申请读取。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-708/3.png\" alt=\"\"></p>\n<p>在通知推送到用户设备之前，我们需要标明这个推送的内容是<code>可变</code>的，同时将附件以<code>链接</code>的形式给<code>my-attachment</code>属性赋值，代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    aps: &#123;</div><div class=\"line\">        alert: &#123; … &#125;,</div><div class=\"line\">        <span class=\"keyword\">mutable</span>-content: <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    my-attachment: <span class=\"string\">\"https://example.com/photo.jpg\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在<code>Service Extension</code>中，可以对<code>附件的链接</code>进行下载操作。这样就可以实现通过<code>Extension</code>实现下载操作。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-708/4.png\" alt=\"\"></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">Public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">notificationService</span>:<span class=\"title\">UNNotificationServiceExtension</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didreceive</span><span class=\"params\">(request:UNNotificationRequest,withContentHandler contentHandler: <span class=\"params\">(UNNotificationContent)</span></span></span> -&gt; <span class=\"type\">Void</span>)&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">let</span> fileURL = <span class=\"string\">\"www.baidu.com\"</span></div><div class=\"line\">    <span class=\"keyword\">let</span> attachment = <span class=\"type\">UNNotificationAttachment</span>(identifier: <span class=\"string\">\"image\"</span> ,url: fileURL,options: <span class=\"literal\">nil</span>)</div><div class=\"line\">    <span class=\"keyword\">let</span> content = request.content.mutableCopy <span class=\"keyword\">as</span>! <span class=\"type\">UNMutableNotificationContent</span></div><div class=\"line\">    content.attachments = [ attachment ]</div><div class=\"line\">    contentHandler(content)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过以上的步骤即可实现，通过<code>Service Extension</code>下载附件并显示出来的功能。</p>\n<h2 id=\"自定义通知样式\"><a href=\"#自定义通知样式\" class=\"headerlink\" title=\"自定义通知样式\"></a>自定义通知样式</h2><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-708/6.png\" alt=\"\"><br>那么针对通知的样式，我们可能会有这样或者那样的需求，我们希望通知的风格和我们的App风格一致，那么这个时候，我们就要自定义通知的<code>UI样式</code>。</p>\n<p>想实现通知的自定义样式，我们会需要</p>\n<ul>\n<li>通知内容的扩展（Notiﬁcation content extension）</li>\n<li>自定义的View</li>\n<li>无需用户交互</li>\n<li>针对通知可以触发相应的动作</li>\n</ul>\n<p>首先创建一个<code>Notification Content</code></p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-708/7.png\" alt=\"\"></p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-708/8.png\" alt=\"\"></p>\n<blockquote>\n<p>通过代码，我们就知道这个<code>Notification Extension</code>继承自<code>UIViewController</code>,其实就是<code>VC</code>那一层。我们一共会得到三个文件。一个<code>VC</code>文件，一个<code>StoryBoard</code>的图形化界面文件还有一个<code>info.plist</code>的配置文件。</p>\n<p><code>VC</code>文件中只有一个遵守<code>UINotificationContentExtension</code>协议的<code>didReceive</code>方法是必须实现的,这个方法随着通知被发送到<code>Extension</code>,当用户展开通知时需要更新UI,<code>随视图控制器的生命周期</code>方法被一起调用，通过这个方法我们获取到具体的<code>通知</code>，得到<code>通知的内容</code>以及其他信息，从而也就可以进行接下来的操作.</p>\n</blockquote>\n<p>为了让<code>Notification Extension</code>知道具体是哪个通知该被扩展，你需要在<code>info.plist</code>文件中，对<code>Notification Extension Category</code>进行注册，此时注册所用的<code>Identifier</code>,应该和你发送通知时所用的<code>identifier</code>一致，这样就将这个<code>Extension</code>和你的<code>Notification</code>绑定了,当然扩展也可以关联多个类型。</p>\n<p>如下图：</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-708/9.png\" alt=\"\"></p>\n<p>在自定义通知的过程中，会碰到一些问题：</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-708/10.png\" alt=\"\"></p>\n<p>例如，显示范围过大，或者通知会显示重复的信息。</p>\n<p>要解决通知会显示重复的信息，这个只需要在<code>info.plist</code>中将默认的属性值修改了就可以。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-708/11.png\" alt=\"\"></p>\n<p>而为了解决显示区域过大，我们要修改显示区域的范围，通过<code>PreferedContentSize</code>可以做到，我们可以按照自己的需要设定一个范围。但是这样还会有另外一个问题，就是通知默认是按照大尺寸出现的，出现后的一瞬间再按照<code>PreferedContentSize</code>所给的尺寸去更新UI，为了避免出现这种动画，只需修改另一个属性<code>UNNotificationExtensionDefaultContentHidden</code>。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-708/13.png\" alt=\"\"></p>\n<p><code>UNNotificationExtensionDefaultContentHidden</code>这个属性，可以保证通知界面一开始不出现，知道改为合适的尺寸直接出现，这样做就避免了通知出现一瞬间，还要更新UI。</p>\n<p><code>PreferedContentSize</code>我们需要在代理方法中自己用代码设定，也可以在<code>info.plist</code>利用<code>UNNotificationExtensionInitialContentSizeRatio</code>设置区域。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">Public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">notificationService</span>:<span class=\"title\">UNNotificationServiceExtension</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123; <span class=\"keyword\">super</span>.viewDidLoad() &#123;</div><div class=\"line\">    </div><div class=\"line\">        <span class=\"keyword\">let</span> size = view.bounds.size preferredContentSize = <span class=\"type\">CGSize</span>(width: size.width, height: size.width / <span class=\"number\">2</span>)</div><div class=\"line\">    </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didreceive</span><span class=\"params\">(request:UNNotificationRequest,withContentHandler contentHandler: <span class=\"params\">(UNNotificationContent)</span></span></span> -&gt; <span class=\"type\">Void</span>)&#123;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-708/12.png\" alt=\"\"></p>\n<h2 id=\"展示通知的媒体附件\"><a href=\"#展示通知的媒体附件\" class=\"headerlink\" title=\"展示通知的媒体附件\"></a>展示通知的媒体附件</h2><p>我们知道通知的媒体附件被系统单独的开辟出一块儿内存空间所管理，所以当我们想要使用的时候，我们要申请读取，访问结束后要将空间关闭</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NotificationViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UNNotificationContentExtension</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">var</span> eventImage: <span class=\"type\">UIImageView</span>!</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceive</span><span class=\"params\">(<span class=\"number\">_</span> notification: UNNotification)</span></span> &#123; </div><div class=\"line\">    </div><div class=\"line\">        <span class=\"keyword\">let</span> content = notification.request.content</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> attachment = content.attachments.first &#123; </div><div class=\"line\">            <span class=\"comment\">// 使用时申请访问</span></div><div class=\"line\">            <span class=\"keyword\">if</span> attachment.url.startAccessingSecurityScopedResource()</div><div class=\"line\">            &#123;</div><div class=\"line\">                eventImage.image = <span class=\"type\">UIImage</span>(contentsOfFile: attachment.url.path!)</div><div class=\"line\">                <span class=\"comment\">// 用完了需要关闭</span></div><div class=\"line\">                attachment.url.stopAccessingSecurityScopedResource()</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过<code>通知</code>我们可以与用户互动，用户点击了不同的选项，我们可以有不同的行为，例如<code>接受</code>或者<code>拒绝</code>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NotificationViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UNNotificationContentExtension</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceive</span><span class=\"params\">(<span class=\"number\">_</span> response: UNNotificationResponse, completionHandler done: <span class=\"params\">(UNNotificationContentExtensionResponseOption)</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">        server.postEventResponse(response.actionIdentifier) </div><div class=\"line\">        &#123; </div><div class=\"line\">            <span class=\"keyword\">if</span> response.actionIdentifier == <span class=\"string\">\"accept\"</span></div><div class=\"line\">            &#123;</div><div class=\"line\">                eventResponse.text = <span class=\"string\">\"Going!\"</span> </div><div class=\"line\">                eventResponse.textColor = <span class=\"type\">UIColor</span>.green() </div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>  response.actionIdentifier == <span class=\"string\">\"decline\"</span> </div><div class=\"line\">            &#123;</div><div class=\"line\">                eventResponse.text = <span class=\"string\">\"Not going :(\"</span> </div><div class=\"line\">                eventResponse.textColor = <span class=\"type\">UIColor</span>.red()</div><div class=\"line\">            &#125;</div><div class=\"line\">            done(.dismiss)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同时也允许用户进行<strong>输入操作</strong>，同时还增加了<code>PlaceHolder</code></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeEventExtensionCategory</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">UNNotificationCategory</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">let</span> commentAction = <span class=\"type\">UNTextInputNotificationAction</span>( identifier: <span class=\"string\">\"comment\"</span>,</div><div class=\"line\">                                                                title: <span class=\"string\">\"Comment\"</span>,</div><div class=\"line\">                                                              options: [],</div><div class=\"line\">                                                 textInputButtonTitle: <span class=\"string\">\"Send\"</span>, </div><div class=\"line\">                                                 textInputPlaceholder: <span class=\"string\">\"Type here…\"</span>)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UNNotificationCategory</span>(identifier: <span class=\"string\">\"event-invite\"</span>,</div><div class=\"line\">                                         actions: [ acceptAction, declineAction, commentAction ], </div><div class=\"line\">                                  minimalActions: [ acceptAction, declineAction ], </div><div class=\"line\">                               intentIdentifiers: [], </div><div class=\"line\">                                         options: [])</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//  点击后</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NotificationViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UNNotificationContentExtension</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceive</span><span class=\"params\">(<span class=\"number\">_</span> response: UNNotificationResponse, completionHandler done: <span class=\"params\">(UNNotificationContentExtensionResponseOption)</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> textResponse = response <span class=\"keyword\">as</span>? <span class=\"type\">UNTextInputNotificationResponse</span></div><div class=\"line\">        &#123;</div><div class=\"line\">            server.send(textResponse.userText) </div><div class=\"line\">            &#123;</div><div class=\"line\">                done(.dismiss)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还可以自定义<code>inputView</code></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NotificationViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UNNotificationContentExtension</span> </span></div><div class=\"line\">    </div><div class=\"line\">    // 判断能否成为第一响应者</div><div class=\"line\">    <span class=\"title\">override</span> <span class=\"title\">func</span> <span class=\"title\">canBecomeFirstResponder</span>() -&gt; <span class=\"title\">Bool</span> &#123; </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span> </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 重写inputView</span></div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">var</span> inputAccessoryView: <span class=\"type\">UIView</span> &#123;</div><div class=\"line\">         <span class=\"keyword\">get</span> &#123; </div><div class=\"line\">            <span class=\"keyword\">return</span> inputView </div><div class=\"line\">         &#125; </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceive</span><span class=\"params\">(<span class=\"number\">_</span> response: UNNotificationResponse, completionHandler done: <span class=\"params\">(UNNotificationContentExtensionResponseOption)</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> response.actionIdentifier == <span class=\"string\">\"comment\"</span> </div><div class=\"line\">        &#123;</div><div class=\"line\">            becomeFirstResponder()</div><div class=\"line\">            textField.becomeFirstResponder()</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"此篇我们接着Session 707接着讲,有兴趣的可以查看 : http://xiaolu520.com/2017/06/08/WWDC2016-Session707%EF%BC%88UNNotifications%EF%BC%89/","categories":[],"tags":[{"name":"WWDC Session 2016","slug":"WWDC-Session-2016","permalink":"http://yoursite.com/tags/WWDC-Session-2016/"}]},{"title":"WWDC2016-Session707（UNNotifications）","date":"2017-06-08T06:15:20.000Z","path":"2017/06/08/WWDC2016-Session707（UNNotifications）/","text":"UNNotifications是WWDC2016基于之前的推送服务，推出的全新的的通知框架。 概览 此课程主要分为两大部分。 全新的 User Notifictions 框架 通知的注册 构建通知的内容 通知的排期 通知的管理 通知触发的动作 服务的扩展 还有一些更深入的知识，可以等我的下一篇文章。 通知的样式通知的样式有三种 可见的提示框 声音和震动 App图标角标 通知的类型通知的类型可以分为两类 本地通知 远程通知 本地通知本地通知是自身触发的 我们App按照一定规则对系统进行排期，当触发条件达成，就会发出本地通知。 可以触发本地通知的行为有以下三种 任务通知 日期通知 基于定位的通知 远程通知讲远程通知，首先要知道远程通知的原理。 通过上面这张图，理解起来会比较轻松 我们的iOS设备和苹果的APNS服务器一直保持着一个长连接，我们将App注册通知后，设备与 APNS 服务器通信，由 APNS 服务器返回设备一个Token，随后这个Token被上传到我们所需要使用的推送服务器上。之后当我们需要向设备上推送的时候，我们的推送服务器直接把要推送的内容和Token发送给APNS，APNS就可以把信息准确、快速的推送到指定的设备上。 APNS远程通知可以被用于以下场景 新闻标题 即时通讯 信息的实时更新等。。。 远程通知实际上也分为两种 显式的远程通知显式的远程通知是设备接到通知之后，会显示在用户的设备界面上，用户可以直观的看 隐式的远程通知隐式的远程通知是App在后台时，接收到隐式的远程通知，此时并不会调起程序，而是程序在后台发起请求，更新数据，当用户下一次主动点击，进入App后，直接显示的就是已经更新好数据的页面。 iOS 10 之前通知存在的问题 注册繁琐 本地通知和远程通知要写不同的代码 通知被排期之后管理就变得困难 不同平台，通知的区别比较大 User Notifications Framework基于之前通知平台所存在的问题和不足，WWDC-2016 推出了全新的通知架构 User Notifications Framework。 通过上图我们可以简要的概括一下这个新框架 和之前几乎相同的API。 内容扩展（支持标题、子标题、内容以及音视频附件）。 本地通知、远程通知的代码可以只写一份。 更简单的代理方法。 针对通知的管理比以前更加优化（可更新、撤销）。 在拓展中对通知进行排期和操作。 通知的拓展（可在通知到达设备之前利用 Notification Service 进行操作）！ 新的User Notifications Framework框架可以全平台支持 其中iOS平台支持全部的新特性 WatchOS平台，可以实现不依靠iOS设备转发，直接实现本地通知（例如 实现运动目标、定时通知等）。 TV OS支持角标，可以实现一些特定的提醒通知。 推送流程推送的流程基本如图所示，下面一一展开来说 1.配置并获取许可（Registration） 12345678910111213141516171819202122232425// 献上OC版本的代码-(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter]; [center requestAuthorizationWithOptions:UNAuthorizationOptionCarPlay | UNAuthorizationOptionSound | UNAuthorizationOptionBadge | UNAuthorizationOptionAlert completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; if (granted) &#123; NSLog(@\" iOS 10 request notification success\"); &#125; else &#123; NSLog(@\" iOS 10 request notification fail\"); &#125; &#125;]; [[UIApplication sharedApplication] registerForRemoteNotifications]; return YES; &#125; iOS 10 可以通过以下方法获取针对通知的用户配置，于是我们可以更加灵活的给用户发出提示 1234[[UNUserNotificationCenter currentNotificationCenter] getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) &#123; NSLog(@\"%@\",settings); &#125;]; 2.构建推送的内容（Content）1.针对本地通知，构建推送内容方式 123456// OC版本UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];content.title = @\"Introduction to Notification\";content.subtitle = @\"Session 707\";content.body = @\"lalalalala\";content.badge = 2; 2.针对远程通知，构建推送内容方式 3.通知触发（Triggers）触发一共有四种方式 基于APNS的推送任务 基于时间间隔的推送任务 基于日程、日历的推送任务 基于定位信息的推送任务 4.排期（Schedule）本地通知排期 远程通知排期 自此，前端的通知配置完毕 5.代码（code）1234567891011121314151617181920 import UserNotifications // 获取用户许可 UNUserNotificationCenter.current().requestAuthorization([.alert, .sound, .badge]) &#123; (granted, error) in ... &#125; // 构建推送内容 let content = UNMutableNotificationContent() content.title = \"Introduction to Notifications\" content.body = \"Let's talk about notifications!\" // 构建触发条件 let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false) // 构建推送请求 let requestIdentifier = \"sampleRequest\" let request = UNNotificationRequest(identifier: requestIdentifier, content: content, trigger: trigger) // 进行排期 UNUserNotificationCenter.current().add(request) &#123; (error) in // ... &#125; import UserNotifications Notifiction Handling（前台的通知处理）为了使我们的程序在前台时依然可以接收通知，我们可以通过实现 UNUserNotificationCenterDelegate 的代理方法，通过这个代理方法，我们可以获取到即将收到的通知，此时我们就可以在他的Handler回调中对其进行处理 如果没有传递参数，也就意味着不对其进行处理 Notifiction ManagementNotifiction Management允许开发者访问已经排期等待发出的通知，甚至可以管理用户已经收到了的通知。这包括本地通知和远程通知。 同时你也可以更新、提升或者删除已经发送给用户的通知。 其中有个很关键的要素就是请求识别符（RequestIdentifier），在本地通知中，它被设置在通知的请求对象上，在远程通知中，在 HTTP/2 有一个新的请求数据头 apns-collapse-id。 系统通过这个 RequestIdentifier 来得知是哪个通知 我们可以通过官方的示例，来简单的理解这个功能。 删除通知 12345678// 比赛开始时给一个标识符let gameStartIdentifier = \"game1.start.identifier\" let gameStartRequest = UNNotificationRequest(identifier: gameStartIdentifier, content: content, trigger: startTrigger)UNUserNotificationCenter.current().add(gameStartRequest) &#123; (error) in // ... &#125;// 因为发送了错误的信息，所可以直接取消通知，只要标识符一样即可（比赛结束也可以直接remove掉）UNUserNotificationCenter.current() .removePendingNotificationRequests(withIdentifiers: [gameStartIdentifier]) 更新通知 12345678910// 比赛开始时给一个标识符let gameStartIdentifier = \"game1.start.identifier\" let gameStartRequest = UNNotificationRequest(identifier: gameStartIdentifier, content: content, trigger: startTrigger)UNUserNotificationCenter.current().add(gameStartRequest) &#123; (error) in // ... &#125;// 比赛分数发生改变，需要更新通知，创建一个新的request，但是标识符要一样let updatedGameStartRequest = UNNotificationRequest(identifier: gameStartIdentifier, content: content, trigger: newStartTrigger)UNUserNotificationCenter.current().add(updatedGameStartRequest) &#123; (error) in // ... &#125; Notiﬁcation Actions1.默认行为（Default Action）通知可以在三个地方显示，锁屏页面，开锁后主屏幕，通知中心。 默认行为是点击通知后，直接进入程序 2.可操作行为（Actionable Notifications）可操作行为是接收到用户通知后，可进行一系列的交互操作，如下图 实现这种可以进行操作的通知需要给通知注册行为，实现代码如下 123456// 声明一个Actionlet action = UNNotificationAction(identifier:\"reply\",title:\"Reply\",options:[])// 声明一个Categorylet category = UNNotificationCategory(identifier: \"message\", actions: [action], minimalActions: [action], intentIdentifiers: [], options: [])// 将Category赋值给当前的通知中心即可UNUserNotificationCenter.current().setNotificationCategories([category]) 如果是远程通知的话，需要在推送的数据中加上Category,并且将Content的CategotrIdentifier赋值 123456789// Remote Notiﬁcations&#123; aps:&#123; alert:“Welcome to WWDC !”, category:\"message\" &#125; // Local Notiﬁcations content.categoryIdentifier = \"message\"&#125; 3.取消行为（Dismiss Action） 可以通过向左滑动通知，进行取消操作; 也可以在通知中心，点击x号 取消通知之后可以执行相关的操作，需要用到CustomerDismissAction,可以进行自定义的操作； 123customDismissAction: UNNotificationCategoryOptionslet category = UNNotificationCategory(identifier: \"message\", actions: [action], minimalActions: [action], intentIdentifiers: [], options: [.customDismissAction]) Actions Response我们有多种方法知道，用户是通过什么途径打开应用，在通知上做了什么操作，通知是什么类型等等。但是现在我们只需要实现一个代理方法就可以做到这些了 通过 delegate 的方法，我们可以得到一个response 和一个 handler 的Block回调 在 Response中我们可以得到actionIdentifier,如果用户有输入行为，我们可以得到输入的文本，以及具体的Notification。 在已得到的通知中，获取Request,再接下来就可以得到触发条件Trigger和通知内容Content。 然后我们在completionHandler回调中，进行相关的操作。 Service Extension Service Extension是通知的服务扩展，它不会在UI界面上进行展示，用于增强和替换显示到用户界面上的内容。 其原理是我们的推送服务器将推送的内容上传至APNS服务器，在APNS将消息推送到设备，在设备显示推送消息之前，我们有一段很短的时间，可以通过Extension进行回调执行相关的操作。 基于Service Extension，我们可以实现端到端加密以及添加附件和其他统一的操作。 我们大致走一下构建Service Extension的流程 1234567891011// Service Extensionimport UserNotificationsclass NotificationService: UNNotificationServiceExtension &#123; override func didReceive(request: UNNotificationRequest, withContentHandler contentHandler:(UNNotificationContent) -&gt; Void) &#123; // Modify the notification content &#125; override func serviceExtensionTimeWillExpire() &#123; // Called before the extension will be terminated by the system &#125;&#125; 示例代码 12345678910111213141516171819202122&#123; aps : &#123; alert : “New Message Available”, mutable-content : 1 &#125;, encrypted-content : “#myencryptedcontent”&#125;// Decrypt Remote Notification Payload in Service Extension and Update Notification Contentoverride func didReceive(request: UNNotificationRequest, withContentHandler contentHandler: (UNNotificationContent) -&gt; Void) &#123; // Decrypt the payload let decryptedBody = decrypt(request.content.userInfo[“encrypted-content”]) let newContent = UNMutableNotificationContent() // Modify the notification content newContent.body = decryptedBody // Call content handler with updated content contentHandler(newContent)&#125; 后面还有一篇高级通知的文章，地址。","content":"<p><code>UNNotifications</code>是<code>WWDC2016</code>基于之前的推送服务，推出的全新的的通知框架。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-01.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-02.png\" alt=\"\"></p>\n<p>此课程主要分为两大部分。</p>\n<ul>\n<li>全新的 <code>User Notifictions</code> 框架 <ul>\n<li>通知的注册</li>\n<li>构建通知的内容</li>\n<li>通知的排期</li>\n<li>通知的管理</li>\n<li>通知触发的动作</li>\n</ul>\n</li>\n<li>服务的扩展</li>\n</ul>\n<p>还有一些更深入的知识，可以等我的下一篇文章。</p>\n<h2 id=\"通知的样式\"><a href=\"#通知的样式\" class=\"headerlink\" title=\"通知的样式\"></a>通知的样式</h2><p>通知的样式有三种</p>\n<ul>\n<li>可见的提示框</li>\n<li>声音和震动</li>\n<li>App图标角标</li>\n</ul>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-03.png\" alt=\"\"></p>\n<h2 id=\"通知的类型\"><a href=\"#通知的类型\" class=\"headerlink\" title=\"通知的类型\"></a>通知的类型</h2><p>通知的类型可以分为两类</p>\n<ul>\n<li>本地通知</li>\n<li>远程通知</li>\n</ul>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-04.png\" alt=\"\"></p>\n<h3 id=\"本地通知\"><a href=\"#本地通知\" class=\"headerlink\" title=\"本地通知\"></a>本地通知</h3><p>本地通知是自身触发的<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-05.png\" alt=\"\"></p>\n<p>我们App按照一定规则对系统进行排期，当触发条件达成，就会发出本地通知。</p>\n<p>可以触发本地通知的行为有以下三种</p>\n<ul>\n<li>任务通知</li>\n<li>日期通知</li>\n<li>基于定位的通知</li>\n</ul>\n<h3 id=\"远程通知\"><a href=\"#远程通知\" class=\"headerlink\" title=\"远程通知\"></a>远程通知</h3><p>讲远程通知，首先要知道远程通知的原理。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/11.png\" alt=\"\"></p>\n<p>通过上面这张图，理解起来会比较轻松</p>\n<p>我们的<code>iOS</code>设备和苹果的<code>APNS</code>服务器一直保持着一个长连接，我们将<code>App注册</code>通知后，设备与 <code>APNS</code> 服务器通信，由 <code>APNS</code> 服务器返回设备一个<code>Token</code>，随后这个<code>Token</code>被上传到我们所需要使用的<code>推送服务器</code>上。之后当我们需要向设备上推送的时候，我们的<code>推送服务器</code>直接把要<code>推送的内容</code>和<code>Token</code>发送给<code>APNS</code>，<code>APNS</code>就可以把信息准确、快速的推送到指定的设备上。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-06.png\" alt=\"\"></p>\n<p><code>APNS</code>远程通知可以被用于以下场景</p>\n<ul>\n<li>新闻标题</li>\n<li>即时通讯</li>\n<li>信息的实时更新等。。。</li>\n</ul>\n<p>远程通知实际上也分为两种</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-07.png\" alt=\"\"></p>\n<p><strong>显式的远程通知</strong><br><code>显式的远程通知</code>是设备接到通知之后，会显示在用户的设备界面上，用户可以直观的看</p>\n<p><strong>隐式的远程通知</strong><br><code>隐式的远程通知</code>是App在后台时，接收到隐式的远程通知，此时并不会调起程序，而是程序在后台发起请求，更新数据，当用户下一次主动点击，进入App后，直接显示的就是已经更新好数据的页面。</p>\n<h2 id=\"iOS-10-之前通知存在的问题\"><a href=\"#iOS-10-之前通知存在的问题\" class=\"headerlink\" title=\"iOS 10 之前通知存在的问题\"></a>iOS 10 之前通知存在的问题</h2><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-08.png\" alt=\"\"></p>\n<ul>\n<li>注册繁琐</li>\n<li>本地通知和远程通知要写不同的代码</li>\n<li>通知被排期之后管理就变得困难</li>\n<li>不同平台，通知的区别比较大</li>\n</ul>\n<h2 id=\"User-Notifications-Framework\"><a href=\"#User-Notifications-Framework\" class=\"headerlink\" title=\"User Notifications Framework\"></a>User Notifications Framework</h2><p>基于之前通知平台所存在的问题和不足，<code>WWDC-2016</code> 推出了全新的通知架构 <code>User Notifications Framework</code>。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-09.png\" alt=\"\"><br>通过上图我们可以简要的概括一下这个新框架</p>\n<ul>\n<li>和之前几乎相同的API。</li>\n<li>内容扩展（支持标题、子标题、内容以及音视频附件）。</li>\n<li>本地通知、远程通知的代码可以只写一份。</li>\n<li>更简单的代理方法。</li>\n<li>针对通知的管理比以前更加优化（可更新、撤销）。</li>\n<li>在拓展中对通知进行排期和操作。</li>\n<li>通知的拓展（可在通知到达设备之前利用 Notification Service 进行操作）！</li>\n</ul>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/WWDC-2016-707-10.png\" alt=\"\"></p>\n<p>新的<code>User Notifications Framework</code>框架可以全平台支持</p>\n<ul>\n<li>其中<code>iOS</code>平台支持全部的新特性</li>\n<li><code>WatchOS</code>平台，可以实现不依靠<code>iOS设备转发</code>，直接实现<code>本地通知</code>（例如 实现运动目标、定时通知等）。</li>\n<li><code>TV OS</code>支持角标，可以实现一些特定的提醒通知。</li>\n</ul>\n<h2 id=\"推送流程\"><a href=\"#推送流程\" class=\"headerlink\" title=\"推送流程\"></a>推送流程</h2><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/15.png\" alt=\"\"><br>推送的流程基本如图所示，下面一一展开来说</p>\n<h3 id=\"1-配置并获取许可（Registration）\"><a href=\"#1-配置并获取许可（Registration）\" class=\"headerlink\" title=\"1.配置并获取许可（Registration）\"></a>1.配置并获取许可（Registration）</h3><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/12.png\" alt=\"\"></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 献上OC版本的代码</span></div><div class=\"line\">-(<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;  </div><div class=\"line\"> </div><div class=\"line\">    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter]; </div><div class=\"line\">     </div><div class=\"line\">    [center requestAuthorizationWithOptions:UNAuthorizationOptionCarPlay | </div><div class=\"line\">                                              UNAuthorizationOptionSound | </div><div class=\"line\">                                              UNAuthorizationOptionBadge | </div><div class=\"line\">                                              UNAuthorizationOptionAlert </div><div class=\"line\">                                              completionHandler:^(<span class=\"built_in\">BOOL</span> granted, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;  </div><div class=\"line\">    </div><div class=\"line\">           <span class=\"keyword\">if</span> (granted) </div><div class=\"line\">           &#123;  </div><div class=\"line\">               <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\" iOS 10 request notification success\"</span>);  </div><div class=\"line\">           &#125; </div><div class=\"line\">           <span class=\"keyword\">else</span> </div><div class=\"line\">           &#123;  </div><div class=\"line\">               <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\" iOS 10 request notification fail\"</span>);  </div><div class=\"line\">           &#125;  </div><div class=\"line\">    &#125;];  </div><div class=\"line\">    </div><div class=\"line\">     [[<span class=\"built_in\">UIApplication</span> sharedApplication] registerForRemoteNotifications]; </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>iOS 10</code> 可以通过以下方法获取针对通知的用户配置，于是我们可以更加灵活的给用户发出提示</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[UNUserNotificationCenter currentNotificationCenter] getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,settings);</div><div class=\"line\"> &#125;];</div></pre></td></tr></table></figure>\n<h3 id=\"2-构建推送的内容（Content）\"><a href=\"#2-构建推送的内容（Content）\" class=\"headerlink\" title=\"2.构建推送的内容（Content）\"></a>2.构建推送的内容（Content）</h3><p>1.针对<code>本地通知</code>，构建推送内容方式<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/13.png\" alt=\"\"></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// OC版本</span></div><div class=\"line\">UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];</div><div class=\"line\">content.title = <span class=\"string\">@\"Introduction to Notification\"</span>;</div><div class=\"line\">content.subtitle = <span class=\"string\">@\"Session 707\"</span>;</div><div class=\"line\">content.body = <span class=\"string\">@\"lalalalala\"</span>;</div><div class=\"line\">content.badge = <span class=\"number\">2</span>;</div></pre></td></tr></table></figure>\n<p>2.针对<code>远程通知</code>，构建推送内容方式<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/14.png\" alt=\"\"></p>\n<h3 id=\"3-通知触发（Triggers）\"><a href=\"#3-通知触发（Triggers）\" class=\"headerlink\" title=\"3.通知触发（Triggers）\"></a>3.通知触发（Triggers）</h3><p>触发一共有四种方式<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/16.png\" alt=\"\"></p>\n<ul>\n<li>基于<code>APNS</code>的推送任务</li>\n<li>基于<code>时间间隔</code>的推送任务</li>\n<li>基于<code>日程、日历</code>的推送任务</li>\n<li>基于<code>定位信息</code>的推送任务</li>\n</ul>\n<h3 id=\"4-排期（Schedule）\"><a href=\"#4-排期（Schedule）\" class=\"headerlink\" title=\"4.排期（Schedule）\"></a>4.排期（Schedule）</h3><p><strong>本地通知排期</strong><br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/17.png\" alt=\"\"></p>\n<p><strong>远程通知排期</strong><br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/18.png\" alt=\"\"></p>\n<p>自此，前端的通知配置完毕</p>\n<h3 id=\"5-代码（code）\"><a href=\"#5-代码（code）\" class=\"headerlink\" title=\"5.代码（code）\"></a>5.代码（code）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">    </div><div class=\"line\"><span class=\"keyword\">import</span> UserNotifications</div><div class=\"line\">       </div><div class=\"line\">    <span class=\"comment\">// 获取用户许可</span></div><div class=\"line\">    <span class=\"type\">UNUserNotificationCenter</span>.current().requestAuthorization([.alert, .sound, .badge]) &#123; (granted, error) <span class=\"keyword\">in</span>  ... &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 构建推送内容  </span></div><div class=\"line\">    <span class=\"keyword\">let</span> content = <span class=\"type\">UNMutableNotificationContent</span>() </div><div class=\"line\">    content.title = <span class=\"string\">\"Introduction to Notifications\"</span> </div><div class=\"line\">    content.body = <span class=\"string\">\"Let's talk about notifications!\"</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 构建触发条件  </span></div><div class=\"line\">    <span class=\"keyword\">let</span> trigger = <span class=\"type\">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class=\"number\">5</span>, repeats: <span class=\"literal\">false</span>)</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 构建推送请求   </span></div><div class=\"line\">    <span class=\"keyword\">let</span> requestIdentifier = <span class=\"string\">\"sampleRequest\"</span> </div><div class=\"line\">    <span class=\"keyword\">let</span> request = <span class=\"type\">UNNotificationRequest</span>(identifier: requestIdentifier, content: content, trigger: trigger)</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 进行排期</span></div><div class=\"line\">    <span class=\"type\">UNUserNotificationCenter</span>.current().add(request) &#123; (error) <span class=\"keyword\">in</span> <span class=\"comment\">// ... &#125; import UserNotifications</span></div></pre></td></tr></table></figure>\n<h2 id=\"Notifiction-Handling（前台的通知处理）\"><a href=\"#Notifiction-Handling（前台的通知处理）\" class=\"headerlink\" title=\"Notifiction Handling（前台的通知处理）\"></a>Notifiction Handling（前台的通知处理）</h2><p>为了使我们的程序在前台时依然可以接收通知，我们可以通过实现 <code>UNUserNotificationCenterDelegate</code> 的代理方法，通过这个代理方法，我们可以获取到即将收到的<code>通知</code>，此时我们就可以在他的<code>Handler回调</code>中对其进行处理</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/19.png\" alt=\"\"></p>\n<p>如果没有传递参数，也就意味着不对其进行处理</p>\n<h2 id=\"Notifiction-Management\"><a href=\"#Notifiction-Management\" class=\"headerlink\" title=\"Notifiction Management\"></a>Notifiction Management</h2><p><code>Notifiction Management</code>允许开发者访问已经排期等待发出的<code>通知</code>，甚至可以管理用户已经收到了的<code>通知</code>。这包括<code>本地通知</code>和<code>远程通知</code>。</p>\n<p>同时你也可以<code>更新、提升或者删除</code>已经发送给用户的通知。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/20.png\" alt=\"\"></p>\n<p>其中有个很关键的要素就是<code>请求识别符（RequestIdentifier）</code>，在<strong>本地通知</strong>中，它被设置在通知的请求对象上，在<strong>远程通知</strong>中，在 <code>HTTP/2</code> 有一个新的请求数据头 <code>apns-collapse-id</code>。</p>\n<p>系统通过这个 <code>RequestIdentifier</code> 来得知是哪个通知</p>\n<p>我们可以通过官方的示例，来简单的理解这个功能。</p>\n<ul>\n<li>删除通知</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 比赛开始时给一个标识符</span></div><div class=\"line\"><span class=\"keyword\">let</span> gameStartIdentifier = <span class=\"string\">\"game1.start.identifier\"</span> </div><div class=\"line\"><span class=\"keyword\">let</span> gameStartRequest = <span class=\"type\">UNNotificationRequest</span>(identifier: gameStartIdentifier, content: content, trigger: startTrigger)</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().add(gameStartRequest) &#123; (error) <span class=\"keyword\">in</span> <span class=\"comment\">// ... &#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 因为发送了错误的信息，所可以直接取消通知，只要标识符一样即可（比赛结束也可以直接remove掉）</span></div><div class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current() .removePendingNotificationRequests(withIdentifiers: [gameStartIdentifier])</div></pre></td></tr></table></figure>\n<ul>\n<li>更新通知</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 比赛开始时给一个标识符</span></div><div class=\"line\"><span class=\"keyword\">let</span> gameStartIdentifier = <span class=\"string\">\"game1.start.identifier\"</span> </div><div class=\"line\"><span class=\"keyword\">let</span> gameStartRequest = <span class=\"type\">UNNotificationRequest</span>(identifier: gameStartIdentifier, content: content, trigger: startTrigger)</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().add(gameStartRequest) &#123; (error) <span class=\"keyword\">in</span> <span class=\"comment\">// ... &#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 比赛分数发生改变，需要更新通知，创建一个新的request，但是标识符要一样</span></div><div class=\"line\"><span class=\"keyword\">let</span> updatedGameStartRequest = <span class=\"type\">UNNotificationRequest</span>(identifier: gameStartIdentifier, content: content, trigger: newStartTrigger)</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().add(updatedGameStartRequest) &#123; (error) <span class=\"keyword\">in</span> <span class=\"comment\">// ... &#125;</span></div></pre></td></tr></table></figure>\n<h2 id=\"Notiﬁcation-Actions\"><a href=\"#Notiﬁcation-Actions\" class=\"headerlink\" title=\"Notiﬁcation Actions\"></a>Notiﬁcation Actions</h2><h3 id=\"1-默认行为（Default-Action）\"><a href=\"#1-默认行为（Default-Action）\" class=\"headerlink\" title=\"1.默认行为（Default Action）\"></a>1.默认行为（Default Action）</h3><p>通知可以在三个地方显示，<code>锁屏页面</code>，<code>开锁后主屏幕</code>，<code>通知中心</code>。</p>\n<p><code>默认行为</code>是点击通知后，直接进入程序</p>\n<h3 id=\"2-可操作行为（Actionable-Notifications）\"><a href=\"#2-可操作行为（Actionable-Notifications）\" class=\"headerlink\" title=\"2.可操作行为（Actionable Notifications）\"></a>2.可操作行为（Actionable Notifications）</h3><p><code>可操作行为</code>是接收到用户通知后，可进行一系列的交互操作，如下图</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/21.png\" alt=\"\"></p>\n<p>实现这种可以进行操作的通知需要给通知注册行为，实现代码如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 声明一个Action</span></div><div class=\"line\"><span class=\"keyword\">let</span> action = <span class=\"type\">UNNotificationAction</span>(identifier:<span class=\"string\">\"reply\"</span>,title:<span class=\"string\">\"Reply\"</span>,options:[])</div><div class=\"line\"><span class=\"comment\">// 声明一个Category</span></div><div class=\"line\"><span class=\"keyword\">let</span> category = <span class=\"type\">UNNotificationCategory</span>(identifier: <span class=\"string\">\"message\"</span>, actions: [action], minimalActions: [action], intentIdentifiers: [], options: [])</div><div class=\"line\"><span class=\"comment\">// 将Category赋值给当前的通知中心即可</span></div><div class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().setNotificationCategories([category])</div></pre></td></tr></table></figure>\n<p>如果是<code>远程通知的话</code>，需要在推送的数据中加上<code>Category</code>,并且将<code>Content</code>的<code>CategotrIdentifier</code>赋值</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Remote Notiﬁcations</span></div><div class=\"line\">&#123;</div><div class=\"line\">    aps:&#123;</div><div class=\"line\">             alert:“<span class=\"type\">Welcome</span> to <span class=\"type\">WWDC</span> !”,</div><div class=\"line\">             category:<span class=\"string\">\"message\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    <span class=\"comment\">// Local Notiﬁcations</span></div><div class=\"line\">    content.categoryIdentifier = <span class=\"string\">\"message\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-取消行为（Dismiss-Action）\"><a href=\"#3-取消行为（Dismiss-Action）\" class=\"headerlink\" title=\"3.取消行为（Dismiss Action）\"></a>3.取消行为（Dismiss Action）</h3><ul>\n<li>可以通过向左滑动通知，进行取消操作;</li>\n<li>也可以在通知中心，点击<code>x</code>号</li>\n</ul>\n<p>取消通知之后可以执行相关的操作，需要用到<code>CustomerDismissAction</code>,可以进行自定义的操作；</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">customDismissAction: <span class=\"type\">UNNotificationCategoryOptions</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> category = <span class=\"type\">UNNotificationCategory</span>(identifier: <span class=\"string\">\"message\"</span>, actions: [action], minimalActions: [action], intentIdentifiers: [], options: [.customDismissAction])</div></pre></td></tr></table></figure>\n<h2 id=\"Actions-Response\"><a href=\"#Actions-Response\" class=\"headerlink\" title=\"Actions Response\"></a>Actions Response</h2><p>我们有多种方法知道，用户是通过什么途径打开应用，在通知上做了什么操作，通知是什么类型等等。但是现在我们只需要实现一个代理方法就可以做到这些了</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/25.png\" alt=\"\"></p>\n<p>通过 <code>delegate</code> 的方法，我们可以得到一个<code>response</code> 和一个 <code>handler</code> 的<code>Block回调</code></p>\n<p>在 <code>Response</code>中我们可以得到<code>actionIdentifier</code>,如果用户有输入行为，我们可以得到<code>输入的文本</code>，以及具体的<code>Notification</code>。</p>\n<p>在已得到的通知中，获取<code>Request</code>,再接下来就可以得到触发条件<code>Trigger</code>和通知内容<code>Content</code>。</p>\n<p>然后我们在<code>completionHandler</code>回调中，进行相关的操作。</p>\n<h2 id=\"Service-Extension\"><a href=\"#Service-Extension\" class=\"headerlink\" title=\"Service Extension\"></a>Service Extension</h2><blockquote>\n<p><code>Service Extension</code>是通知的服务扩展，它不会在UI界面上进行展示，用于<code>增强</code>和<code>替换</code>显示到用户界面上的内容。</p>\n<p>其原理是我们的推送服务器将推送的内容上传至<code>APNS</code>服务器，在<code>APNS</code>将消息推送到设备，在设备显示推送消息之前，我们有一段很短的时间，可以通过<code>Extension</code>进行回调执行相关的操作。</p>\n<p>基于<code>Service Extension</code>，我们可以实现<code>端到端加密</code>以及<code>添加附件</code>和其他统一的操作。</p>\n</blockquote>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/23.png\" alt=\"\"></p>\n<p>我们大致走一下构建<code>Service Extension</code>的流程</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC-2016-707/24.png\" alt=\"\"></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Service Extension</span></div><div class=\"line\"><span class=\"keyword\">import</span> UserNotifications</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NotificationService</span>: <span class=\"title\">UNNotificationServiceExtension</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceive</span><span class=\"params\">(request: UNNotificationRequest, withContentHandler contentHandler:<span class=\"params\">(UNNotificationContent)</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123; <span class=\"comment\">// Modify the notification content </span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serviceExtensionTimeWillExpire</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">// Called before the extension will be terminated by the system </span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>示例代码</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    aps : &#123; </div><div class=\"line\">            alert : “<span class=\"type\">New</span> <span class=\"type\">Message</span> <span class=\"type\">Available</span>”,</div><div class=\"line\">            mutable-content : <span class=\"number\">1</span></div><div class=\"line\"></div><div class=\"line\">          &#125;, </div><div class=\"line\">    encrypted-content : “#myencryptedcontent”</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Decrypt Remote Notification Payload in Service Extension and Update Notification Content</span></div><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceive</span><span class=\"params\">(request: UNNotificationRequest, withContentHandler contentHandler: <span class=\"params\">(UNNotificationContent)</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Decrypt the payload </span></div><div class=\"line\">    <span class=\"keyword\">let</span> decryptedBody = decrypt(request.content.userInfo[“encrypted-content”])</div><div class=\"line\">    <span class=\"keyword\">let</span> newContent = <span class=\"type\">UNMutableNotificationContent</span>()</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// Modify the notification content </span></div><div class=\"line\">    newContent.body = decryptedBody</div><div class=\"line\">    <span class=\"comment\">// Call content handler with updated content </span></div><div class=\"line\">    contentHandler(newContent)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>后面还有一篇高级通知的文章，地址。</p>\n","excerpt":"UNNotifications是WWDC2016基于之前的推送服务，推出的全新的的通知框架。","categories":[],"tags":[{"name":"WWDC Session 2016","slug":"WWDC-Session-2016","permalink":"http://yoursite.com/tags/WWDC-Session-2016/"}]},{"title":"iOS常用加密算法","date":"2017-06-07T06:46:23.000Z","path":"2017/06/07/iOS常用加密算法/","text":"对称加密[算法]在加密和解密时使用的是同一个秘钥；而[非对称加密算法]需要两个[密钥]来进行加密和解密，这两个秘钥是[公开密钥]（public key，简称公钥）和私有密钥（private key，简称私钥）。 DES加密（数据加密算法）AES加密（高级加密标准）替代DES加密 字节替代（SubBytes） 行移位（ShiftRows） 列混淆（MixColumns） 轮密钥加（AddRoundKey） 参考博客 http://www.mamicode.com/info-detail-514466.html MD5加密（信息-摘要算法）MD5功能： 输入任意长度的信息，经过处理，输出为128位的信息（数字指纹）； 不同的输入得到的不同的结果（唯一性）； 根据128位的输出结果不可能反推出输入的信息（不可逆）； MD5用途 1、防止被篡改： 2、比如发送一个电子文档，发送前，我先得到MD5的输出结果a。然后在对方收到电子文档后，对方也得到一个MD5的输出结果b。如果a与b一样就代表中途未被篡改。2）比如我提供文件下载，为了防止不法分子在安装程序中添加木马，我可以在网站上公布由安装文件得到的MD5输出结果。 3、SVN在检测文件是否在CheckOut后被修改过，也是用到了MD5. SHA加密（安全散列算法） 接收一段明文，然后以一种不可逆的方式将它转换成一段密文，也可以简单的理解为取一串输入码，并把这个信息转化为长度较短、位数固定的输出序列即散列值（也称为信息认证代码）的过程。适用于长度不超过2^64 二进制位的消息。根据长度小于2^64 位的消息，它会产生一个160位的信息摘要 优点 不可逆——（无法推出任何部分的原始信息） 防冲突—— （任何输入的信息的变化，哪怕一位，都将导致结果变化） 具有良好的雪崩效应——（找不到具有相同散列结果的两条信息） RSA加密 与对称加密[算法]不同，[非对称加密算法]需要两个[密钥]：[公开密钥]（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的[密钥]，所以这种算法叫作[非对称加密算法]。 RSA加密原理RSA是常用的加密模式，其加密原理可用以下的例子进行简要的论述。 随机取两个质数 1234567891011121314P = 61;q = 53;N = P * Q = 3233;// E是1-n之间的一个随机的质数E = 17;// D是通过一系列数学运算得出的一个数字，// 运算方法后续会附上阮一峰老师的两篇文章链接// (N,D)(N,E)要满足可以互相解值运算// 假如(N,D)是公钥，（N,E）是私钥// 满足私钥加密，公钥解密或者反过来公钥加密，私钥解密。// 也要满足只知道（N，D）就想知道（N,E），那就要把N这个大的整数进行因数分解。// 因数分解只能使用暴力穷举，N越大，相应的也就越安全// 当 N 大到1024位或者2048位时，以目前的技术破解几乎不可能，所以很安全 附录阮一峰-RSA算法原理1阮一峰-RSA算法原理2","content":"<blockquote>\n<p>对称加密<code>[算法]</code>在加密和解密时使用的是同一个秘钥；而<code>[非对称加密算法]</code>需要两个<code>[密钥]</code>来进行加密和解密，这两个秘钥是<code>[公开密钥]</code>（public key，简称公钥）和私有密钥（private key，简称私钥）。</p>\n</blockquote>\n<h3 id=\"DES加密（数据加密算法）\"><a href=\"#DES加密（数据加密算法）\" class=\"headerlink\" title=\"DES加密（数据加密算法）\"></a>DES加密（数据加密算法）</h3><h3 id=\"AES加密（高级加密标准）\"><a href=\"#AES加密（高级加密标准）\" class=\"headerlink\" title=\"AES加密（高级加密标准）\"></a>AES加密（高级加密标准）</h3><p>替代DES加密</p>\n<p><img src=\"http://images.cnitblog.com/blog2015/671127/201503/130035028553414.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<ul>\n<li>字节替代（SubBytes）</li>\n<li>行移位（ShiftRows）</li>\n<li>列混淆（MixColumns）</li>\n<li>轮密钥加（AddRoundKey）</li>\n</ul>\n<p>参考博客   <a href=\"http://www.mamicode.com/info-detail-514466.html\" target=\"_blank\" rel=\"external\">http://www.mamicode.com/info-detail-514466.html</a></p>\n<h3 id=\"MD5加密（信息-摘要算法）\"><a href=\"#MD5加密（信息-摘要算法）\" class=\"headerlink\" title=\"MD5加密（信息-摘要算法）\"></a>MD5加密（信息-摘要算法）</h3><h6 id=\"MD5功能：\"><a href=\"#MD5功能：\" class=\"headerlink\" title=\"MD5功能：\"></a>MD5功能：</h6><ul>\n<li>输入任意长度的信息，经过处理，输出为128位的信息（数字指纹）；</li>\n<li>不同的输入得到的不同的结果（唯一性）；</li>\n<li>根据128位的输出结果不可能反推出输入的信息（不可逆）；</li>\n</ul>\n<h6 id=\"MD5用途\"><a href=\"#MD5用途\" class=\"headerlink\" title=\"MD5用途\"></a>MD5用途</h6><ul>\n<li>1、防止被篡改：</li>\n<li>2、比如发送一个电子文档，发送前，我先得到MD5的输出结果a。然后在对方收到电子文档后，对方也得到一个MD5的输出结果b。如果a与b一样就代表中途未被篡改。2）比如我提供文件下载，为了防止不法分子在安装程序中添加木马，我可以在网站上公布由安装文件得到的MD5输出结果。</li>\n<li>3、SVN在检测文件是否在CheckOut后被修改过，也是用到了MD5. </li>\n</ul>\n<h3 id=\"SHA加密（安全散列算法）\"><a href=\"#SHA加密（安全散列算法）\" class=\"headerlink\" title=\"SHA加密（安全散列算法）\"></a>SHA加密（安全散列算法）</h3><blockquote>\n<p>接收一段明文，然后以一种不可逆的方式将它转换成一段密文，也可以简单的理解为取一串输入码，并把这个信息转化为长度较短、位数固定的输出序列即散列值（也称为信息认证代码）的过程。适用于长度不超过<br>2^64 二进制位的消息。根据长度小于2^64 位的消息，它会产生一个160位的信息摘要</p>\n</blockquote>\n<h6 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h6><ul>\n<li>不可逆——（无法推出任何部分的原始信息）</li>\n<li>防冲突—— （任何输入的信息的变化，哪怕一位，都将导致结果变化）</li>\n<li>具有良好的雪崩效应——（找不到具有相同散列结果的两条信息）</li>\n</ul>\n<h3 id=\"RSA加密\"><a href=\"#RSA加密\" class=\"headerlink\" title=\"RSA加密\"></a>RSA加密</h3><blockquote>\n<p>与对称加密[算法]不同，[非对称加密算法]需要两个[密钥]：<code>[公开密钥]（publickey）</code>和<code>私有密钥（privatekey）</code>。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为<code>加密</code>和<code>解密</code>使用的是两个不同的[密钥]，所以这种算法叫作<code>[非对称加密算法]</code>。</p>\n</blockquote>\n<h4 id=\"RSA加密原理\"><a href=\"#RSA加密原理\" class=\"headerlink\" title=\"RSA加密原理\"></a><code>RSA</code>加密原理</h4><p><code>RSA</code>是常用的加密模式，其加密原理可用以下的例子进行简要的论述。</p>\n<p>随机取两个质数</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">P = <span class=\"number\">61</span>;</div><div class=\"line\">q = <span class=\"number\">53</span>;</div><div class=\"line\">N = P * Q = <span class=\"number\">3233</span>;</div><div class=\"line\"><span class=\"comment\">// E是1-n之间的一个随机的质数</span></div><div class=\"line\">E = <span class=\"number\">17</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// D是通过一系列数学运算得出的一个数字，</span></div><div class=\"line\"><span class=\"comment\">// 运算方法后续会附上阮一峰老师的两篇文章链接</span></div><div class=\"line\"><span class=\"comment\">// (N,D)(N,E)要满足可以互相解值运算</span></div><div class=\"line\"><span class=\"comment\">// 假如(N,D)是公钥，（N,E）是私钥</span></div><div class=\"line\"><span class=\"comment\">// 满足私钥加密，公钥解密或者反过来公钥加密，私钥解密。</span></div><div class=\"line\"><span class=\"comment\">// 也要满足只知道（N，D）就想知道（N,E），那就要把N这个大的整数进行因数分解。</span></div><div class=\"line\"><span class=\"comment\">// 因数分解只能使用暴力穷举，N越大，相应的也就越安全</span></div><div class=\"line\"><span class=\"comment\">// 当 N 大到1024位或者2048位时，以目前的技术破解几乎不可能，所以很安全</span></div></pre></td></tr></table></figure>\n<h4 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h4><p><a href=\"http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html\" target=\"_blank\" rel=\"external\">阮一峰-RSA算法原理1</a><br><a href=\"http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html\" target=\"_blank\" rel=\"external\">阮一峰-RSA算法原理2</a></p>\n","excerpt":"对称加密[算法]在加密和解密时使用的是同一个秘钥；而[非对称加密算法]需要两个[密钥]来进行加密和解密，这两个秘钥是[公开密钥]（public key，简称公钥）和私有密钥（private key，简称私钥）。 DES加密（数据加密算法）AES加密（高级加密标准）替代DES加密","categories":[],"tags":[{"name":"加密算法","slug":"加密算法","permalink":"http://yoursite.com/tags/加密算法/"}]},{"title":"WWDC2016-Session413（介绍Xcode的使用技巧）","date":"2017-06-07T02:34:15.000Z","path":"2017/06/07/WWDC2016-Session413（介绍Xcode的使用技巧）/","text":"这一章节作为开发者工具的一部分，简单介绍了我们日常使用的开发工具 Xcode,虽然是我们每天都要使用的工具，但是通过这一个session还是收获了一些实用的小技巧。 其中包括以下这几个大的模块。 创建一个简单的应用并使其运行 运行单元测试并对Bug进行调试 审阅代码和提交 对Xcode进行相关配置 配置你的工程（configuring your project）像创建运行模块、简单的测试调试、以及代码的审阅和提交，在此处就不多叙述了，而在配置项目中，有几个很关键的概念需要弄明白 Project Target BuildSetting Schemes WorkSpaces Project根据官方文档的解释 ，Xcode的Project是我们构建一个或多个应用时所需的文件、资源、相关信息的主要仓库。一个Project包含构建一个应用的所有元素，同时管理着这些元素之间的关系。它可能包含一个或者多个Target,Target可以专门指定该如何构建产品。Project为项目中的所有Target都做了默认的设定。 Project 包含以下文件 引用源文件 源代码，包括头文件(.h)以及实现文件(.m)。 静态库、动态库。内部文件和外部文件。 资源文件。 图片文件。 用户交互的图形化界面(nib)。 分组被用来在导航栏中管理源文件 项目级构建配置(Schems)。 您可以为项目指定多个构建配置; 例如，您可能有一个项目的调试和发布构建设置。 目标文件(Targets) 每个指定的可用于调试或者单元测试的执行环境 TargetsProject管理Target Targets包含一组在Project或者WorkSpace中的指定该如何构建产品的说明文件。一个Target就构建了一个独立的Product. Target构建成产品会经历上图的几个步骤，具体看图即可 SchemesScheme就是构建的方案，例如，你可以自定规则Debug或者Release,来决定不同环境下的不同规则。 Build Settings 字面意思就是 编译设置，用于设置在编译过程中一些优先级、支持架构信息、优化的优先级、引用外部框架的路径、项目名称等一系列信息。 WorkSpacesWorkSpaces就是工作空间，用来管理，整个项目中的多个Project。 收获的小技巧 ommand + shift + O == Open Quickly 单元测试中，可以使用Test Again,针对某一个，测试用例进行多次测试 利用搜索栏的条件，进行精确的搜索，筛除无用的信息 Xcode中自带的Source Control进行代码对比，查看修改，以及查看相关日至 引申出的其他相关 Session","content":"<p>这一章节作为开发者工具的一部分，简单介绍了我们日常使用的开发工具 <code>Xcode</code>,虽然是我们每天都要使用的工具，但是通过这一个<code>session</code>还是收获了一些实用的小技巧。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-01.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>其中包括以下这几个大的模块。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-02.png\" alt=\"\"></p>\n<ul>\n<li>创建一个简单的应用并使其运行</li>\n<li>运行单元测试并对Bug进行调试</li>\n<li>审阅代码和提交</li>\n<li>对Xcode进行相关配置</li>\n</ul>\n<h3 id=\"配置你的工程（configuring-your-project）\"><a href=\"#配置你的工程（configuring-your-project）\" class=\"headerlink\" title=\"配置你的工程（configuring your project）\"></a>配置你的工程（configuring your project）</h3><p>像创建运行模块、简单的测试调试、以及代码的审阅和提交，在此处就不多叙述了，而在配置项目中，有几个很关键的概念需要弄明白</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-03.png\" alt=\"\"></p>\n<ul>\n<li>Project</li>\n<li>Target</li>\n<li>BuildSetting</li>\n<li>Schemes</li>\n<li>WorkSpaces</li>\n</ul>\n<h4 id=\"Project\"><a href=\"#Project\" class=\"headerlink\" title=\"Project\"></a>Project</h4><p>根据<a href=\"https://developer.apple.com/library/content/featuredarticles/XcodeConcepts/Concept-Projects.html\" target=\"_blank\" rel=\"external\">官方文档的解释</a> ，<code>Xcode</code>的<code>Project</code>是我们构建一个或多个应用时所需的文件、资源、相关信息的主要仓库。一个<code>Project</code>包含构建一个应用的所有元素，同时管理着这些元素之间的关系。它可能包含一个或者多个<code>Target</code>,<code>Target</code>可以专门指定该如何构建产品。<code>Project</code>为项目中的所有<code>Target</code>都做了默认的设定。</p>\n<h5 id=\"Project-包含以下文件\"><a href=\"#Project-包含以下文件\" class=\"headerlink\" title=\"Project 包含以下文件\"></a>Project 包含以下文件</h5><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-04.png\" alt=\"\"></p>\n<ul>\n<li><p>引用源文件</p>\n<ul>\n<li>源代码，包括头文件(.h)以及实现文件(.m)。</li>\n<li>静态库、动态库。内部文件和外部文件。</li>\n<li>资源文件。</li>\n<li>图片文件。</li>\n<li>用户交互的图形化界面(nib)。   </li>\n</ul>\n</li>\n<li><p>分组被用来在导航栏中管理<code>源文件</code></p>\n</li>\n<li>项目级构建配置(Schems)。 您可以为项目指定多个构建配置; 例如，您可能有一个项目的调试和发布构建设置。</li>\n<li>目标文件(Targets)</li>\n<li>每个指定的可用于<code>调试</code>或者<code>单元测试</code>的执行环境</li>\n</ul>\n<h4 id=\"Targets\"><a href=\"#Targets\" class=\"headerlink\" title=\"Targets\"></a>Targets</h4><p><code>Project</code>管理<code>Target</code><br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-06.png\" alt=\"\"></p>\n<p><code>Targets</code>包含一组在<code>Project</code>或者<code>WorkSpace</code>中的指定该如何构建产品的说明文件。一个<code>Target</code>就构建了一个独立的<code>Product</code>.</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-05.png\" alt=\"\"></p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-07.png\" alt=\"\"></p>\n<p><code>Target</code>构建成产品会经历上图的几个步骤，具体看图即可</p>\n<h4 id=\"Schemes\"><a href=\"#Schemes\" class=\"headerlink\" title=\"Schemes\"></a>Schemes</h4><p><code>Scheme</code>就是构建的方案，例如，你可以自定规则<code>Debug</code>或者<code>Release</code>,来决定不同环境下的不同规则。<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-08.png\" alt=\"\"></p>\n<h4 id=\"Build-Settings\"><a href=\"#Build-Settings\" class=\"headerlink\" title=\"Build Settings\"></a>Build Settings</h4><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-11.png\" alt=\"\"></p>\n<p>字面意思就是 <code>编译设置</code>，用于设置在编译过程中一些优先级、支持架构信息、优化的优先级、引用外部框架的路径、项目名称等一系列信息。</p>\n<h4 id=\"WorkSpaces\"><a href=\"#WorkSpaces\" class=\"headerlink\" title=\"WorkSpaces\"></a>WorkSpaces</h4><p><code>WorkSpaces</code>就是工作空间，用来管理，整个项目中的多个<code>Project</code>。<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-09.png\" alt=\"\"></p>\n<h3 id=\"收获的小技巧\"><a href=\"#收获的小技巧\" class=\"headerlink\" title=\"收获的小技巧\"></a>收获的小技巧</h3><ul>\n<li><code>ommand</code> + <code>shift</code> + <code>O</code> == <code>Open Quickly</code></li>\n<li>单元测试中，可以使用<code>Test Again</code>,针对某一个，测试用例进行多次测试</li>\n<li>利用搜索栏的条件，进行精确的搜索，筛除无用的信息</li>\n<li><code>Xcode</code>中自带的<code>Source Control</code>进行代码对比，查看修改，以及查看相关日至</li>\n</ul>\n<h3 id=\"引申出的其他相关-Session\"><a href=\"#引申出的其他相关-Session\" class=\"headerlink\" title=\"引申出的其他相关 Session\"></a>引申出的其他相关 Session</h3><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/WWDC/2016-413-10.png\" alt=\"\"></p>\n","excerpt":"这一章节作为开发者工具的一部分，简单介绍了我们日常使用的开发工具 Xcode,虽然是我们每天都要使用的工具，但是通过这一个session还是收获了一些实用的小技巧。","categories":[],"tags":[{"name":"WWDC Session 2016","slug":"WWDC-Session-2016","permalink":"http://yoursite.com/tags/WWDC-Session-2016/"}]},{"title":"NSURLProtocol","date":"2017-05-26T08:03:27.000Z","path":"2017/05/26/NSURLProtocol/","text":"","content":"","excerpt":"","categories":[],"tags":[]},{"title":"Block详解","date":"2017-05-18T11:34:42.000Z","path":"2017/05/18/Block详解/","text":"block是2010年WWDC苹果为 Objective－C 提供的一个新特性，它为我们开发提供了便利，比如GCD就大量使用了block，用来往执行队列中添加任务。书上定义block是带有自动变量（局部变量）的匿名函数。其实它就是一个闭包，一个引用自动变量的函数，更通俗的说，block就是一段代码块，用来储存一段代码，在特定的时机执行 Block用途 自动变量（局部变量） 函数参数 静态局部变量 静态全局变量 全局变量 Block声明与定义1.没有返回值,没有参数的定义方式 12345678910111213141516//返回值类型(^block的名字)(参数类型) = ^(参数类型和参数名) &#123;&#125;; void(^block)() = ^()&#123; NSLog(@\"调用了block\"); &#125;; //当然,没有参数的时候可以把括号省去 void(^block)() = ^&#123; NSLog(@\"调用了block\"); &#125;; // Block的调用直接Block名称后面括号即可，有参数就把参数放入即可 block(); // 调用了上面定义的Block 2.有返回值,有参数的定义方式 123456//返回值类型(^block的名字)(参数类型) = ^(参数类型和参数名) &#123;&#125;;//如果有参数,定义的时候,必须要写参数,而且必须要有参数变量名 int(^block)(int) = ^(int a)&#123; return a + 1; &#125;; 3.系统提供了一个定义block的快捷函数inline 12345// block快捷方式 输入:inlinereturnType(^blockName)(parameterTypes) = ^(parameters) &#123; statements&#125;; 4.block的类型 1234567891011121314151617181920212223242526//block有自己的类型,就想@\"string\"是NSString类型一样//格式就是 返回值(^)(参数类型)//比如这个block的类型就是: int(^)(int) int(^block)(int) = ^(int a)&#123; return 1; &#125;; //这个block的类型就是void(^)() void(^block)() = ^&#123; NSLog(@\"调用了block\"); &#125;; //在ARC中把block定义成属性要用 copy 类型,定义方式如下://这样在类中可以拿到self.block@property (nonatomic, copy) void(^block)();//当然也可以取别名://BlockType不是变量名,而是这种类型的block的别名typedef void(^BlockType)();//然后就可以这样@property (nonatomic, strong) BlockType block; Block语法上的省略block的标准范式为 ^ 返回值类型 参数列表 表达式 12345678910111213141516171819202122232425// 1.例如一个完整的Block ^int (int count) &#123; return count + 1; &#125;; // 2.如果返回值为Void，那么返回值可以省略 ^ (int count) &#123; NSLog(@\"%d\",count); &#125;; // 3.同理如果返回值和参数列表都没有值，那么可以同时省略 ^ &#123; NSLog(@\"%d\",count); &#125;; // 4.省略返回值时，如果表达式内部有 return 的类型，那么上略的返回值以 return 的类型为准，下面这个离子的返回值实际就是 int ^ (int count) &#123; return count + 1; &#125;; // 5.返回值类型和实际 return的类型必须一致。 与C语言指针函数的不同123456789101112131415161718//首先我们定义一个C语言的指针函数void buttonCallBack(int event) &#123; Printf(\"event = %d\\n\",event);&#125;//再写一个相同的Block^ void (int event) &#123; NSLog(@\"event = %d\",event);&#125;//对比得出结论1.Block是匿名函数，无需写函数名称2.返回值前加上 “^” 标记 Block变量的传递1.如果block访问的变量是局部变量,那么变量是值传递 1234567//block为值传递只有一种情况:int a = 3;void(^block)() = ^&#123; NSLog(@\"%d\",a);&#125;;a = 5;block();//这里调用block打印出的是3,是值传递 2.如果是静态变量,那么变量是指针传递 1234567static int a = 3;void(^block)() = ^&#123; NSLog(@\"%d\",a);&#125;;a = 5;block();//这里调用block打印出的是5,是指针传递//另外全局变量,静态变量都是指针传递 Block值传递Block也可以进行值的传递，且一般用于逆向回传，在此处不展开了，后面会针对iOS几种值传递的类型，做一个系统的总结,随后会附上链接。","content":"<blockquote>\n<p><code>block</code>是2010年WWDC苹果为 Objective－C 提供的一个新特性，它为我们开发提供了便利，比如GCD就大量使用了<code>block</code>，用来往执行队列中添加任务。书上定义<code>block</code>是带有自动变量（局部变量）的匿名函数。其实它就是一个闭包，一个引用自动变量的函数，更通俗的说，<code>block</code>就是一段代码块，用来储存一段代码，在特定的时机执行</p>\n</blockquote>\n<h3 id=\"Block用途\"><a href=\"#Block用途\" class=\"headerlink\" title=\"Block用途\"></a>Block用途</h3><ol>\n<li>自动变量（局部变量）</li>\n<li>函数参数</li>\n<li>静态局部变量</li>\n<li>静态全局变量</li>\n<li>全局变量</li>\n</ol>\n<h3 id=\"Block声明与定义\"><a href=\"#Block声明与定义\" class=\"headerlink\" title=\"Block声明与定义\"></a>Block声明与定义</h3><p>1.没有返回值,没有参数的定义方式</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//返回值类型(^block的名字)(参数类型) = ^(参数类型和参数名) &#123;&#125;;</span></div><div class=\"line\">  <span class=\"keyword\">void</span>(^block)() = ^()&#123;</div><div class=\"line\">  </div><div class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"调用了block\"</span>);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">//当然,没有参数的时候可以把括号省去</span></div><div class=\"line\">  <span class=\"keyword\">void</span>(^block)() = ^&#123;</div><div class=\"line\">  </div><div class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"调用了block\"</span>);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">// Block的调用直接Block名称后面括号即可，有参数就把参数放入即可</span></div><div class=\"line\"></div><div class=\"line\">    block();  <span class=\"comment\">// 调用了上面定义的Block</span></div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>2.有返回值,有参数的定义方式</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//返回值类型(^block的名字)(参数类型) = ^(参数类型和参数名) &#123;&#125;;</span></div><div class=\"line\"><span class=\"comment\">//如果有参数,定义的时候,必须要写参数,而且必须要有参数变量名</span></div><div class=\"line\">  <span class=\"keyword\">int</span>(^block)(<span class=\"keyword\">int</span>) = ^(<span class=\"keyword\">int</span> a)&#123;</div><div class=\"line\">  </div><div class=\"line\">      <span class=\"keyword\">return</span> a + <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;;</div></pre></td></tr></table></figure>\n<p>3.系统提供了一个定义block的快捷函数<code>inline</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// block快捷方式   输入:inline</span></div><div class=\"line\">returnType(^blockName)(parameterTypes) = ^(parameters) &#123;</div><div class=\"line\"></div><div class=\"line\">        statements</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>4.block的类型</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//block有自己的类型,就想@\"string\"是NSString类型一样</span></div><div class=\"line\"><span class=\"comment\">//格式就是 返回值(^)(参数类型)</span></div><div class=\"line\"><span class=\"comment\">//比如这个block的类型就是: int(^)(int)</span></div><div class=\"line\">  <span class=\"keyword\">int</span>(^block)(<span class=\"keyword\">int</span>) = ^(<span class=\"keyword\">int</span> a)&#123;</div><div class=\"line\">  </div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">      </div><div class=\"line\">  &#125;;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">//这个block的类型就是void(^)()</span></div><div class=\"line\">  <span class=\"keyword\">void</span>(^block)() = ^&#123;</div><div class=\"line\">  </div><div class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"调用了block\"</span>);</div><div class=\"line\">      </div><div class=\"line\">  &#125;; </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">//在ARC中把block定义成属性要用 copy 类型,定义方式如下:</span></div><div class=\"line\"><span class=\"comment\">//这样在类中可以拿到self.block</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"keyword\">void</span>(^block)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//当然也可以取别名:</span></div><div class=\"line\"><span class=\"comment\">//BlockType不是变量名,而是这种类型的block的别名</span></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^BlockType)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//然后就可以这样</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) BlockType block;</div></pre></td></tr></table></figure>\n<h3 id=\"Block语法上的省略\"><a href=\"#Block语法上的省略\" class=\"headerlink\" title=\"Block语法上的省略\"></a>Block语法上的省略</h3><p><code>block</code>的标准范式为</p>\n<p><code>^</code>  <code>返回值类型</code>  <code>参数列表</code>  <code>表达式</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 1.例如一个完整的Block</span></div><div class=\"line\">    ^<span class=\"keyword\">int</span> (<span class=\"keyword\">int</span> count) &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> count + <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">// 2.如果返回值为Void，那么返回值可以省略</span></div><div class=\"line\">    ^ (<span class=\"keyword\">int</span> count) &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,count);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">// 3.同理如果返回值和参数列表都没有值，那么可以同时省略</span></div><div class=\"line\">    ^  &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,count);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">// 4.省略返回值时，如果表达式内部有 return 的类型，那么上略的返回值以 return 的类型为准，下面这个离子的返回值实际就是 int</span></div><div class=\"line\">    ^ (<span class=\"keyword\">int</span> count) &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> count + <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;;</div><div class=\"line\">   </div><div class=\"line\"><span class=\"comment\">// 5.返回值类型和实际 return的类型必须一致。</span></div></pre></td></tr></table></figure>\n<h3 id=\"与C语言指针函数的不同\"><a href=\"#与C语言指针函数的不同\" class=\"headerlink\" title=\"与C语言指针函数的不同\"></a>与C语言指针函数的不同</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//首先我们定义一个C语言的指针函数</span></div><div class=\"line\"><span class=\"keyword\">void</span> buttonCallBack(<span class=\"keyword\">int</span> event) &#123;</div><div class=\"line\"></div><div class=\"line\">    Printf(<span class=\"string\">\"event = %d\\n\"</span>,event);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//再写一个相同的Block</span></div><div class=\"line\">^ <span class=\"keyword\">void</span> (<span class=\"keyword\">int</span> event) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"event = %d\"</span>,event);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//对比得出结论</span></div><div class=\"line\"><span class=\"number\">1.</span>Block是匿名函数，无需写函数名称</div><div class=\"line\"><span class=\"number\">2.</span>返回值前加上 “^” 标记</div></pre></td></tr></table></figure>\n<h3 id=\"Block变量的传递\"><a href=\"#Block变量的传递\" class=\"headerlink\" title=\"Block变量的传递\"></a>Block变量的传递</h3><p>1.如果block访问的变量是局部变量,那么变量是值传递</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//block为值传递只有一种情况:</span></div><div class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"keyword\">void</span>(^block)() = ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,a);</div><div class=\"line\">&#125;;</div><div class=\"line\">a = <span class=\"number\">5</span>;</div><div class=\"line\">block();<span class=\"comment\">//这里调用block打印出的是3,是值传递</span></div></pre></td></tr></table></figure>\n<p>2.如果是静态变量,那么变量是指针传递</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"keyword\">void</span>(^block)() = ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,a);</div><div class=\"line\">&#125;;</div><div class=\"line\">a = <span class=\"number\">5</span>;</div><div class=\"line\">block();<span class=\"comment\">//这里调用block打印出的是5,是指针传递</span></div><div class=\"line\"><span class=\"comment\">//另外全局变量,静态变量都是指针传递</span></div></pre></td></tr></table></figure>\n<h3 id=\"Block值传递\"><a href=\"#Block值传递\" class=\"headerlink\" title=\"Block值传递\"></a>Block值传递</h3><p><code>Block</code>也可以进行值的传递，且一般用于逆向回传，在此处不展开了，后面会针对<code>iOS</code>几种值传递的类型，做一个系统的总结,随后会附上链接。</p>\n","excerpt":"block是2010年WWDC苹果为 Objective－C 提供的一个新特性，它为我们开发提供了便利，比如GCD就大量使用了block，用来往执行队列中添加任务。书上定义block是带有自动变量（局部变量）的匿名函数。其实它就是一个闭包，一个引用自动变量的函数，更通俗的说，block就是一段代码块，用来储存一段代码，在特定的时机执行 Block用途 自动变量（局部变量） 函数参数 静态局部变量 静态全局变量 全局变量 Block声明与定义1.没有返回值,没有参数的定义方式 12345678910111213141516//返回值类型(^block的名字)(参数类型) = ^(参数类型和参数名) &#123;&#125;; void(^block)() = ^()&#123; NSLog(@\"调用了block\"); &#125;; //当然,没有参数的时候可以把括号省去 void(^block)() = ^&#123; NSLog(@\"调用了block\"); &#125;; // Block的调用直接Block名称后面括号即可，有参数就把参数放入即可 block(); // 调用了上面定义的Block","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://yoursite.com/tags/知识点/"}]},{"title":"iOS知识点小集","date":"2017-05-17T05:45:24.000Z","path":"2017/05/17/iOS知识点小集/","text":"在初始化项目时，LaunchScreen &gt; LaunchImage的优先级 123456789 如果是通过LaunchImage设置启动界面,那么屏幕的可视范围由图片决定 注意:如果使用LaunchImage,必须让你的美工提供各种尺寸的启动图片 LaunchScreen:Xcode6开始才有 LaunchScreen好处:1.自动识别当前真机或者模拟器的尺寸 2.只要让美工提供一个可拉伸图片 3.展示更多东西 LaunchScreen底层实现:把LaunchScreen截屏,生成一张图片.作为启动界面*/","content":"<ol>\n<li><p>在初始化项目时，<code>LaunchScreen</code> &gt; <code>LaunchImage</code>的优先级</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">   如果是通过LaunchImage设置启动界面,那么屏幕的可视范围由图片决定</div><div class=\"line\">   注意:如果使用LaunchImage,必须让你的美工提供各种尺寸的启动图片</div><div class=\"line\">   </div><div class=\"line\">   LaunchScreen:Xcode6开始才有</div><div class=\"line\">   LaunchScreen好处:<span class=\"number\">1.</span>自动识别当前真机或者模拟器的尺寸 <span class=\"number\">2.</span>只要让美工提供一个可拉伸图片</div><div class=\"line\">   <span class=\"number\">3.</span>展示更多东西</div><div class=\"line\"></div><div class=\"line\">   LaunchScreen底层实现:把LaunchScreen截屏,生成一张图片.作为启动界面</div><div class=\"line\">*/</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<a id=\"more\"></a>\n","excerpt":"在初始化项目时，LaunchScreen &gt; LaunchImage的优先级 123456789 如果是通过LaunchImage设置启动界面,那么屏幕的可视范围由图片决定 注意:如果使用LaunchImage,必须让你的美工提供各种尺寸的启动图片 LaunchScreen:Xcode6开始才有 LaunchScreen好处:1.自动识别当前真机或者模拟器的尺寸 2.只要让美工提供一个可拉伸图片 3.展示更多东西 LaunchScreen底层实现:把LaunchScreen截屏,生成一张图片.作为启动界面*/","categories":[],"tags":[]},{"title":"SDWebImage源码解析","date":"2017-05-16T05:59:32.000Z","path":"2017/05/16/SDWebImage源码解析/","text":"SDWebImage是我们经常使用的一个异步图片加载库，大大提高了我们的开发效率。它支持从网络中下载且缓存图片，并设置图片到对应的UIImageView控件或者UIButton控件上。 SDWebImage 概论123456789101.提供了一个UIImageView的category用来加载网络图片并且对网络图片的缓存进行管理2.采用异步方式来下载网络图片3.采用异步方式，使用memory＋disk来缓存网络图片，自动管理缓存。4.支持GIF动画,支持JEPG,JPG格式。5.支持WebP格式6.同一个URL的网络图片不会被重复下载7.失效的URL不会被无限重试8.耗时操作都在子线程，确保不会阻塞主线程9.使用GCD和ARC10.支持Arm64 ##SDWebImage知识点的梳理 正常程序退出后，会在几秒内停止工作,要想申请更长的时间，需要用到beginBackgroundTaskWithExpirationHandler endBackgroundTask一定要成对出现 使用NSdirectoryEnumerator遍历所有的缓存文件不会有性能耗时的问题,检查某个文件是否存在或者检查是否为文件夹都会检查文件的inode 数据,而这个inode中包括file的各种attribute. 使用NSCache作为内存储存比NSDictionary的好处是:当系统资源要耗尽的时候可以自动的删减,NSCache不会自动的拷贝键,并且是线程安全的,比NSDictionary线程安全. 线程中urlCallbacks的增加,改动都是使用所有增改回调集合URLCallbacks的操作使用dispatch_barrier_sync放入队列barrierQueue中，而查询URLCallbakcs的操作只需使用dispatch_sync放入队列barrierQueue中。 要先说一些系统中锁的问题: 同步锁@synchronized(self)在self上加一个同步锁,频繁滥用的话会导致程序会等待另外一段与此代码无关的执行完毕之后才能执行,会耗时. 123[_lock lock];//[_lock unlock]; 这样遇到死锁也会很麻烦,并且效率也不高.一般情况下想要为代码加锁,最好使用CGD.将所有的操作放到串行队列中执行.而对于并行队列的话就需要,读取的话可以并发进行,并没有任何改动,而增加或者修改数据的话必须保证此时不能进行读取数据,那么可以使用栅栏(barrier)来设置.在队列中栅栏块必须单独执行,不能与其他一起执行.这对于并发队列来说,如果并发队列发下下面要处理的是栅栏块,那么会一直等前面所有的并发块执行完毕后才执行这个栅栏,而等栅栏执行完毕后才执行其后的并发任务.所以增加和修改使用栅栏可以保证线程安全. 5.图片的解码.当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。SDWebImage就是在后台生成这种位图. SDWebImageManager结构关于结构，我们可以用一张流程图说明 SDWebImageDownloaderOptionsSDWebImageDownloaderOptions是图片下载选项 123456789101112131415161718192021222324typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) &#123; SDWebImageDownloaderLowPriority = 1 &lt;&lt; 0, //低优先级 SDWebImageDownloaderProgressiveDownload = 1 &lt;&lt; 1, //渐进式下载 SDWebImageDownloaderUseNSURLCache = 1 &lt;&lt; 2, //使用 NSURLCache 和默认缓存策略 /* * 如果图像是从 NSURLCache 读取的，则调用 completion block 时，image/imageData 传入 nil * (此标记要和 `SDWebImageDownloaderUseNSURLCache` 组合使用) */ SDWebImageDownloaderIgnoreCachedResponse = 1 &lt;&lt; 3, SDWebImageDownloaderContinueInBackground = 1 &lt;&lt; 4, //当 App 进入后台后仍然会继续下载图像 SDWebImageDownloaderHandleCookies = 1 &lt;&lt; 5, //处理保存在 NSHTTPCookieStore 中的 cookies SDWebImageDownloaderAllowInvalidSSLCertificates = 1 &lt;&lt; 6, //允许不信任的 SSL 证书 SDWebImageDownloaderHighPriority = 1 &lt;&lt; 7, //将图像放入高优先级队列 &#125; SDWebImageDownloaderExecutionOrderSDWebImageDownloaderExecutionOrder是图片下载操作的执行方式 123456typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) &#123; SDWebImageDownloaderFIFOExecutionOrder, //默认值，按照队列的先进先出方式执行 SDWebImageDownloaderLIFOExecutionOrder //按照堆栈的后进先出方式执行&#125;;","content":"<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/header/image/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-SDWebImage.png\" alt=\"\"></p>\n<blockquote>\n<p><a href=\"https://github.com/rs/SDWebImage\" target=\"_blank\" rel=\"external\">SDWebImage</a>是我们经常使用的一个异步图片加载库，大大提高了我们的开发效率。它支持从网络中下载且缓存图片，并设置图片到对应的UIImageView控件或者UIButton控件上。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"SDWebImage-概论\"><a href=\"#SDWebImage-概论\" class=\"headerlink\" title=\"SDWebImage 概论\"></a>SDWebImage 概论</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.提供了一个UIImageView的category用来加载网络图片并且对网络图片的缓存进行管理</div><div class=\"line\">2.采用异步方式来下载网络图片</div><div class=\"line\">3.采用异步方式，使用memory＋disk来缓存网络图片，自动管理缓存。</div><div class=\"line\">4.支持GIF动画,支持JEPG,JPG格式。</div><div class=\"line\">5.支持WebP格式</div><div class=\"line\">6.同一个URL的网络图片不会被重复下载</div><div class=\"line\">7.失效的URL不会被无限重试</div><div class=\"line\">8.耗时操作都在子线程，确保不会阻塞主线程</div><div class=\"line\">9.使用GCD和ARC</div><div class=\"line\">10.支持Arm64</div></pre></td></tr></table></figure>\n<p>##SDWebImage知识点的梳理</p>\n<ol>\n<li><p>正常程序退出后，会在几秒内停止工作,要想申请更长的时间，需要用到<code>beginBackgroundTaskWithExpirationHandler</code></p>\n</li>\n<li><p><code>endBackgroundTask</code>一定要成对出现</p>\n</li>\n<li><p>使用<code>NSdirectoryEnumerator</code>遍历所有的缓存文件不会有性能耗时的问题,检查某个文件是否存在或者检查是否为文件夹都会检查文件的inode 数据,而这个inode中包括file的各种attribute.</p>\n</li>\n<li><p>使用NSCache作为内存储存比NSDictionary的好处是:当系统资源要耗尽的时候可以自动的删减,NSCache不会自动的拷贝键,并且是线程安全的,比NSDictionary线程安全.</p>\n</li>\n<li><p>线程中<code>urlCallbacks</code>的增加,改动都是使用所有增改回调集合<code>URLCallbacks</code>的操作使用<code>dispatch_barrier_sync</code>放入队列<code>barrierQueue</code>中，而查询<code>URLCallbakcs</code>的操作只需使用<code>dispatch_sync</code>放入队列<code>barrierQueue</code>中。</p>\n</li>\n</ol>\n<p>要先说一些系统中锁的问题:</p>\n<p>同步锁<code>@synchronized(self)</code>在<code>self</code>上加一个同步锁,频繁滥用的话会导致程序会等待另外一段与此代码无关的执行完毕之后才能执行,会耗时.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[_lock lock];</div><div class=\"line\">//</div><div class=\"line\">[_lock unlock];</div></pre></td></tr></table></figure>\n<p>这样遇到死锁也会很麻烦,并且效率也不高.<br>一般情况下想要为代码加锁,最好使用CGD.将所有的操作放到串行队列中执行.而对于并行队列的话就需要,读取的话可以并发进行,并没有任何改动,而增加或者修改数据的话必须保证此时不能进行读取数据,那么可以使用<code>栅栏(barrier)</code>来设置.<strong>在队列中栅栏块必须单独执行,不能与其他一起执行.这对于并发队列来说,如果并发队列发下下面要处理的是栅栏块,那么会一直等前面所有的并发块执行完毕后才执行这个栅栏,而等栅栏执行完毕后才执行其后的并发任务</strong>.所以增加和修改使用栅栏可以保证线程安全.</p>\n<p>5.图片的解码.当你用 <code>UIImage</code> 或 <code>CGImageSource</code> 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 <code>UIImageView</code> 或者 <code>CALayer.contents</code> 中去，并且 <code>CALayer</code> 被提交到 <code>GPU</code> 前，<code>CGImage</code> 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 <code>CGBitmapContext</code> 中，然后从 <code>Bitmap</code> 直接创建图片。目前常见的网络图片库都自带这个功能。<code>SDWebImage</code>就是在后台生成这种位图.</p>\n<h2 id=\"SDWebImageManager结构\"><a href=\"#SDWebImageManager结构\" class=\"headerlink\" title=\"SDWebImageManager结构\"></a>SDWebImageManager结构</h2><p>关于结构，我们可以用一张流程图说明<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/SDWebImage%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png?watermark/2/text/QExpYmVyYWxpc20=/font/5a6L5L2T/fontsize/800/fill/IzhBMTgxOA==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" alt=\"\"></p>\n<h4 id=\"SDWebImageDownloaderOptions\"><a href=\"#SDWebImageDownloaderOptions\" class=\"headerlink\" title=\"SDWebImageDownloaderOptions\"></a>SDWebImageDownloaderOptions</h4><p><code>SDWebImageDownloaderOptions</code>是图片下载选项</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, SDWebImageDownloaderOptions) &#123;</div><div class=\"line\"></div><div class=\"line\">    SDWebImageDownloaderLowPriority = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,  <span class=\"comment\">//低优先级</span></div><div class=\"line\">    </div><div class=\"line\">    SDWebImageDownloaderProgressiveDownload = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,  <span class=\"comment\">//渐进式下载</span></div><div class=\"line\"></div><div class=\"line\">    SDWebImageDownloaderUseNSURLCache = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,  <span class=\"comment\">//使用 NSURLCache 和默认缓存策略</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     * 如果图像是从 NSURLCache 读取的，则调用 completion block 时，image/imageData 传入 nil</div><div class=\"line\">     * (此标记要和 `SDWebImageDownloaderUseNSURLCache` 组合使用)</div><div class=\"line\">     */</div><div class=\"line\">    SDWebImageDownloaderIgnoreCachedResponse = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span>,</div><div class=\"line\"></div><div class=\"line\">    SDWebImageDownloaderContinueInBackground = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>,  <span class=\"comment\">//当 App 进入后台后仍然会继续下载图像</span></div><div class=\"line\"></div><div class=\"line\">    SDWebImageDownloaderHandleCookies = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">5</span>, <span class=\"comment\">//处理保存在 NSHTTPCookieStore 中的 cookies</span></div><div class=\"line\"></div><div class=\"line\">    SDWebImageDownloaderAllowInvalidSSLCertificates = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">6</span>,  <span class=\"comment\">//允许不信任的 SSL 证书</span></div><div class=\"line\"></div><div class=\"line\">    SDWebImageDownloaderHighPriority = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">7</span>, <span class=\"comment\">//将图像放入高优先级队列</span></div><div class=\"line\">    </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"SDWebImageDownloaderExecutionOrder\"><a href=\"#SDWebImageDownloaderExecutionOrder\" class=\"headerlink\" title=\"SDWebImageDownloaderExecutionOrder\"></a>SDWebImageDownloaderExecutionOrder</h4><p><code>SDWebImageDownloaderExecutionOrder</code>是图片下载操作的执行方式</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, SDWebImageDownloaderExecutionOrder) &#123;</div><div class=\"line\">     </div><div class=\"line\">    SDWebImageDownloaderFIFOExecutionOrder,  <span class=\"comment\">//默认值，按照队列的先进先出方式执行</span></div><div class=\"line\"></div><div class=\"line\">    SDWebImageDownloaderLIFOExecutionOrder  <span class=\"comment\">//按照堆栈的后进先出方式执行</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n","excerpt":"SDWebImage是我们经常使用的一个异步图片加载库，大大提高了我们的开发效率。它支持从网络中下载且缓存图片，并设置图片到对应的UIImageView控件或者UIButton控件上。","categories":[],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"}]},{"title":"iOS知识总结-多线程","date":"2017-05-12T05:36:13.000Z","path":"2017/05/12/iOS知识总结-多线程/","text":"进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。 线程 进程要想执行任务，必须得有线程（每1个进程至少要有1条线程），线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。线程中任务的执行是串行的，如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务。也就是说，在同一时间内，1个线程只能执行1个任务。 多线程 即1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务。在同一时间里，CPU只能处理1条线程，只有1条线程在工作。多线程并发执行，其实是CPU快速地在多条线程之间切换，如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象 多线程优缺点优点 1.能适当提高程序的执行效率。 2.能适当提高资源利用率（CPU、内存利用率） 缺点 1.开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能。 2.线程越多，CPU在调度线程上的开销就越大。 3.程序设计更加复杂：比如线程之间的通信、多线程的数据共享 1234567891011121314151617181920212223245-2 NSThread a.特点： 1）使用更加面向对象 2）简单易用，可直接操作线程对象 b.使用语言：OC语言 c.使用频率：偶尔使用 d.线程生命周期：由程序员进行管理5-3 GCD a.特点： 1）旨在替代NSThread等线程技术 2）充分利用设备的多核（自动） b.使用语言：C语言 c.使用频率：经常使用 d.线程生命周期：自动管理5-4 NSOperation a.特点： 1）基于GCD（底层是GCD） 2）比GCD多了一些更简单实用的功能 3）使用更加面向对象 b.使用语言：OC语言 c.使用频率：经常使用 d.线程生命周期：自动管理 ###3 NSThread（1）NSThread的基本使用 123456789101112131415161718192021222324//第一种创建线程的方式：alloc init.//特点：需要手动开启线程，可以拿到线程对象进行详细设置 //创建线程 /* 第一个参数：目标对象 第二个参数：选择器，线程启动要调用哪个方法 第三个参数：前面方法要接收的参数（最多只能接收一个参数，没有则传nil） */ NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(run:) object:@\"wendingding\"]; //启动线程 [thread start];//第二种创建线程的方式：分离出一条子线程//特点：自动启动线程，无法对线程进行更详细的设置 /* 第一个参数：线程启动调用的方法 第二个参数：目标对象 第三个参数：传递给调用方法的参数 */ [NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@\"我是分离出来的子线程\"];//第三种创建线程的方式：后台线程//特点：自动启动县城，无法进行更详细设置[self performSelectorInBackground:@selector(run:) withObject:@\"我是后台线程\"]; （2）设置线程的属性 123456//设置线程的属性 //设置线程的名称 thread.name = @\"线程A\"; //设置线程的优先级,注意线程优先级的取值范围为0.0~1.0之间，1.0表示线程的优先级最高,如果不设置该值，那么理想状态下默认为0.5 thread.threadPriority = 1.0; （3）线程的状态（了解） 123456//线程的各种状态：新建-就绪-运行-阻塞-死亡//常用的控制线程状态的方法[NSThread exit];//退出当前线程[NSThread sleepForTimeInterval:2.0];//阻塞线程[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:2.0]];//阻塞线程//注意：线程死了不能复生 （4）线程安全 01 前提：多个线程访问同一块资源会发生数据安全问题 02 解决方案：加互斥锁 03 相关代码：@synchronized(self){} 04 专业术语-线程同步 05 原子和非原子属性（是否对setter方法加锁） （5）线程间通信 1234567891011121314151617181920212223242526272829-(void)touchesBegan:(nonnull NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event&#123;// [self download2]; //开启一条子线程来下载图片 [NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil];&#125;-(void)downloadImage&#123; //1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源 NSURL *url = [NSURL URLWithString:@\"http://p6.qhimg.com/t01d2954e2799c461ab.jpg\"]; //2.根据url地址下载图片数据到本地（二进制数据 NSData *data = [NSData dataWithContentsOfURL:url]; //3.把下载到本地的二进制数据转换成图片 UIImage *image = [UIImage imageWithData:data]; //4.回到主线程刷新UI //4.1 第一种方式// [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES]; //4.2 第二种方式// [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES]; //4.3 第三种方式 [self.imageView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:YES];&#125; （6）如何计算代码段的执行时间 1234567891011121314//第一种方法 NSDate *start = [NSDate date]; //2.根据url地址下载图片数据到本地（二进制数据） NSData *data = [NSData dataWithContentsOfURL:url]; NSDate *end = [NSDate date]; NSLog(@\"第二步操作花费的时间为%f\",[end timeIntervalSinceDate:start]);//第二种方法 CFTimeInterval start = CFAbsoluteTimeGetCurrent(); NSData *data = [NSData dataWithContentsOfURL:url]; CFTimeInterval end = CFAbsoluteTimeGetCurrent(); NSLog(@\"第二步操作花费的时间为%f\",end - start); ###4.GCD （1）GCD基本知识 01 两个核心概念-队列和任务 02 同步函数和异步函数 （2）GCD基本使用【重点】123456701 异步函数+并发队列：开启多条线程，并发执行任务02 异步函数+串行队列：开启一条线程，串行执行任务03 同步函数+并发队列：不开线程，串行执行任务04 同步函数+串行队列：不开线程，串行执行任务05 异步函数+主队列：不开线程，在主线程中串行执行任务06 同步函数+主队列：不开线程，串行执行任务（注意死锁发生）07 注意同步函数和异步函数在执行顺序上面的差异 （3）GCD线程间通信 123456789101112131415161718192021//0.获取一个全局的队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //1.先开启一个线程，把下载图片的操作放在子线程中处理 dispatch_async(queue, ^&#123; //2.下载图片 NSURL *url = [NSURL URLWithString:@\"http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg\"]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; NSLog(@\"下载操作所在的线程--%@\",[NSThread currentThread]); //3.回到主线程刷新UI dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; //打印查看当前线程 NSLog(@\"刷新UI---%@\",[NSThread currentThread]); &#125;); &#125;); （4）GCD其它常用函数 12345678910111213141516171819202122232425262728293031323334353637 01 栅栏函数（控制任务的执行顺序） dispatch_barrier_async(queue, ^&#123; NSLog(@\"--dispatch_barrier_async-\"); &#125;); 02 延迟执行（延迟·控制在哪个线程执行） dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@\"---%@\",[NSThread currentThread]); &#125;); 03 一次性代码（注意不能放到懒加载） -(void)once &#123; //整个程序运行过程中只会执行一次 //onceToken用来记录该部分的代码是否被执行过 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@\"-----\"); &#125;); &#125; 04 快速迭代（开多个线程并发完成迭代操作） dispatch_apply(subpaths.count, queue, ^(size_t index) &#123; &#125;); 05 队列组（同栅栏函数） //创建队列组 dispatch_group_t group = dispatch_group_create(); //队列组中的任务执行完毕之后，执行该函数 dispatch_group_notify(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block);06进入群组和离开群组 dispatch_group_enter(group);//执行该函数后，后面异步执行的block会被gruop监听 dispatch_group_leave(group);//异步block中，所有的任务都执行完毕，最后离开群组 //注意：dispatch_group_enter|dispatch_group_leave必须成对使用","content":"<p><strong>进程</strong>是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a><strong>线程</strong></h2><blockquote>\n<p>进程要想执行任务，必须得有线程（每1个进程至少要有1条线程），线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。线程中任务的执行是串行的，如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务。也就是说，在同一时间内，1个线程只能执行1个任务。</p>\n</blockquote>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a><strong>多线程</strong></h2><blockquote>\n<p> 即1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务。在同一时间里，CPU只能处理1条线程，只有1条线程在工作。多线程并发执行，其实是CPU快速地在多条线程之间切换，如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"多线程优缺点\"><a href=\"#多线程优缺点\" class=\"headerlink\" title=\"多线程优缺点\"></a><strong>多线程优缺点</strong></h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><blockquote>\n<p>1.能适当提高程序的执行效率。<br>  2.能适当提高资源利用率（CPU、内存利用率）</p>\n</blockquote>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><blockquote>\n<p>1.开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能。<br>  2.线程越多，CPU在调度线程上的开销就越大。<br>  3.程序设计更加复杂：比如线程之间的通信、多线程的数据共享</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">5</span><span class=\"number\">-2</span> <span class=\"built_in\">NSThread</span></div><div class=\"line\">\ta.特点：</div><div class=\"line\">\t    <span class=\"number\">1</span>）使用更加面向对象</div><div class=\"line\">\t    <span class=\"number\">2</span>）简单易用，可直接操作线程对象</div><div class=\"line\">\tb.使用语言：OC语言</div><div class=\"line\">\tc.使用频率：偶尔使用</div><div class=\"line\">\td.线程生命周期：由程序员进行管理</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5</span><span class=\"number\">-3</span> GCD</div><div class=\"line\">\ta.特点：</div><div class=\"line\">\t    <span class=\"number\">1</span>）旨在替代<span class=\"built_in\">NSThread</span>等线程技术</div><div class=\"line\">\t    <span class=\"number\">2</span>）充分利用设备的多核（自动）</div><div class=\"line\">\tb.使用语言：C语言</div><div class=\"line\">\tc.使用频率：经常使用</div><div class=\"line\">\td.线程生命周期：自动管理</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5</span><span class=\"number\">-4</span> <span class=\"built_in\">NSOperation</span></div><div class=\"line\">\ta.特点：</div><div class=\"line\">\t    <span class=\"number\">1</span>）基于GCD（底层是GCD）</div><div class=\"line\">\t    <span class=\"number\">2</span>）比GCD多了一些更简单实用的功能</div><div class=\"line\">\t    <span class=\"number\">3</span>）使用更加面向对象</div><div class=\"line\">\tb.使用语言：OC语言</div><div class=\"line\">\tc.使用频率：经常使用</div><div class=\"line\">\td.线程生命周期：自动管理</div></pre></td></tr></table></figure>\n<p>###3 NSThread<br>（1）NSThread的基本使用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//第一种创建线程的方式：alloc init.</span></div><div class=\"line\"><span class=\"comment\">//特点：需要手动开启线程，可以拿到线程对象进行详细设置</span></div><div class=\"line\">    <span class=\"comment\">//创建线程</span></div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     第一个参数：目标对象</div><div class=\"line\">     第二个参数：选择器，线程启动要调用哪个方法</div><div class=\"line\">     第三个参数：前面方法要接收的参数（最多只能接收一个参数，没有则传nil）</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"built_in\">NSThread</span> *thread = [[<span class=\"built_in\">NSThread</span> alloc]initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run:) object:<span class=\"string\">@\"wendingding\"</span>];</div><div class=\"line\">     <span class=\"comment\">//启动线程</span></div><div class=\"line\">    [thread start];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第二种创建线程的方式：分离出一条子线程</span></div><div class=\"line\"><span class=\"comment\">//特点：自动启动线程，无法对线程进行更详细的设置</span></div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     第一个参数：线程启动调用的方法</div><div class=\"line\">     第二个参数：目标对象</div><div class=\"line\">     第三个参数：传递给调用方法的参数</div><div class=\"line\">     */</div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(run:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"我是分离出来的子线程\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第三种创建线程的方式：后台线程</span></div><div class=\"line\"><span class=\"comment\">//特点：自动启动县城，无法进行更详细设置</span></div><div class=\"line\">[<span class=\"keyword\">self</span> performSelectorInBackground:<span class=\"keyword\">@selector</span>(run:) withObject:<span class=\"string\">@\"我是后台线程\"</span>];</div></pre></td></tr></table></figure>\n<p>（2）设置线程的属性</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置线程的属性</span></div><div class=\"line\"> <span class=\"comment\">//设置线程的名称</span></div><div class=\"line\"> thread.name = <span class=\"string\">@\"线程A\"</span>;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">//设置线程的优先级,注意线程优先级的取值范围为0.0~1.0之间，1.0表示线程的优先级最高,如果不设置该值，那么理想状态下默认为0.5</span></div><div class=\"line\"> thread.threadPriority = <span class=\"number\">1.0</span>;</div></pre></td></tr></table></figure>\n<p>（3）线程的状态（了解）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//线程的各种状态：新建-就绪-运行-阻塞-死亡</span></div><div class=\"line\"><span class=\"comment\">//常用的控制线程状态的方法</span></div><div class=\"line\">[<span class=\"built_in\">NSThread</span> exit];<span class=\"comment\">//退出当前线程</span></div><div class=\"line\">[<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">2.0</span>];<span class=\"comment\">//阻塞线程</span></div><div class=\"line\">[<span class=\"built_in\">NSThread</span> sleepUntilDate:[<span class=\"built_in\">NSDate</span> dateWithTimeIntervalSinceNow:<span class=\"number\">2.0</span>]];<span class=\"comment\">//阻塞线程</span></div><div class=\"line\"><span class=\"comment\">//注意：线程死了不能复生</span></div></pre></td></tr></table></figure>\n<p>（4）线程安全</p>\n<pre><code>01 前提：多个线程访问同一块资源会发生数据安全问题\n02 解决方案：加互斥锁\n03 相关代码：@synchronized(self){}\n04 专业术语-线程同步\n05 原子和非原子属性（是否对setter方法加锁）\n</code></pre><p>（5）线程间通信</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"keyword\">nonnull</span> <span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"comment\">//    [self download2];</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//开启一条子线程来下载图片</span></div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(downloadImage) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)downloadImage</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源</span></div><div class=\"line\">    <span class=\"built_in\">NSURL</span> *url = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://p6.qhimg.com/t01d2954e2799c461ab.jpg\"</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//2.根据url地址下载图片数据到本地（二进制数据</span></div><div class=\"line\">    <span class=\"built_in\">NSData</span> *data = [<span class=\"built_in\">NSData</span> dataWithContentsOfURL:url];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//3.把下载到本地的二进制数据转换成图片</span></div><div class=\"line\">    <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageWithData:data];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//4.回到主线程刷新UI</span></div><div class=\"line\">    <span class=\"comment\">//4.1 第一种方式</span></div><div class=\"line\"><span class=\"comment\">//    [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES];</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//4.2 第二种方式</span></div><div class=\"line\"><span class=\"comment\">//    [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES];</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//4.3 第三种方式</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.imageView performSelector:<span class=\"keyword\">@selector</span>(setImage:) onThread:[<span class=\"built_in\">NSThread</span> mainThread] withObject:image waitUntilDone:<span class=\"literal\">YES</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（6）如何计算代码段的执行时间</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//第一种方法</span></div><div class=\"line\">    <span class=\"built_in\">NSDate</span> *start = [<span class=\"built_in\">NSDate</span> date];</div><div class=\"line\">    <span class=\"comment\">//2.根据url地址下载图片数据到本地（二进制数据）</span></div><div class=\"line\">    <span class=\"built_in\">NSData</span> *data = [<span class=\"built_in\">NSData</span> dataWithContentsOfURL:url];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSDate</span> *end = [<span class=\"built_in\">NSDate</span> date];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第二步操作花费的时间为%f\"</span>,[end timeIntervalSinceDate:start]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第二种方法</span></div><div class=\"line\">    <span class=\"built_in\">CFTimeInterval</span> start = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</div><div class=\"line\">    <span class=\"built_in\">NSData</span> *data = [<span class=\"built_in\">NSData</span> dataWithContentsOfURL:url];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">CFTimeInterval</span> end = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第二步操作花费的时间为%f\"</span>,end - start);</div></pre></td></tr></table></figure>\n<p>###4.GCD</p>\n<p>（1）GCD基本知识</p>\n<pre><code>01 两个核心概念-队列和任务\n02 同步函数和异步函数\n</code></pre><p>（2）GCD基本使用【重点】<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">01</span> 异步函数+并发队列：开启多条线程，并发执行任务</div><div class=\"line\"><span class=\"number\">02</span> 异步函数+串行队列：开启一条线程，串行执行任务</div><div class=\"line\"><span class=\"number\">03</span> 同步函数+并发队列：不开线程，串行执行任务</div><div class=\"line\"><span class=\"number\">04</span> 同步函数+串行队列：不开线程，串行执行任务</div><div class=\"line\"><span class=\"number\">05</span> 异步函数+主队列：不开线程，在主线程中串行执行任务</div><div class=\"line\"><span class=\"number\">06</span> 同步函数+主队列：不开线程，串行执行任务（注意死锁发生）</div><div class=\"line\"><span class=\"number\">07</span> 注意同步函数和异步函数在执行顺序上面的差异</div></pre></td></tr></table></figure></p>\n<p>（3）GCD线程间通信</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//0.获取一个全局的队列</span></div><div class=\"line\">   <span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">//1.先开启一个线程，把下载图片的操作放在子线程中处理</span></div><div class=\"line\">   <span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">//2.下载图片</span></div><div class=\"line\">       <span class=\"built_in\">NSURL</span> *url = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg\"</span>];</div><div class=\"line\">       <span class=\"built_in\">NSData</span> *data = [<span class=\"built_in\">NSData</span> dataWithContentsOfURL:url];</div><div class=\"line\">       <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageWithData:data];</div><div class=\"line\"></div><div class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"下载操作所在的线程--%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//3.回到主线程刷新UI</span></div><div class=\"line\">       <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">          <span class=\"keyword\">self</span>.imageView.image = image;</div><div class=\"line\">          <span class=\"comment\">//打印查看当前线程</span></div><div class=\"line\">           <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"刷新UI---%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">       &#125;);</div><div class=\"line\"></div><div class=\"line\">   &#125;);</div></pre></td></tr></table></figure>\n<p>（4）GCD其它常用函数</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">   <span class=\"number\">01</span> 栅栏函数（控制任务的执行顺序）</div><div class=\"line\">   dispatch_barrier_async(queue, ^&#123;</div><div class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"--dispatch_barrier_async-\"</span>);</div><div class=\"line\">   &#125;);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"number\">02</span> 延迟执行（延迟·控制在哪个线程执行）</div><div class=\"line\">     dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"---%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">   &#125;);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"number\">03</span> 一次性代码（注意不能放到懒加载）</div><div class=\"line\">   -(<span class=\"keyword\">void</span>)once</div><div class=\"line\">   &#123;</div><div class=\"line\">       <span class=\"comment\">//整个程序运行过程中只会执行一次</span></div><div class=\"line\">       <span class=\"comment\">//onceToken用来记录该部分的代码是否被执行过</span></div><div class=\"line\">       <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</div><div class=\"line\">       <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class=\"line\"></div><div class=\"line\">           <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"-----\"</span>);</div><div class=\"line\">       &#125;);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"number\">04</span> 快速迭代（开多个线程并发完成迭代操作）</div><div class=\"line\">      dispatch_apply(subpaths.count, queue, ^(size_t index) &#123;</div><div class=\"line\">   &#125;);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"number\">05</span> 队列组（同栅栏函数）</div><div class=\"line\">   <span class=\"comment\">//创建队列组</span></div><div class=\"line\">   dispatch_group_t group = dispatch_group_create();</div><div class=\"line\">   <span class=\"comment\">//队列组中的任务执行完毕之后，执行该函数</span></div><div class=\"line\">   dispatch_group_notify(dispatch_group_t group,<span class=\"built_in\">dispatch_queue_t</span> queue,dispatch_block_t block);</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">06</span>进入群组和离开群组</div><div class=\"line\">   dispatch_group_enter(group);<span class=\"comment\">//执行该函数后，后面异步执行的block会被gruop监听</span></div><div class=\"line\">   dispatch_group_leave(group);<span class=\"comment\">//异步block中，所有的任务都执行完毕，最后离开群组</span></div><div class=\"line\">   <span class=\"comment\">//注意：dispatch_group_enter|dispatch_group_leave必须成对使用</span></div></pre></td></tr></table></figure>\n","excerpt":"进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。 线程 进程要想执行任务，必须得有线程（每1个进程至少要有1条线程），线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。线程中任务的执行是串行的，如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务。也就是说，在同一时间内，1个线程只能执行1个任务。 多线程 即1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务。在同一时间里，CPU只能处理1条线程，只有1条线程在工作。多线程并发执行，其实是CPU快速地在多条线程之间切换，如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象","categories":[],"tags":[{"name":"知识总结","slug":"知识总结","permalink":"http://yoursite.com/tags/知识总结/"}]},{"title":"iOS常用设计模式","date":"2017-05-10T07:28:43.000Z","path":"2017/05/10/iOS常用设计模式/","text":"一、何为设计模式 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。","content":"<p>一、何为设计模式</p>\n<p><code>设计模式（Design pattern）</code>是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p>\n","excerpt":"","categories":[],"tags":[{"name":"知识总结","slug":"知识总结","permalink":"http://yoursite.com/tags/知识总结/"}]},{"title":"iOS知识总结-基础篇-2","date":"2017-04-25T05:43:49.000Z","path":"2017/04/25/iOS知识总结-基础篇-2/","text":"文章大纲，便于浏览 1.NSTimer以下文章详细讲述了NSTimer的创建、销毁以及与NSRunLoop的关系，通读几遍，就可以融会贯通了 2.iOS应用程序间共享数据这篇文章义工介绍了四种应用程序间共享数据的方法 3.开源许可说明 4.枚举的三种写法 普通写法 12345typedef enum&#123; GZQDemoTypeTop, GZQDemoTypeBottom,&#125;GZQDemoType; 文艺写法 123456定义类型typedef NS_ENUM(NSInteger,GZQType)&#123; GZQTypeTop, GZQTypeBottom,&#125;; 推荐写法（可以进行位运算，更加灵活） 12345678typedef NS_OPTIONS(NSInteger, GZQActionType)&#123; GZQActionTypeA = 1&lt;&lt;0, GZQActionTypeb = 1&lt;&lt;1, GZQActionTypec = 1&lt;&lt;2, GZQActionTypeD = 1&lt;&lt;3,&#125; 5.didReceiveMemoryWarning当系统内存告急时，会接收到didReceiveMemoryWarning。这是属于ViewController的方法，当ViewController接收到didReceiveMemoryWarning，首先会判断当前的ViewController是否还显示在window上，如果不在就会移除当前的ViewController，销毁ViewController上面的子控件，并执行ViewDidUnload方法 具体参考下图：","content":"<p>文章大纲，便于浏览</p>\n<h3 id=\"1-NSTimer\"><a href=\"#1-NSTimer\" class=\"headerlink\" title=\"1.NSTimer\"></a>1.NSTimer</h3><p>以下<a href=\"http://www.jianshu.com/p/330d7310339d\" target=\"_blank\" rel=\"external\">文章</a>详细讲述了NSTimer的创建、销毁以及与NSRunLoop的关系，通读几遍，就可以融会贯通了</p>\n<h3 id=\"2-iOS应用程序间共享数据\"><a href=\"#2-iOS应用程序间共享数据\" class=\"headerlink\" title=\"2.iOS应用程序间共享数据\"></a>2.iOS应用程序间共享数据</h3><p>这篇<a href=\"http://www.jianshu.com/p/169e31cacf42\" target=\"_blank\" rel=\"external\">文章</a>义工介绍了四种应用程序间共享数据的方法</p>\n<h3 id=\"3-开源许可说明\"><a href=\"#3-开源许可说明\" class=\"headerlink\" title=\"3.开源许可说明\"></a>3.开源许可说明</h3><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%B4%E6%98%8E.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"4-枚举的三种写法\"><a href=\"#4-枚举的三种写法\" class=\"headerlink\" title=\"4.枚举的三种写法\"></a>4.枚举的三种写法</h3><ul>\n<li>普通写法</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span></div><div class=\"line\">&#123;</div><div class=\"line\">    GZQDemoTypeTop,</div><div class=\"line\">    GZQDemoTypeBottom,</div><div class=\"line\">&#125;GZQDemoType;</div></pre></td></tr></table></figure>\n<ul>\n<li>文艺写法</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">定义类型</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>,GZQType)</div><div class=\"line\">&#123;</div><div class=\"line\">    GZQTypeTop,</div><div class=\"line\">    GZQTypeBottom,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li>推荐写法（可以进行位运算，更加灵活）</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSInteger</span>, GZQActionType)</div><div class=\"line\">&#123;</div><div class=\"line\">    GZQActionTypeA = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">0</span>,</div><div class=\"line\">    GZQActionTypeb = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>,</div><div class=\"line\">    GZQActionTypec = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>,</div><div class=\"line\">    GZQActionTypeD = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span>,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"5-didReceiveMemoryWarning\"><a href=\"#5-didReceiveMemoryWarning\" class=\"headerlink\" title=\"5.didReceiveMemoryWarning\"></a>5.didReceiveMemoryWarning</h3><p>当系统内存告急时，会接收到<code>didReceiveMemoryWarning</code>。<br>这是属于<code>ViewController</code>的方法，当<code>ViewController</code>接收到<code>didReceiveMemoryWarning</code>，首先会判断当前的<code>ViewController</code>是否还显示在<code>window</code>上，如果不在就会移除当前的<code>ViewController</code>，销毁<code>ViewController</code>上面的子控件，并执行<code>ViewDidUnload</code>方法</p>\n<p>具体参考下图：</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/MemoryWarning.png\" alt=\"\"></p>\n","excerpt":"文章大纲，便于浏览 1.NSTimer以下文章详细讲述了NSTimer的创建、销毁以及与NSRunLoop的关系，通读几遍，就可以融会贯通了 2.iOS应用程序间共享数据这篇文章义工介绍了四种应用程序间共享数据的方法 3.开源许可说明","categories":[],"tags":[{"name":"知识总结","slug":"知识总结","permalink":"http://yoursite.com/tags/知识总结/"}]},{"title":"iOS知识总结-基础篇-1","date":"2017-04-15T15:43:49.000Z","path":"2017/04/15/iOS知识总结-基础篇-1/","text":"文章大纲，便于浏览 01-iOS程序启动过程 02-浅拷贝-深拷贝 03-View的生命周期 04-@property 05-事件传递和事件响应 06-KVC 07-KVO 08-iOS数据持久化方案 01-iOS-App-startup-process一、启动完整过程 1.main函数 2.UIApplicationMain函数 创建UIApplication对象 创建UIApplication的delegate对象 3.delegate对象开始处理(监听)系统事件(没有storyboard) 程序启动完毕的时候, 就会调用代理的:didFinishLaunchingWithOptions:方法 在application:didFinishLaunchingWithOptions:中创建UIWindow 创建和设置UIWindow的rootViewController 显示窗口 4.根据Info.plist获得最主要storyboard的文件名,加载最主要的storyboard(有storyboard) 创建UIWindow 创建和设置UIWindow的rootViewController 显示窗口 ###二、程序启动原理 1.main函数中执行了一个UIApplicationMain这个函数 123int UIApplicationMain(int argc, char *argv[], NSString *principalClassName, NSString *delegateClassName);argc、argv：直接传递给UIApplicationMain进行相关处理即可 2.principalClassName：指定应用程序类名（app的象征），该类必须是UIApplication(或子类)。如果为nil,则用UIApplication类作为默认值 3.delegateClassName：指定应用程序的代理类，该类必须遵守UIApplicationDelegate协议 4.UIApplicationMain函数会根据principalClassName创建UIApplication对象，根据delegateClassName创建一个delegate对象，并将该delegate对象赋值给UIApplication对象中的delegate属性 5.接着会建立应用程序的Main Runloop（事件循环），进行事件的处理(首先会在程序完毕后调用delegate对象的application:didFinishLaunchingWithOptions:方法) 程序正常退出时UIApplicationMain函数才返回 1234567891011int main(int argc, char * argv[])&#123; @autoreleasepool &#123; /*** argc: 系统或者用户传入的参数个数* argv: 系统或者用户传入的实际参数 * 1.根据传入的第三个参数创建UIApplication对象 * 2.根据传入的第四个产生创建UIApplication对象的代理* 3.设置刚刚创建出来的代理对象为UIApplication的代理 * 4.开启一个事件循环 **/ return UIApplicationMain(argc, argv, @\"UIApplication\", @\"YYAppDelegate\"); &#125;&#125; 启动与代理： 02-ShallowCopy-DeepCopy简要总结一下什么是浅拷贝，什么是深拷贝 深拷贝就是内容拷贝（分为单层拷贝、完全拷贝），深拷贝的之所以分为两类，主要是针对集合类 浅拷贝就是指针拷贝 ####一.系统对象的 copy/mutableCopy 1234567891011121314151617NSString *string = @\"LiMing\"; NSString *copyString = [string copy]; NSString *mutableString = [string mutableCopy]; NSLog(@\"string = %p\",string); NSLog(@\"copyString = %p\",copyString); NSLog(@\"mutableString = %p \",mutableString);结论：1.string 和 copyString 他们只是二个不同的指针，指向内存中的同一块地址，copy 只是指针复制2.string 和 mutableString 打印出来的地址不同，是因为两个指针指向的地址本就不同，mutableCopy 是内容复制注意：其他对象 NSArray 、NSMutableArray 、NSDictionary 、NSMutableDictionary 一样适用 规律可以从这张图看出来 ####二.自定义对象实现 Copy-MutableCopy copy 1234GZQPerson *person = [[GZQPerson alloc] init];person.age = 20;person.name = @\"GZQ\";GZQPerson *copyP = [person copy]; // 这里崩溃 崩溃： 看崩溃信息GZQPerson应该先实现： 1- (id)copyWithZone:(NSZone *)zone; 测试： 12345678910111213141516171819202122232425#import \"GZQPerson.h\"@interface GZQPerson ()&lt;NSCopying,NSMutableCopying&gt;@end@implementation GZQPerson- (id)copyWithZone:(NSZone *)zone &#123; GZQPerson *person = [[[self class] allocWithZone:zone] init]; person.age = self.age; person.name = self.name; return person;&#125;- (id)mutableCopyWithZone:(NSZone *)zone &#123; GZQPerson *person = [[[self class] allocWithZone:zone] init]; person.age = self.age; person.name = self.name; return person;&#125;@end 12345678910111213141516171819202122232425#import \"ViewController.h\"#import \"GZQPerson.h\"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; GZQPerson *person = [[GZQPerson alloc] init]; person.age = 20; person.name = @\"GZQ\"; GZQPerson *copyP = [person copy]; NSLog(@\"copyP=%p\",copyP); NSLog(@\"person=%p\",person); NSLog(@\"person=%p\",copyP.name); NSLog(@\"person=%p\",person.name); &#125;@end 可以看出虽然指针的地址不同，但是存储的地址是一致的。 ####三.copy 本质 property copy 实际上就对name干了这个： 12345678#import &lt;Foundation/Foundation.h&gt;property copy 实际上就对name干了这个：- (void)setName:(NSString *)name&#123; _name = [name copy];&#125; strong是不执行Copy操作的 1234567891011@property (nonatomic, strong) NSString *name;NSMutableString *string = [NSMutableString stringWithFormat:@\"深拷贝-浅拷贝\"];GZQPerson *person = [[GZQPerson alloc] init];person.name = string;// 可以改变person.name的值，因为其内部没有生成新的对象[string appendString:@\"LALALA\"];NSLog(@\"name = %@\", person.name); ####四.集合类 Copy MutableCopy 操作 单层深复制，也就是我们经常说的深复制，我这里说的单层深复制是对于集合类所说的(即NSArray,NSDictionary,NSSet)，单层深复制指的是只复制了该集合类的最外层，里边的元素没有复制，(即这两个集合类的地址不一样，但是两个集合里所存储的元素的地址是一样的) 完全复制，指的是完全复制整个集合类，也就是说两个集合地址不一样，里边所存储的元素地址也不一样 实现多层完全拷贝也很简单 1NSArray *copyArray = [[NSArray alloc] initWithArray:array copyItems:YES]; // 完全复制 03-View的生命周期 读懂这一张图即可 04-@property @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的 @property 的本质. 1@property = ivar + getter + setter; 下面解释下： “属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。 “属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示: 编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说： 1@property = getter + setter; 例如下面这个类： 1234@interface Person : NSObject@property NSString *firstName;@property NSString *lastName;@end 上述代码写出来的类与下面这种写法等效： 123456@interface Person : NSObject- (NSString *)firstName;- (void)setFirstName:(NSString *)firstName;- (NSString *)lastName;- (void)setLastName:(NSString *)lastName;@end property在runtime中是objc_property_t定义如下: 1typedef struct objc_property *objc_property_t; 而objc_property是一个结构体，包括name和attributes，定义如下： 1234struct property_t &#123; const char *name; const char *attributes;&#125;; 而attributes本质是objc_property_attribute_t，定义了property的一些属性，定义如下： 12345/// Defines a property attributetypedef struct &#123; const char *name; /**&lt; The name of the attribute */ const char *value; /**&lt; The value of the attribute (usually empty) */&#125; objc_property_attribute_t; 而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。 例如：我们定义一个string的property 1@property (nonatomic, copy) NSString *string; 通过 property_getAttributes(property)获取到attributes并打印出来之后的结果为 1T@\"NSString\",C,N,V_string 其中T就代表类型，可参阅Type Encodings，C就代表Copy，N代表nonatomic，V就代表对于的实例变量。 ivar、getter、setter 是如何生成并添加到这个类中的? “自动合成”( autosynthesis) 完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过@synthesize 语法来指定实例变量的名字. 1234@implementation Person@synthesize firstName = _myFirstName;@synthesize lastName = _myLastName;@end 我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西 1234561. OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。2. setter 与 getter 方法对应的实现函数3. ivar_list ：成员变量列表4. method_list ：方法列表5. prop_list ：属性列表也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转. 属性可以拥有的特质分为四类: 原子性— nonatomic 特质,在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。 读/写权限—readwrite(读写)、readonly (只读) 内存管理语义—assign、strong、 weak、unsafe_unretained、copy 方法名—getter= 、setter= getter=的样式： 123@property (nonatomic, getter=isOn) BOOL on; (`setter=`这种不常用，也不推荐使用。故不在这里给出写法。） setter=一般用在特殊的情境下，比如： 在数据反序列化、转模型的过程中，服务器返回的字段如果以 init 开头，所以你需要定义一个 init 开头的属性，但默认生成的 setter 与 getter 方法也会以 init 开头，而编译器会把所有以 init 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。 这时你就可以使用下面的方式来避免编译器报错： 1@property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:)NSString *initBy; 另外也可以用关键字进行特殊说明，来避免编译器报错： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@property(nonatomic, readwrite, copy, null_resettable) NSString *initBy;- (NSString *)initBy __attribute__((objc_method_family(none)));1. 不常用的：nonnull,null_resettable,nullable注意：很多人会认为如果属性具备 nonatomic 特质，则不使用 “同步锁”。其实在属性设置方法中使用的是自旋锁，自旋锁相关代码如下：static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)&#123; if (offset == 0) &#123; object_setClass(self, newValue); return; &#125; id oldValue; id *slot = (id*) ((char*)self + offset); if (copy) &#123; newValue = [newValue copyWithZone:nil]; &#125; else if (mutableCopy) &#123; newValue = [newValue mutableCopyWithZone:nil]; &#125; else &#123; if (*slot == newValue) return; newValue = objc_retain(newValue); &#125; if (!atomic) &#123; oldValue = *slot; *slot = newValue; &#125; else &#123; spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); &#125; objc_release(oldValue);&#125;void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) &#123; bool copy = (shouldCopy &amp;&amp; shouldCopy != MUTABLE_COPY); bool mutableCopy = (shouldCopy == MUTABLE_COPY); reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);&#125; 05-事件传递和事件响应这部分知识如果自己总结，篇幅较长。可以参考以下文章 06-KVCKey-Value Coding (KVC) KVC（Key-value coding）键值编码，单看这个名字可能不太好理解。其实翻译一下就很简单了，就是指iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值。而不需要调用明确的存取方法。这样就可以在运行时动态在访问和修改对象的属性。而不是在编译时确定，这也是iOS开发中的黑魔法之一。很多高级的iOS开发技巧都是基于KVC实现的。目前网上关于KVC的文章在非常多，有的只是简单地说了下用法，有的讲得深入但是在使用场景和最佳实践没有说明，我写下这遍文章就是给大家详解一个最完整最详细的KVC。 KVC在iOS中的定义 无论是Swift还是Objective-C，KVC的定义都是对NSObject的扩展来实现的(Objective-C中有个显式的NSKeyValueCoding类别名，而Swift没有，也不需要)所以对于所有继承了NSObject在类型，都能使用KVC(一些纯Swift类和结构体是不支持KVC的)，下面是KVC最为重要的四个方法 1234- (nullable id)valueForKey:(NSString *)key; //直接通过Key来取值- (void)setValue:(nullable id)value forKey:(NSString *)key; //通过Key来设值- (nullable id)valueForKeyPath:(NSString *)keyPath; //通过KeyPath来取值- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; //通过KeyPath来设值 当然NSKeyValueCoding类别中还有其他的一些方法，下面列举一些 1234567891011121314+ (BOOL)accessInstanceVariablesDirectly;//默认返回YES，表示如果没有找到Set&lt;Key&gt;方法的话，会按照_key，_iskey，key，iskey的顺序搜索成员，设置成NO就不这样搜索- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;//KVC提供属性值确认的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;//这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回- (nullable id)valueForUndefinedKey:(NSString *)key;//如果Key不存在，且没有KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;//和上一个方法一样，只不过是设值。- (void)setNilValueForKey:(NSString *)key;//如果你在SetValue方法时面给Value传nil，则会调用这个方法- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;//输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。 上面的这些方法在碰到特殊情况或者有特殊需求还是会用到的，所以也是可以了解一下。后面的代码示例会有讲到其中的一些方法。同时苹果对一些容器类比如NSArray或者NSSet等，KVC有着特殊的实现。建议有基础的或者英文好的开发者直接去看苹果的官方文档，相信你会对KVC的理解更上一个台阶。 KVC是怎么寻找Key的 KVC是怎么使用的，我相信绝大多数的开发者都很清楚，我在这里就不再写简单的使用KVC来设值和取值的代码了，首页我们来探讨KVC在内部是按什么样的顺序来寻找key的。当调用setValue：属性值 forKey：``@”name“的代码时，底层的执行机制如下： 程序优先调用set&lt;Key&gt;:属性值方法，代码通过setter方法完成设置。注意，这里的&lt;key&gt;是指成员变量名，首字母大清写要符合KVC的全名规则，下同 如果没有找到setName：方法，KVC机制会检查+ (BOOL)accessInstanceVariablesDirectly方法有没有返回YES，默认该方法会返回YES，如果你重写了该方法让其返回NO的话，那么在这一步KVC会执行setValue：forUNdefinedKey：方法，不过一般开发者不会这么做。所以KVC机制会搜索该类里面有没有名为_&lt;key&gt;的成员变量，无论该变量是在类接口部分定义，还是在类实现部分定义，也无论用了什么样的访问修饰符，只在存在以_&lt;key&gt;命名的变量，KVC都可以对该成员变量赋值。 如果该类即没有set&lt;Key&gt;：方法，也没有_&lt;key&gt;成员变量，KVC机制会搜索_is&lt;Key&gt;的成员变量， 和上面一样，如果该类即没有set&lt;Key&gt;：方法，也没有_&lt;key&gt;和_is&lt;Key&gt;成员变量，KVC机制再会继续搜索&lt;key&gt;和is&lt;Key&gt;的成员变量。再给它们赋值。 如果上面列出的方法或者成员变量都不存在，系统将会执行该对象的setValue：forUNdefinedKey：方法，默认是抛出异常。 如果开发者想让这个类禁用KVC里，那么重写+ (BOOL)accessInstanceVariablesDirectly方法让其返回NO即可，这样的话如果KVC没有找到set&lt;Key&gt;:属性名时，会直接用setValue：forUNdefinedKey：方法。 07-KVOKVO，全称为Key-Value Observing，是iOS中的一种设计模式，用于检测对象的某些属性的实时变化情况并作出响应。当应用场景比较复杂时，多个地方存在crash的危险。 首先，假设我们的目标是在一个UITableViewController内对tableview的contentOffset进行实时监测，很容易地使用KVO来实现为。 在初始化方法中加入： 12345678910111213[_tableView addObserver:self forKeyPath:@\"contentOffset\" options:NSKeyValueObservingOptionNew context:nil];// 在dealloc中移除KVO监听：[_tableView removeObserver:self forKeyPath:@\"contentOffset\" context:nil];// 添加默认的响应回调方法：- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; [self doSomethingWhenContentOffsetChanges];&#125; 好了，KVO实现就到此完美结束了，开玩笑，肯定没这么简单的，这样的代码太粗糙了，当你在controller中添加多个KVO时，所有的回调都是走同上述函数，那就必须对触发回调函数的来源进行判断。判断如下： 12345678910- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if (object == _tableView &amp;&amp; [keyPath isEqualToString:@\"contentOffset\"]) &#123; [self doSomethingWhenContentOffsetChanges]; &#125;&#125; 你以为这样就结束了吗？答案是否定的！我们假设当前类(在例子中为UITableViewController)还有父类，并且父类也有自己绑定了一些其他KVO呢？我们看到，上述回调函数体中只有一个判断，如果这个if不成立，这次KVO事件的触发就会到此中断了。但事实上，若当前类无法捕捉到这个KVO，那很有可能是在他的superClass，或者super-superClass...中，上述处理砍断了这个链。合理的处理方式应该是这样的： 1234567891011121314- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if (object == _tableView &amp;&amp; [keyPath isEqualToString:@\"contentOffset\"]) &#123; [self doSomethingWhenContentOffsetChanges]; &#125; else &#123; [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; &#125;&#125; 这样就结束了吗？答案仍旧是否定的。潜在的问题有可能出现在dealloc中对KVO的注销上。KVO的一种缺陷(其实不能称为缺陷，应该称为特性)是，当对同一个keypath进行两次removeObserver时会导致程序crash，这种情况常常出现在父类有一个kvo，父类在dealloc中remove了一次，子类又remove了一次的情况下。不要以为这种情况很少出现！当你封装framework开源给别人用或者多人协作开发时是有可能出现的，而且这种crash很难发现。不知道你发现没，目前的代码中context字段都是nil，那能否利用该字段来标识出到底kvo是superClass注册的，还是self注册的？ 回答是可以的。我们可以分别在父类以及本类中定义各自的context字符串，比如在本类中定义context为@&quot;ThisIsMyKVOContextNotSuper&quot;;然后在dealloc中remove observer时指定移除的自身添加的observer。这样iOS就能知道移除的是自己的kvo，而不是父类中的kvo，避免二次remove造成crash。 08-iOS数据持久化方案存储方案 plist文件（属性列表） preference（偏好设置） NSKeyedArchiver（归档） SQLite 3 CoreData 沙盒 iOS程序默认情况下只能访问程序自己的目录，这个目录被称为“沙盒”。 1.结构沙盒的目录结构如下： 123456\"应用程序包\"DocumentsLibrary Caches Preferencestmp 2.目录特性 虽然沙盒中有这么多文件夹，但是每个文件夹都不尽相同，都有各自的特性。所以在选择存放目录时，一定要认真选择适合的目录。 “应用程序包”: 这里面存放的是应用程序的源文件，包括资源文件和可执行文件。 Documents: 最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。 12NSString *path = [[NSBundle mainBundle] bundlePath];NSLog(@\"%@\", path); Library/Caches: iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。 12NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;NSLog(@\"%@\", path); Library/Preferences: iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。 12NSString *path = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).firstObject;NSLog(@\"%@\", path); tmp: iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。 12NSString *path = NSTemporaryDirectory();NSLog(@\"%@\", path); plist文件 plist文件是将某些特定的类，通过XML文件的方式保存在目录中。 可以被序列化的类型只有如下几种： 12345678910NSArray;NSMutableArray;NSDictionary;NSMutableDictionary;NSData;NSMutableData;NSString;NSMutableString;NSNumber;NSDate; 1.获得文件路径12NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;NSString *fileName = [path stringByAppendingPathComponent:@\"123.plist\"]; 2.存储12NSArray *array = @[@\"123\", @\"456\", @\"789\"];[array writeToFile:fileName atomically:YES]; 3.读取12NSArray *result = [NSArray arrayWithContentsOfFile:fileName];NSLog(@\"%@\", result); 4.注意123// 只有以上列出的类型才能使用plist文件存储。// 存储时使用writeToFile: atomically:方法。 其中atomically表示是否需要先写入一个辅助文件，再把辅助文件拷贝到目标文件地址。这是更安全的写入文件方法，一般都写YES。// 读取时使用arrayWithContentsOfFile:方法。 Preference1.使用方法12345678910111213141516//1.获得NSUserDefaults文件NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];//2.向文件中写入内容[userDefaults setObject:@\"AAA\" forKey:@\"a\"];[userDefaults setBool:YES forKey:@\"sex\"];[userDefaults setInteger:21 forKey:@\"age\"];//2.1立即同步[userDefaults synchronize];//3.读取文件NSString *name = [userDefaults objectForKey:@\"a\"];BOOL sex = [userDefaults boolForKey:@\"sex\"];NSInteger age = [userDefaults integerForKey:@\"age\"];NSLog(@\"%@, %d, %ld\", name, sex, age); 2.注意123// 偏好设置是专门用来保存应用程序的配置信息的，一般不要在偏好设置中保存其他数据。// 如果没有调用synchronize方法，系统会根据I/O情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用synchronize方法。// 偏好设置会将所有数据保存到同一个文件中。即preference目录下的一个以此应用包名来命名的plist文件。 NSKeyedArchiver 归档在iOS中是另一种形式的序列化，只要遵循了NSCoding协议的对象都可以通过它实现序列化。由于决大多数支持存储数据的Foundation和Cocoa Touch类都遵循了NSCoding协议，因此，对于大多数类来说，归档相对而言还是比较容易实现的。 1.遵循NSCoding协议 NSCoding协议声明了两个方法，这两个方法都是必须实现的。一个用来说明如何将对象编码到归档中，另一个说明如何进行解档来获取一个新对象。 遵循协议和设置属性 123456//1.遵循NSCoding协议 @interface Person : NSObject //2.设置属性@property (strong, nonatomic) UIImage *avatar;@property (copy, nonatomic) NSString *name;@property (assign, nonatomic) NSInteger age;@end 实现协议方法 12345678910111213141516//解档- (id)initWithCoder:(NSCoder *)aDecoder &#123; if ([super init]) &#123; self.avatar = [aDecoder decodeObjectForKey:@\"avatar\"]; self.name = [aDecoder decodeObjectForKey:@\"name\"]; self.age = [aDecoder decodeIntegerForKey:@\"age\"]; &#125; return self;&#125;//归档- (void)encodeWithCoder:(NSCoder *)aCoder &#123; [aCoder encodeObject:self.avatar forKey:@\"avatar\"]; [aCoder encodeObject:self.name forKey:@\"name\"]; [aCoder encodeInteger:self.age forKey:@\"age\"];&#125; 特别注意 1如果需要归档的类是某个自定义类的子类时，就需要在归档和解档之前先实现父类的归档和解档方法。即 [super encodeWithCoder:aCoder] 和 [super initWithCoder:aDecoder] 方法; 2.使用需要把对象归档是调用NSKeyedArchiver的工厂方法 archiveRootObject: toFile:方法。 123456NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@\"person.data\"];Person *person = [[Person alloc] init];person.avatar = self.avatarView.image;person.name = self.nameField.text;person.age = [self.ageField.text integerValue];[NSKeyedArchiver archiveRootObject:person toFile:file]; 需要从文件中解档对象就调用NSKeyedUnarchiver的一个工厂方法 unarchiveObjectWithFile: 即可。 12345678NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@\"person.data\"];Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:file];if (person) &#123; self.avatarView.image = person.avatar; self.nameField.text = person.name; self.ageField.text = [NSString stringWithFormat:@\"%ld\", person.age];&#125; 3.注意123必须遵循并实现NSCoding协议保存文件的扩展名可以任意指定继承时必须先调用父类的归档解档方法 SQLite3 之前的所有存储方法，都是覆盖存储。如果想要增加一条数据就必须把整个文件读出来，然后修改数据后再把整个内容覆盖写入文件。所以它们都不适合存储大量的内容。 1.字段类型表面上·SQLite·将数据分为以下几种类型： 1234integer : 整数real : 实数（浮点数）text : 文本字符串blob : 二进制数据，比如文件，图片之类的 实际上SQLite是无类型的。即不管你在创表时指定的字段类型是什么，存储是依然可以存储任意类型的数据。而且在创表时也可以不指定字段类型。SQLite之所以什么类型就是为了良好的编程规范和方便开发人员交流，所以平时在使用时最好设置正确的字段类型！主键必须设置成integer 2. 准备工作准备工作就是导入依赖库啦，在iOS中要使用SQLite3，需要添加库文件：libsqlite3.dylib并导入主头文件，这是一个C语言的库，所以直接使用SQLite3还是比较麻烦的。 3.使用1.创建数据库并打开操作数据库之前必须先指定数据库文件和要操作的表，所以使用SQLite3，首先要打开数据库文件，然后指定或创建一张表。 12345678910111213141516171819202122232425262728293031// 打开数据库并创建一个表- (void)openDatabase &#123; //1.设置文件名 NSString *filename = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@\"person.db\"]; //2.打开数据库文件，如果没有会自动创建一个文件 NSInteger result = sqlite3_open(filename.UTF8String, &amp;_sqlite3); if (result == SQLITE_OK) &#123; NSLog(@\"打开数据库成功！\"); //3.创建一个数据库表 char *errmsg = NULL; sqlite3_exec(_sqlite3, \"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)\", NULL, NULL, &amp;errmsg); if (errmsg) &#123; NSLog(@\"错误：%s\", errmsg); &#125; else &#123; NSLog(@\"创表成功！\"); &#125; &#125; else &#123; NSLog(@\"打开数据库失败！\"); &#125;&#125; 2.执行指令使用 sqlite3_exec() 方法可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据。 1234567891011121314151617181920// 往表中插入1000条数据- (void)insertData &#123; NSString *nameStr; NSInteger age; for (NSInteger i = 0; i &lt; 1000; i++) &#123; nameStr = [NSString stringWithFormat:@\"Bourne-%d\", arc4random_uniform(10000)]; age = arc4random_uniform(80) + 20; NSString *sql = [NSString stringWithFormat:@\"INSERT INTO t_person (name, age) VALUES('%@', '%ld')\", nameStr, age]; char *errmsg = NULL; sqlite3_exec(_sqlite3, sql.UTF8String, NULL, NULL, &amp;errmsg); if (errmsg) &#123; NSLog(@\"错误：%s\", errmsg); &#125; &#125; NSLog(@\"插入完毕！\"); &#125; 3.查询指令前面说过一般不使用 sqlite3_exec() 方法查询数据。因为查询数据必须要获得查询结果，所以查询相对比较麻烦。示例代码如下： 123456789101112131415161718192021222324252627// sqlite3_prepare_v2() : 检查sql的合法性// sqlite3_step() : 逐行获取查询结果，不断重复，直到最后一条记录// sqlite3_coloum_xxx() : 获取对应类型的内容，iCol对应的就是SQL语句中字段的顺序，从0开始。根据实际查询字段的属性，使用sqlite3_column_xxx取得对应的内容即可。// sqlite3_finalize() : 释放stmt// 从表中读取数据到数组中- (void)readData &#123; NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1000]; char *sql = \"select name, age from t_person;\"; sqlite3_stmt *stmt; NSInteger result = sqlite3_prepare_v2(_sqlite3, sql, -1, &amp;stmt, NULL); if (result == SQLITE_OK) &#123; while (sqlite3_step(stmt) == SQLITE_ROW) &#123; char *name = (char *)sqlite3_column_text(stmt, 0); NSInteger age = sqlite3_column_int(stmt, 1); //创建对象 Person *person = [Person personWithName:[NSString stringWithUTF8String:name] Age:age]; [mArray addObject:person]; &#125; self.dataList = mArray; &#125; sqlite3_finalize(stmt);&#125; 4.总结总得来说，SQLite3的使用还是比较麻烦的，因为都是些c语言的函数，理解起来有些困难。不过在一般开发过程中，使用的都是第三方开源库 FMDB，封装了这些基本的c语言方法，使得我们在使用时更加容易理解，提高开发效率。 FMDB1.简介 FMDB是iOS平台的SQLite数据库框架，它是以OC的方式封装了SQLite的C语言API，它相对于cocoa自带的C语言框架有如下的优点:使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码对比苹果自带的Core Data框架，更加轻量级和灵活提供了多线程安全的数据库操作方法，有效地防止数据混乱 2.核心类FMDB有三个主要的类： 12345678// FMDatabase一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句// FMResultSet使用FMDatabase执行查询后的结果集// FMDatabaseQueue用于在多线程中执行多个查询或更新，它是线程安全的 3.打开数据库 和c语言框架一样，FMDB通过指定SQLite数据库文件路径来创建FMDatabase对象，但FMDB更加容易理解，使用起来更容易，使用之前一样需要导入sqlite3.dylib。打开数据库方法如下： 1234567NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@\"person.db\"];FMDatabase *database = [FMDatabase databaseWithPath:path]; if (![database open]) &#123; NSLog(@\"数据库打开失败！\");&#125; 值得注意的是，Path的值可以传入以下三种情况： 123// 具体文件路径，如果不存在会自动创建// 空字符串@\"\"，会在临时目录创建一个空的数据库，当FMDatabase连接关闭时，数据库文件也被删除// nil，会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁 4.更新 在FMDB中，除查询以外的所有操作，都称为“更新”, 如：create、drop、insert、update、delete等操作，使用executeUpdate:方法执行更新： 123456789101112//常用方法有以下 3 种： - (BOOL)executeUpdate:(NSString*)sql, ...- (BOOL)executeUpdateWithFormat:(NSString*)format, ...- (BOOL)executeUpdate:(NSString*)sql withArgumentsInArray:(NSArray *)arguments//示例[database executeUpdate:@\"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)\"]; //或者 [database executeUpdate:@\"INSERT INTO t_person(name, age) VALUES(?, ?)\", @\"Bourne\", [NSNumber numberWithInt:42]]; 5.查询查询方法也有3种，使用起来相当简单： 123- (FMResultSet *)executeQuery:(NSString*)sql, ...- (FMResultSet *)executeQueryWithFormat:(NSString*)format, ...- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments 查询示例： 123456789//1.执行查询FMResultSet *result = [database executeQuery:@\"SELECT * FROM t_person\"];//2.遍历结果集while ([result next]) &#123; NSString *name = [result stringForColumn:@\"name\"]; int age = [result intForColumn:@\"age\"];&#125; 6.线程安全 在多个线程中同时使用一个 FMDatabase 实例是不明智的。不要让多个线程分享同一个FMDatabase实例，它无法在多个线程中同时使用。 如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题。所以，请使用 FMDatabaseQueue，它是线程安全的。以下是使用方法： 创建队列。 123456789101112131415161718192021222324FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];// 使用队列[queue inDatabase:^(FMDatabase *database)&#123; [database executeUpdate:@\"INSERT INTO t_person(name, age) VALUES (?, ?)\", @\"Bourne_1\", [NSNumber numberWithInt:1]]; [database executeUpdate:@\"INSERT INTO t_person(name, age) VALUES (?, ?)\", @\"Bourne_2\", [NSNumber numberWithInt:2]]; [database executeUpdate:@\"INSERT INTO t_person(name, age) VALUES (?, ?)\", @\"Bourne_3\", [NSNumber numberWithInt:3]]; FMResultSet *result = [database executeQuery:@\"select * from t_person\"]; while([result next]) &#123; &#125; &#125;];// 而且可以轻松地把简单任务包装到事务里：[queue inTransaction:^(FMDatabase *database, BOOL *rollback) &#123; [database executeUpdate:@\"INSERT INTO t_person(name, age) VALUES (?, ?)\", @\"Bourne_1\", [NSNumber numberWithInt:1]]; [database executeUpdate:@\"INSERT INTO t_person(name, age) VALUES (?, ?)\", @\"Bourne_2\", [NSNumber numberWithInt:2]]; [database executeUpdate:@\"INSERT INTO t_person(name, age) VALUES (?, ?)\", @\"Bourne_3\", [NSNumber numberWithInt:3]]; FMResultSet *result = [database executeQuery:@\"select * from t_person\"]; while([result next]) &#123; &#125; //回滚 *rollback = YES; &#125;]; FMDatabaseQueue 后台会建立系列化的GCD队列，并执行你传给GCD队列的块。这意味着 你从多线程同时调用调用方法，GCD也会按它接收的块的顺序来执行了。","content":"<p>文章大纲，便于浏览</p>\n<ol>\n<li><a href=\"https://github.com/liberalisman/2018-Interview-Preparation#01-ios-app-startup-process\" target=\"_blank\" rel=\"external\">01-iOS程序启动过程</a></li>\n<li><a href=\"https://github.com/liberalisman/2018-Interview-Preparation#02-shallowcopy-deepcopy\" target=\"_blank\" rel=\"external\">02-浅拷贝-深拷贝</a></li>\n<li><a href=\"https://github.com/liberalisman/2018-Interview-Preparation#03-view的生命周期\" target=\"_blank\" rel=\"external\">03-View的生命周期</a></li>\n<li><a href=\"https://github.com/liberalisman/2018-Interview-Preparation#04-property\" target=\"_blank\" rel=\"external\">04-@property</a></li>\n<li><a href=\"https://github.com/liberalisman/iOS-Summary-Part1#05-事件传递和事件响应\" target=\"_blank\" rel=\"external\">05-事件传递和事件响应</a></li>\n<li><a href=\"https://github.com/liberalisman/iOS-Summary-Part1#06-kvc\" target=\"_blank\" rel=\"external\">06-KVC</a></li>\n<li><a href=\"https://github.com/liberalisman/iOS-Summary-Part1#07-kvo\" target=\"_blank\" rel=\"external\">07-KVO</a></li>\n<li><a href=\"https://github.com/liberalisman/iOS-Summary-Part1#08-ios数据持久化方案\" target=\"_blank\" rel=\"external\">08-iOS数据持久化方案</a></li>\n</ol>\n<h2 id=\"01-iOS-App-startup-process\"><a href=\"#01-iOS-App-startup-process\" class=\"headerlink\" title=\"01-iOS-App-startup-process\"></a>01-iOS-App-startup-process</h2><h3 id=\"一、启动完整过程\"><a href=\"#一、启动完整过程\" class=\"headerlink\" title=\"一、启动完整过程\"></a>一、启动完整过程</h3><p><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>1.<code>main</code>函数</p>\n<p>2.<code>UIApplicationMain</code>函数</p>\n<ul>\n<li>创建<code>UIApplication</code>对象</li>\n<li>创建<code>UIApplication的delegate</code>对象</li>\n</ul>\n<p>3.<code>delegate</code>对象开始处理(监听)系统事件(没有storyboard)</p>\n<ul>\n<li>程序启动完毕的时候, 就会调用代理的:<code>didFinishLaunchingWithOptions:</code>方法</li>\n<li>在<code>application:didFinishLaunchingWithOptions</code>:中创建<code>UIWindow</code> 创建和设置<code>UIWindow</code>的<code>rootViewController</code></li>\n<li>显示窗口</li>\n</ul>\n<p>4.根据<code>Info.plist</code>获得最主要<code>storyboard</code>的文件名,加载最主要的<code>storyboard</code>(有storyboard)</p>\n<ul>\n<li>创建<code>UIWindow</code></li>\n<li>创建和设置<code>UIWindow</code>的<code>rootViewController</code></li>\n<li>显示窗口</li>\n</ul>\n<p>###二、程序启动原理</p>\n<p>1.<code>main</code>函数中执行了一个<code>UIApplicationMain</code>这个函数</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">UIApplicationMain</span>(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[], <span class=\"built_in\">NSString</span> *principalClassName, <span class=\"built_in\">NSString</span> *delegateClassName);</div><div class=\"line\"></div><div class=\"line\">argc、argv：直接传递给<span class=\"built_in\">UIApplicationMain</span>进行相关处理即可</div></pre></td></tr></table></figure>\n<p>2.<code>principalClassName</code>：指定应用程序类名（app的象征），该类必须是<code>UIApplication</code>(或子类)。如果为<code>nil</code>,则用<code>UIApplication</code>类作为默认值</p>\n<p>3.<code>delegateClassName</code>：指定应用程序的代理类，该类必须遵守<code>UIApplicationDelegate</code>协议</p>\n<p>4.<code>UIApplicationMain</code>函数会根据<code>principalClassName</code>创建<code>UIApplication</code>对象，根据<code>delegateClassName</code>创建一个<code>delegate</code>对象，并将该<code>delegate</code>对象赋值给<code>UIApplication</code>对象中的<code>delegate</code>属性</p>\n<p>5.接着会建立应用程序的<code>Main Runloop</code>（事件循环），进行事件的处理(首先会在程序完毕后调用<code>delegate</code>对象的<code>application:didFinishLaunchingWithOptions</code>:方法)</p>\n<p>程序正常退出时<code>UIApplicationMain</code>函数才返回</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * argv[])&#123; <span class=\"keyword\">@autoreleasepool</span> &#123; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* argc: 系统或者用户传入的参数个数</div><div class=\"line\">* argv: 系统或者用户传入的实际参数 </div><div class=\"line\">* 1.根据传入的第三个参数创建UIApplication对象 </div><div class=\"line\">* 2.根据传入的第四个产生创建UIApplication对象的代理</div><div class=\"line\">* 3.设置刚刚创建出来的代理对象为UIApplication的代理 </div><div class=\"line\">* 4.开启一个事件循环 </div><div class=\"line\">**/ </div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">UIApplicationMain</span>(argc, argv, <span class=\"string\">@\"UIApplication\"</span>, <span class=\"string\">@\"YYAppDelegate\"</span>); &#125;&#125;</div></pre></td></tr></table></figure>\n<p>启动与代理：<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E4%B8%8E%E4%BB%A3%E7%90%86.png\" alt=\"\"></p>\n<h2 id=\"02-ShallowCopy-DeepCopy\"><a href=\"#02-ShallowCopy-DeepCopy\" class=\"headerlink\" title=\"02-ShallowCopy-DeepCopy\"></a>02-ShallowCopy-DeepCopy</h2><p>简要总结一下什么是浅拷贝，什么是深拷贝</p>\n<blockquote>\n<p>深拷贝就是内容拷贝（分为单层拷贝、完全拷贝），深拷贝的之所以分为两类，主要是针对集合类</p>\n<p>浅拷贝就是指针拷贝</p>\n</blockquote>\n<p>####一.系统对象的 copy/mutableCopy</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *string = <span class=\"string\">@\"LiMing\"</span>;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"built_in\">NSString</span> *copyString = [string <span class=\"keyword\">copy</span>];</div><div class=\"line\">    </div><div class=\"line\"><span class=\"built_in\">NSString</span> *mutableString = [string mutableCopy];</div><div class=\"line\">    </div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"string = %p\"</span>,string);</div><div class=\"line\">    </div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"copyString = %p\"</span>,copyString);</div><div class=\"line\">    </div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"mutableString = %p \"</span>,mutableString);</div><div class=\"line\"></div><div class=\"line\">结论：</div><div class=\"line\"><span class=\"number\">1.</span>string 和 copyString 他们只是二个不同的指针，指向内存中的同一块地址，<span class=\"keyword\">copy</span> 只是指针复制</div><div class=\"line\"><span class=\"number\">2.</span>string 和 mutableString 打印出来的地址不同，是因为两个指针指向的地址本就不同，mutableCopy 是内容复制</div><div class=\"line\"></div><div class=\"line\">注意：其他对象 <span class=\"built_in\">NSArray</span> 、<span class=\"built_in\">NSMutableArray</span> 、<span class=\"built_in\">NSDictionary</span> 、<span class=\"built_in\">NSMutableDictionary</span> 一样适用</div></pre></td></tr></table></figure>\n<p>规律可以从这张图看出来</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D-01\" alt=\"\"></p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D-02\" alt=\"\"></p>\n<p>####二.自定义对象实现 Copy-MutableCopy</p>\n<ul>\n<li>copy</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">GZQPerson *person = [[GZQPerson alloc] init];</div><div class=\"line\">person.age = <span class=\"number\">20</span>;</div><div class=\"line\">person.name = <span class=\"string\">@\"GZQ\"</span>;</div><div class=\"line\">GZQPerson *copyP = [person <span class=\"keyword\">copy</span>];  <span class=\"comment\">// 这里崩溃</span></div></pre></td></tr></table></figure>\n<p>崩溃：<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D-03.png\" alt=\"\"></p>\n<p>看崩溃信息GZQPerson应该先实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">id</span>)copyWithZone:(<span class=\"built_in\">NSZone</span> *)zone;</div></pre></td></tr></table></figure>\n<p>测试：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"GZQPerson.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">GZQPerson</span> ()&lt;<span class=\"title\">NSCopying</span>,<span class=\"title\">NSMutableCopying</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">GZQPerson</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">id</span>)copyWithZone:(<span class=\"built_in\">NSZone</span> *)zone &#123;</div><div class=\"line\"></div><div class=\"line\">    GZQPerson *person = [[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] allocWithZone:zone] init];</div><div class=\"line\">    person.age = <span class=\"keyword\">self</span>.age;</div><div class=\"line\">    person.name = <span class=\"keyword\">self</span>.name;</div><div class=\"line\">    <span class=\"keyword\">return</span> person;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">id</span>)mutableCopyWithZone:(<span class=\"built_in\">NSZone</span> *)zone &#123;</div><div class=\"line\"></div><div class=\"line\">    GZQPerson *person = [[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] allocWithZone:zone] init];</div><div class=\"line\">    person.age = <span class=\"keyword\">self</span>.age;</div><div class=\"line\">    person.name = <span class=\"keyword\">self</span>.name;</div><div class=\"line\">    <span class=\"keyword\">return</span> person;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"ViewController.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"GZQPerson.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    </div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    GZQPerson *person = [[GZQPerson alloc] init];</div><div class=\"line\">    person.age = <span class=\"number\">20</span>;</div><div class=\"line\">    person.name = <span class=\"string\">@\"GZQ\"</span>;</div><div class=\"line\">    GZQPerson *copyP = [person <span class=\"keyword\">copy</span>];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"copyP=%p\"</span>,copyP);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"person=%p\"</span>,person);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"person=%p\"</span>,copyP.name);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"person=%p\"</span>,person.name);</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D-04.png\" alt=\"\"></p>\n<p>可以看出虽然指针的地址不同，但是存储的地址是一致的。</p>\n<p>####三.copy 本质</p>\n<p><code>property copy</code> 实际上就对name干了这个：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\">property <span class=\"keyword\">copy</span> 实际上就对name干了这个：</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name</div><div class=\"line\">&#123;</div><div class=\"line\">    _name = [name <span class=\"keyword\">copy</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>strong</code>是不执行<code>Copy</code>操作的</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *name;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSMutableString</span> *string = [<span class=\"built_in\">NSMutableString</span> stringWithFormat:<span class=\"string\">@\"深拷贝-浅拷贝\"</span>];</div><div class=\"line\"></div><div class=\"line\">GZQPerson *person = [[GZQPerson alloc] init];</div><div class=\"line\">person.name = string;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 可以改变person.name的值，因为其内部没有生成新的对象</span></div><div class=\"line\">[string appendString:<span class=\"string\">@\"LALALA\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"name = %@\"</span>, person.name);</div></pre></td></tr></table></figure>\n<p>####四.集合类 Copy MutableCopy 操作</p>\n<blockquote>\n<p>单层深复制，也就是我们经常说的深复制，我这里说的单层深复制是对于集合类所说的(即NSArray,NSDictionary,NSSet)，单层深复制指的是只复制了该集合类的最外层，里边的元素没有复制，(即这两个集合类的地址不一样，但是两个集合里所存储的元素的地址是一样的)</p>\n<p>完全复制，指的是完全复制整个集合类，也就是说两个集合地址不一样，里边所存储的元素地址也不一样</p>\n</blockquote>\n<p>实现多层完全拷贝也很简单</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *copyArray = [[<span class=\"built_in\">NSArray</span> alloc] initWithArray:array copyItems:<span class=\"literal\">YES</span>];  <span class=\"comment\">// 完全复制</span></div></pre></td></tr></table></figure>\n<h2 id=\"03-View的生命周期\"><a href=\"#03-View的生命周期\" class=\"headerlink\" title=\"03-View的生命周期\"></a>03-View的生命周期</h2><ul>\n<li>读懂这一张图即可<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/image/jpg/View%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"04-property\"><a href=\"#04-property\" class=\"headerlink\" title=\"04-@property\"></a>04-@property</h2><blockquote>\n<p>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</p>\n</blockquote>\n<p>@property 的本质.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> = ivar + <span class=\"keyword\">getter</span> + <span class=\"keyword\">setter</span>;</div></pre></td></tr></table></figure>\n<p>下面解释下：</p>\n<blockquote>\n<p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p>\n<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p>\n</blockquote>\n<p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> = <span class=\"keyword\">getter</span> + <span class=\"keyword\">setter</span>;</div></pre></td></tr></table></figure>\n<p>例如下面这个类：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Person</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSString</span> *firstName;</div><div class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSString</span> *lastName;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>上述代码写出来的类与下面这种写法等效：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Person</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)firstName;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)setFirstName:(<span class=\"built_in\">NSString</span> *)firstName;</div><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)lastName;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)setLastName:(<span class=\"built_in\">NSString</span> *)lastName;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p><code>property</code>在<code>runtime</code>中是<code>objc_property_t</code>定义如下:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_property *objc_property_t;</div></pre></td></tr></table></figure>\n<p>而<code>objc_property</code>是一个结构体，包括<code>name</code>和<code>attributes</code>，定义如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> property_t &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *attributes;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>而<code>attributes</code>本质是<code>objc_property_attribute_t</code>，定义了<code>property</code>的一些属性，定义如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/// Defines a property attribute</span></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;           <span class=\"comment\">/**&lt; The name of the attribute */</span></div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *value;          <span class=\"comment\">/**&lt; The value of the attribute (usually empty) */</span></div><div class=\"line\">&#125; objc_property_attribute_t;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。</p>\n</blockquote>\n<p>例如：我们定义一个<code>string</code>的<code>property</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *string;</div></pre></td></tr></table></figure>\n<p>通过 <code>property_getAttributes(property)</code>获取到<code>attributes</code>并打印出来之后的结果为</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">T<span class=\"string\">@\"NSString\"</span>,C,N,V_string</div></pre></td></tr></table></figure>\n<p>其中<code>T</code>就代表类型，可参阅<code>Type Encodings</code>，<code>C</code>就代表<code>Copy</code>，<code>N</code>代表<code>nonatomic</code>，<code>V</code>就代表对于的实例变量。</p>\n<blockquote>\n<p>ivar、getter、setter 是如何生成并添加到这个类中的?</p>\n</blockquote>\n<p><strong>“自动合成”( autosynthesis)</strong></p>\n<blockquote>\n<p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过@synthesize 语法来指定实例变量的名字.</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Person</span></span></div><div class=\"line\"><span class=\"keyword\">@synthesize</span> firstName = _myFirstName;</div><div class=\"line\"><span class=\"keyword\">@synthesize</span> lastName = _myLastName;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p><strong>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1.</span> OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。</div><div class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">setter</span> 与 <span class=\"keyword\">getter</span> 方法对应的实现函数</div><div class=\"line\"><span class=\"number\">3.</span> ivar_list ：成员变量列表</div><div class=\"line\"><span class=\"number\">4.</span> method_list ：方法列表</div><div class=\"line\"><span class=\"number\">5.</span> prop_list ：属性列表</div><div class=\"line\">也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 <span class=\"keyword\">setter</span> 与 <span class=\"keyword\">getter</span> 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 <span class=\"keyword\">setter</span> 与 <span class=\"keyword\">getter</span> 方法对应的实现,在 <span class=\"keyword\">setter</span> 方法中从偏移量的位置开始赋值,在 <span class=\"keyword\">getter</span> 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</div></pre></td></tr></table></figure>\n<p><strong>属性可以拥有的特质分为四类:</strong></p>\n<ul>\n<li><p>原子性— nonatomic 特质,在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</p>\n</li>\n<li><p>读/写权限—readwrite(读写)、readonly (只读)</p>\n</li>\n<li><p>内存管理语义—assign、strong、 weak、unsafe_unretained、copy</p>\n</li>\n<li>方法名—getter=<name> 、setter=<name></name></name></li>\n</ul>\n<p><strong>getter=<name>的样式：</name></strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">getter</span>=isOn) <span class=\"built_in\">BOOL</span> on;</div><div class=\"line\">     </div><div class=\"line\">(`<span class=\"keyword\">setter</span>=`这种不常用，也不推荐使用。故不在这里给出写法。）</div></pre></td></tr></table></figure>\n<p><strong>setter=<name>一般用在特殊的情境下，比如</name></strong>：</p>\n<blockquote>\n<p>在数据反序列化、转模型的过程中，服务器返回的字段如果以 init 开头，所以你需要定义一个 init 开头的属性，但默认生成的 setter 与 getter 方法也会以 init 开头，而编译器会把所有以 init 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。</p>\n</blockquote>\n<p><strong>这时你就可以使用下面的方式来避免编译器报错：</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">getter</span>=p_initBy, <span class=\"keyword\">setter</span>=setP_initBy:)<span class=\"built_in\">NSString</span> *initBy;</div></pre></td></tr></table></figure>\n<p><strong>另外也可以用关键字进行特殊说明，来避免编译器报错</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readwrite</span>, <span class=\"keyword\">copy</span>, <span class=\"keyword\">null_resettable</span>) <span class=\"built_in\">NSString</span> *initBy;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)initBy __attribute__((objc_method_family(none)));</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">1.</span> 不常用的：<span class=\"keyword\">nonnull</span>,<span class=\"keyword\">null_resettable</span>,<span class=\"keyword\">nullable</span></div><div class=\"line\"></div><div class=\"line\">注意：很多人会认为如果属性具备 <span class=\"keyword\">nonatomic</span> 特质，则不使用 “同步锁”。其实在属性设置方法中使用的是自旋锁，自旋锁相关代码如下：</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> reallySetProperty(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, <span class=\"keyword\">id</span> newValue, ptrdiff_t offset, <span class=\"keyword\">bool</span> atomic, <span class=\"keyword\">bool</span> <span class=\"keyword\">copy</span>, <span class=\"keyword\">bool</span> mutableCopy)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (offset == <span class=\"number\">0</span>) </div><div class=\"line\">    &#123;</div><div class=\"line\">        object_setClass(<span class=\"keyword\">self</span>, newValue);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">id</span> oldValue;</div><div class=\"line\">    <span class=\"keyword\">id</span> *slot = (<span class=\"keyword\">id</span>*) ((<span class=\"keyword\">char</span>*)<span class=\"keyword\">self</span> + offset);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">copy</span>) </div><div class=\"line\">    &#123;</div><div class=\"line\">        newValue = [newValue copyWithZone:<span class=\"literal\">nil</span>];</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mutableCopy) </div><div class=\"line\">    &#123;</div><div class=\"line\">        newValue = [newValue mutableCopyWithZone:<span class=\"literal\">nil</span>];</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"keyword\">else</span> </div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (*slot == newValue) <span class=\"keyword\">return</span>;</div><div class=\"line\">        newValue = objc_retain(newValue);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!atomic) </div><div class=\"line\">    &#123;</div><div class=\"line\">        oldValue = *slot;</div><div class=\"line\">        *slot = newValue;</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"keyword\">else</span> </div><div class=\"line\">    &#123;</div><div class=\"line\">        spinlock_t&amp; slotlock = PropertyLocks[slot];</div><div class=\"line\">        slotlock.lock();</div><div class=\"line\">        oldValue = *slot;</div><div class=\"line\">        *slot = newValue;        </div><div class=\"line\">        slotlock.unlock();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    objc_release(oldValue);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">void</span> objc_setProperty(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, ptrdiff_t offset, <span class=\"keyword\">id</span> newValue, <span class=\"built_in\">BOOL</span> atomic, <span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> shouldCopy) </div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">copy</span> = (shouldCopy &amp;&amp; shouldCopy != MUTABLE_COPY);</div><div class=\"line\">    <span class=\"keyword\">bool</span> mutableCopy = (shouldCopy == MUTABLE_COPY);</div><div class=\"line\">    reallySetProperty(<span class=\"keyword\">self</span>, _cmd, newValue, offset, atomic, <span class=\"keyword\">copy</span>, mutableCopy);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"05-事件传递和事件响应\"><a href=\"#05-事件传递和事件响应\" class=\"headerlink\" title=\"05-事件传递和事件响应\"></a>05-事件传递和事件响应</h2><p>这部分知识如果自己总结，篇幅较长。可以参考<a href=\"http://www.jianshu.com/p/2e074db792ba\" target=\"_blank\" rel=\"external\">以下文章</a></p>\n<h2 id=\"06-KVC\"><a href=\"#06-KVC\" class=\"headerlink\" title=\"06-KVC\"></a>06-KVC</h2><p><strong>Key-Value Coding (KVC)</strong></p>\n<blockquote>\n<p>KVC（Key-value coding）键值编码，单看这个名字可能不太好理解。其实翻译一下就很简单了，就是指iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值。而不需要调用明确的存取方法。这样就可以在运行时动态在访问和修改对象的属性。而不是在编译时确定，这也是iOS开发中的黑魔法之一。很多高级的iOS开发技巧都是基于KVC实现的。目前网上关于KVC的文章在非常多，有的只是简单地说了下用法，有的讲得深入但是在使用场景和最佳实践没有说明，我写下这遍文章就是给大家详解一个最完整最详细的KVC。</p>\n</blockquote>\n<p><strong>KVC在iOS中的定义</strong></p>\n<p>无论是<code>Swift</code>还是<code>Objective-C</code>，<code>KVC</code>的定义都是对<code>NSObject</code>的扩展来实现的(<code>Objective-C</code>中有个显式的<code>NSKeyValueCoding</code>类别名，而<code>Swift</code>没有，也不需要)所以对于所有继承了<code>NSObject</code>在类型，都能使用<code>KVC</code>(一些纯<code>Swift</code>类和结构体是不支持<code>KVC</code>的)，下面是<code>KVC</code>最为重要的四个方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)valueForKey:(<span class=\"built_in\">NSString</span> *)key;                          <span class=\"comment\">//直接通过Key来取值</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forKey:(<span class=\"built_in\">NSString</span> *)key;          <span class=\"comment\">//通过Key来设值</span></div><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)valueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath;                  <span class=\"comment\">//通过KeyPath来取值</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath;  <span class=\"comment\">//通过KeyPath来设值</span></div></pre></td></tr></table></figure>\n<p>当然<code>NSKeyValueCoding</code>类别中还有其他的一些方法，下面列举一些</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"built_in\">BOOL</span>)accessInstanceVariablesDirectly;</div><div class=\"line\"><span class=\"comment\">//默认返回YES，表示如果没有找到Set&lt;Key&gt;方法的话，会按照_key，_iskey，key，iskey的顺序搜索成员，设置成NO就不这样搜索</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)validateValue:(<span class=\"keyword\">inout</span> <span class=\"keyword\">id</span> __<span class=\"keyword\">nullable</span> * __<span class=\"keyword\">nonnull</span>)ioValue forKey:(<span class=\"built_in\">NSString</span> *)inKey error:(<span class=\"keyword\">out</span> <span class=\"built_in\">NSError</span> **)outError;</div><div class=\"line\"><span class=\"comment\">//KVC提供属性值确认的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</span></div><div class=\"line\">- (<span class=\"built_in\">NSMutableArray</span> *)mutableArrayValueForKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\"><span class=\"comment\">//这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回</span></div><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)valueForUndefinedKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\"><span class=\"comment\">//如果Key不存在，且没有KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forUndefinedKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\"><span class=\"comment\">//和上一个方法一样，只不过是设值。</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setNilValueForKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\"><span class=\"comment\">//如果你在SetValue方法时面给Value传nil，则会调用这个方法</span></div><div class=\"line\">- (<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *, <span class=\"keyword\">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keys;</div><div class=\"line\"><span class=\"comment\">//输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。</span></div></pre></td></tr></table></figure>\n<p>上面的这些方法在碰到特殊情况或者有特殊需求还是会用到的，所以也是可以了解一下。后面的代码示例会有讲到其中的一些方法。<br>同时苹果对一些容器类比如NSArray或者NSSet等，KVC有着特殊的实现。建议有基础的或者英文好的开发者直接去看苹果的官方文档，相信你会对KVC的理解更上一个台阶。</p>\n<p><strong>KVC是怎么寻找Key的</strong></p>\n<p>KVC是怎么使用的，我相信绝大多数的开发者都很清楚，我在这里就不再写简单的使用KVC来设值和取值的代码了，首页我们来探讨KVC在内部是按什么样的顺序来寻找key的。<br>当调用<code>setValue：</code>属性值 <code>forKey：``@”name“</code>的代码时，底层的执行机制如下：</p>\n<ul>\n<li><p>程序优先调用<code>set&lt;Key&gt;:</code>属性值方法，代码通过<code>setter</code>方法完成设置。注意，这里的<code>&lt;key&gt;</code>是指成员变量名，首字母大清写要符合<code>KVC</code>的全名规则，下同</p>\n</li>\n<li><p>如果没有找到<code>setName：</code>方法，<code>KVC</code>机制会检查<code>+ (BOOL)accessInstanceVariablesDirectly</code>方法有没有返回<code>YES</code>，默认该方法会返回<code>YES</code>，如果你重写了该方法让其返回<code>NO</code>的话，那么在这一步KVC会执行<code>setValue：forUNdefinedKey：</code>方法，不过一般开发者不会这么做。所以KVC机制会搜索该类里面有没有名为<code>_&lt;key&gt;</code>的成员变量，无论该变量是在类接口部分定义，还是在类实现部分定义，也无论用了什么样的访问修饰符，只在存在以<code>_&lt;key&gt;</code>命名的变量，<code>KVC</code>都可以对该成员变量赋值。</p>\n</li>\n<li><p>如果该类即没有<code>set&lt;Key&gt;：</code>方法，也没有<code>_&lt;key&gt;</code>成员变量，<code>KVC</code>机制会搜索<code>_is&lt;Key&gt;</code>的成员变量，</p>\n</li>\n<li><p>和上面一样，如果该类即没有<code>set&lt;Key&gt;：</code>方法，也没有<code>_&lt;key&gt;</code>和<code>_is&lt;Key&gt;</code>成员变量，<code>KVC</code>机制再会继续搜索<code>&lt;key&gt;</code>和<code>is&lt;Key&gt;</code>的成员变量。再给它们赋值。</p>\n</li>\n<li><p>如果上面列出的方法或者成员变量都不存在，系统将会执行该对象的<code>setValue：forUNdefinedKey：</code>方法，默认是抛出异常。</p>\n</li>\n</ul>\n<p>如果开发者想让这个类禁用<code>KVC</code>里，那么重写<code>+ (BOOL)accessInstanceVariablesDirectly</code>方法让其返回NO即可，这样的话如果<code>KVC</code>没有找到<code>set&lt;Key&gt;:</code>属性名时，会直接用<code>setValue：forUNdefinedKey：</code>方法。</p>\n<h2 id=\"07-KVO\"><a href=\"#07-KVO\" class=\"headerlink\" title=\"07-KVO\"></a>07-KVO</h2><p><code>KVO</code>，全称为<code>Key-Value Observing</code>，是iOS中的一种设计模式，用于检测对象的某些属性的实时变化情况并作出响应。当应用场景比较复杂时，多个地方存在crash的危险。</p>\n<p>首先，假设我们的目标是在一个<code>UITableViewController</code>内对<code>tableview</code>的<code>contentOffset</code>进行实时监测，很容易地使用<code>KVO</code>来实现为。</p>\n<p>在初始化方法中加入：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">[_tableView addObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"contentOffset\"</span> options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> context:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 在dealloc中移除KVO监听：</span></div><div class=\"line\">[_tableView removeObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"contentOffset\"</span> context:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 添加默认的响应回调方法：</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath </div><div class=\"line\">                      ofObject:(<span class=\"keyword\">id</span>)object</div><div class=\"line\">                        change:(<span class=\"built_in\">NSDictionary</span> *)change </div><div class=\"line\">                       context:(<span class=\"keyword\">void</span> *)context</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span> doSomethingWhenContentOffsetChanges];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>好了，<code>KVO</code>实现就到此完美结束了，开玩笑，肯定没这么简单的，这样的代码太粗糙了，当你在<code>controller</code>中添加多个<code>KVO</code>时，所有的回调都是走同上述函数，那就必须对触发回调函数的来源进行判断。判断如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath </div><div class=\"line\">                      ofObject:(<span class=\"keyword\">id</span>)object</div><div class=\"line\">                        change:(<span class=\"built_in\">NSDictionary</span> *)change </div><div class=\"line\">                       context:(<span class=\"keyword\">void</span> *)context</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (object == _tableView &amp;&amp; [keyPath isEqualToString:<span class=\"string\">@\"contentOffset\"</span>]) </div><div class=\"line\">    &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> doSomethingWhenContentOffsetChanges];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你以为这样就结束了吗？答案是否定的！我们假设当前类(在例子中为<code>UITableViewController</code>)还有父类，并且父类也有自己绑定了一些其他<code>KVO</code>呢？我们看到，上述回调函数体中只有一个判断，如果这个<code>if</code>不成立，这次<code>KVO</code>事件的触发就会到此中断了。但事实上，若当前类无法捕捉到这个<code>KVO</code>，那很有可能是在他的<code>superClass</code>，或者<code>super-superClass...</code>中，上述处理砍断了这个链。合理的处理方式应该是这样的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath </div><div class=\"line\">                      ofObject:(<span class=\"keyword\">id</span>)object</div><div class=\"line\">                        change:(<span class=\"built_in\">NSDictionary</span> *)change </div><div class=\"line\">                       context:(<span class=\"keyword\">void</span> *)context</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (object == _tableView &amp;&amp; [keyPath isEqualToString:<span class=\"string\">@\"contentOffset\"</span>]) </div><div class=\"line\">    &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> doSomethingWhenContentOffsetChanges];</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"keyword\">else</span> </div><div class=\"line\">    &#123;</div><div class=\"line\">        [<span class=\"keyword\">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样就结束了吗？答案仍旧是否定的。潜在的问题有可能出现在<code>dealloc</code>中对<code>KVO</code>的注销上。<code>KVO</code>的一种缺陷(其实不能称为缺陷，应该称为特性)是，当对同一个<code>keypath</code>进行两次<code>removeObserver</code>时会导致程序<code>crash</code>，这种情况常常出现在父类有一个<code>kvo</code>，父类在<code>dealloc</code>中<code>remove</code>了一次，子类又<code>remove</code>了一次的情况下。不要以为这种情况很少出现！当你封装<code>framework</code>开源给别人用或者多人协作开发时是有可能出现的，而且这种<code>crash</code>很难发现。不知道你发现没，目前的代码中<code>context</code>字段都是<code>nil</code>，那能否利用该字段来标识出到底<code>kvo</code>是<code>superClass</code>注册的，还是<code>self</code>注册的？</p>\n<p>回答是可以的。我们可以分别在父类以及本类中定义各自的<code>context</code>字符串，比如在本类中定义<code>context</code>为<code>@&quot;ThisIsMyKVOContextNotSuper&quot;</code>;然后在<code>dealloc</code>中<code>remove observer</code>时指定移除的自身添加的<code>observer</code>。这样iOS就能知道移除的是自己的<code>kvo</code>，而不是父类中的<code>kvo</code>，避免二次<code>remove</code>造成<code>crash</code>。</p>\n<h2 id=\"08-iOS数据持久化方案\"><a href=\"#08-iOS数据持久化方案\" class=\"headerlink\" title=\"08-iOS数据持久化方案\"></a>08-iOS数据持久化方案</h2><h3 id=\"存储方案\"><a href=\"#存储方案\" class=\"headerlink\" title=\"存储方案\"></a>存储方案</h3><ul>\n<li>plist文件（属性列表）</li>\n<li>preference（偏好设置）</li>\n<li>NSKeyedArchiver（归档）</li>\n<li>SQLite 3</li>\n<li>CoreData</li>\n</ul>\n<h3 id=\"沙盒\"><a href=\"#沙盒\" class=\"headerlink\" title=\"沙盒\"></a>沙盒</h3><blockquote>\n<p>iOS程序默认情况下只能访问程序自己的目录，这个目录被称为“沙盒”。</p>\n</blockquote>\n<h4 id=\"1-结构\"><a href=\"#1-结构\" class=\"headerlink\" title=\"1.结构\"></a>1.结构</h4><p>沙盒的目录结构如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"应用程序包\"</span></div><div class=\"line\">Documents</div><div class=\"line\">Library</div><div class=\"line\">    Caches</div><div class=\"line\">    Preferences</div><div class=\"line\">tmp</div></pre></td></tr></table></figure>\n<h4 id=\"2-目录特性\"><a href=\"#2-目录特性\" class=\"headerlink\" title=\"2.目录特性\"></a>2.目录特性</h4><blockquote>\n<p>虽然沙盒中有这么多文件夹，但是每个文件夹都不尽相同，都有各自的特性。所以在选择存放目录时，一定要认真选择适合的目录。</p>\n</blockquote>\n<p>“应用程序包”: 这里面存放的是应用程序的<strong>源文件</strong>，包括<strong>资源文件</strong>和<strong>可执行文件</strong>。</p>\n<ul>\n<li>Documents: 最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *path = [[<span class=\"built_in\">NSBundle</span> mainBundle] bundlePath];</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, path);</div></pre></td></tr></table></figure>\n<ul>\n<li>Library/Caches: iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).firstObject;</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, path);</div></pre></td></tr></table></figure>\n<ul>\n<li>Library/Preferences: iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSCachesDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).firstObject;</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, path);</div></pre></td></tr></table></figure>\n<ul>\n<li>tmp: iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *path = <span class=\"built_in\">NSTemporaryDirectory</span>();</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, path);</div></pre></td></tr></table></figure>\n<h3 id=\"plist文件\"><a href=\"#plist文件\" class=\"headerlink\" title=\"plist文件\"></a>plist文件</h3><blockquote>\n<p>plist文件是将某些特定的类，通过XML文件的方式保存在目录中。</p>\n</blockquote>\n<p>可以被序列化的类型只有如下几种：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span>;</div><div class=\"line\"><span class=\"built_in\">NSMutableArray</span>;</div><div class=\"line\"><span class=\"built_in\">NSDictionary</span>;</div><div class=\"line\"><span class=\"built_in\">NSMutableDictionary</span>;</div><div class=\"line\"><span class=\"built_in\">NSData</span>;</div><div class=\"line\"><span class=\"built_in\">NSMutableData</span>;</div><div class=\"line\"><span class=\"built_in\">NSString</span>;</div><div class=\"line\"><span class=\"built_in\">NSMutableString</span>;</div><div class=\"line\"><span class=\"built_in\">NSNumber</span>;</div><div class=\"line\"><span class=\"built_in\">NSDate</span>;</div></pre></td></tr></table></figure>\n<h4 id=\"1-获得文件路径\"><a href=\"#1-获得文件路径\" class=\"headerlink\" title=\"1.获得文件路径\"></a>1.获得文件路径</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).firstObject;</div><div class=\"line\"><span class=\"built_in\">NSString</span> *fileName = [path stringByAppendingPathComponent:<span class=\"string\">@\"123.plist\"</span>];</div></pre></td></tr></table></figure>\n<h4 id=\"2-存储\"><a href=\"#2-存储\" class=\"headerlink\" title=\"2.存储\"></a>2.存储</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[<span class=\"string\">@\"123\"</span>, <span class=\"string\">@\"456\"</span>, <span class=\"string\">@\"789\"</span>];</div><div class=\"line\">[array writeToFile:fileName atomically:<span class=\"literal\">YES</span>];</div></pre></td></tr></table></figure>\n<h4 id=\"3-读取\"><a href=\"#3-读取\" class=\"headerlink\" title=\"3.读取\"></a>3.读取</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *result = [<span class=\"built_in\">NSArray</span> arrayWithContentsOfFile:fileName];</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, result);</div></pre></td></tr></table></figure>\n<h4 id=\"4-注意\"><a href=\"#4-注意\" class=\"headerlink\" title=\"4.注意\"></a>4.注意</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 只有以上列出的类型才能使用plist文件存储。</span></div><div class=\"line\"><span class=\"comment\">// 存储时使用writeToFile: atomically:方法。 其中atomically表示是否需要先写入一个辅助文件，再把辅助文件拷贝到目标文件地址。这是更安全的写入文件方法，一般都写YES。</span></div><div class=\"line\"><span class=\"comment\">// 读取时使用arrayWithContentsOfFile:方法。</span></div></pre></td></tr></table></figure>\n<h3 id=\"Preference\"><a href=\"#Preference\" class=\"headerlink\" title=\"Preference\"></a>Preference</h3><h4 id=\"1-使用方法\"><a href=\"#1-使用方法\" class=\"headerlink\" title=\"1.使用方法\"></a>1.使用方法</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1.获得NSUserDefaults文件</span></div><div class=\"line\"><span class=\"built_in\">NSUserDefaults</span> *userDefaults = [<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2.向文件中写入内容</span></div><div class=\"line\">[userDefaults setObject:<span class=\"string\">@\"AAA\"</span> forKey:<span class=\"string\">@\"a\"</span>];</div><div class=\"line\">[userDefaults setBool:<span class=\"literal\">YES</span> forKey:<span class=\"string\">@\"sex\"</span>];</div><div class=\"line\">[userDefaults setInteger:<span class=\"number\">21</span> forKey:<span class=\"string\">@\"age\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2.1立即同步</span></div><div class=\"line\">[userDefaults synchronize];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3.读取文件</span></div><div class=\"line\"><span class=\"built_in\">NSString</span> *name = [userDefaults objectForKey:<span class=\"string\">@\"a\"</span>];</div><div class=\"line\"><span class=\"built_in\">BOOL</span> sex = [userDefaults boolForKey:<span class=\"string\">@\"sex\"</span>];</div><div class=\"line\"><span class=\"built_in\">NSInteger</span> age = [userDefaults integerForKey:<span class=\"string\">@\"age\"</span>];</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@, %d, %ld\"</span>, name, sex, age);</div></pre></td></tr></table></figure>\n<h4 id=\"2-注意\"><a href=\"#2-注意\" class=\"headerlink\" title=\"2.注意\"></a>2.注意</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 偏好设置是专门用来保存应用程序的配置信息的，一般不要在偏好设置中保存其他数据。</span></div><div class=\"line\"><span class=\"comment\">// 如果没有调用synchronize方法，系统会根据I/O情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用synchronize方法。</span></div><div class=\"line\"><span class=\"comment\">// 偏好设置会将所有数据保存到同一个文件中。即preference目录下的一个以此应用包名来命名的plist文件。</span></div></pre></td></tr></table></figure>\n<h3 id=\"NSKeyedArchiver\"><a href=\"#NSKeyedArchiver\" class=\"headerlink\" title=\"NSKeyedArchiver\"></a>NSKeyedArchiver</h3><blockquote>\n<p>归档在iOS中是另一种形式的序列化，只要遵循了NSCoding协议的对象都可以通过它实现序列化。由于决大多数支持存储数据的Foundation和Cocoa Touch类都遵循了NSCoding协议，因此，对于大多数类来说，归档相对而言还是比较容易实现的。</p>\n</blockquote>\n<h4 id=\"1-遵循NSCoding协议\"><a href=\"#1-遵循NSCoding协议\" class=\"headerlink\" title=\"1.遵循NSCoding协议\"></a>1.遵循NSCoding协议</h4><blockquote>\n<p>NSCoding协议声明了两个方法，这两个方法都是必须实现的。一个用来说明如何将对象编码到归档中，另一个说明如何进行解档来获取一个新对象。</p>\n</blockquote>\n<p>遵循协议和设置属性</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1.遵循NSCoding协议 </span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Person</span> : <span class=\"title\">NSObject</span>   //2.设置属性</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">UIImage</span> *avatar;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">copy</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSString</span> *name;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">assign</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSInteger</span> age;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>实现协议方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//解档</span></div><div class=\"line\">- (<span class=\"keyword\">id</span>)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.avatar = [aDecoder decodeObjectForKey:<span class=\"string\">@\"avatar\"</span>];</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = [aDecoder decodeObjectForKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">        <span class=\"keyword\">self</span>.age = [aDecoder decodeIntegerForKey:<span class=\"string\">@\"age\"</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//归档</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)encodeWithCoder:(<span class=\"built_in\">NSCoder</span> *)aCoder &#123;</div><div class=\"line\">    [aCoder encodeObject:<span class=\"keyword\">self</span>.avatar forKey:<span class=\"string\">@\"avatar\"</span>];</div><div class=\"line\">    [aCoder encodeObject:<span class=\"keyword\">self</span>.name forKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">    [aCoder encodeInteger:<span class=\"keyword\">self</span>.age forKey:<span class=\"string\">@\"age\"</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>特别注意</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">如果需要归档的类是某个自定义类的子类时，就需要在归档和解档之前先实现父类的归档和解档方法。即 [<span class=\"keyword\">super</span> encodeWithCoder:aCoder] 和 [<span class=\"keyword\">super</span> initWithCoder:aDecoder] 方法;</div></pre></td></tr></table></figure>\n<h4 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2.使用\"></a>2.使用</h4><p>需要把对象归档是调用<code>NSKeyedArchiver</code>的工厂方法 <code>archiveRootObject: toFile:</code>方法。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *file = [<span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).firstObject stringByAppendingPathComponent:<span class=\"string\">@\"person.data\"</span>];</div><div class=\"line\">Person *person = [[Person alloc] init];</div><div class=\"line\">person.avatar = <span class=\"keyword\">self</span>.avatarView.image;</div><div class=\"line\">person.name = <span class=\"keyword\">self</span>.nameField.text;</div><div class=\"line\">person.age = [<span class=\"keyword\">self</span>.ageField.text integerValue];</div><div class=\"line\">[<span class=\"built_in\">NSKeyedArchiver</span> archiveRootObject:person toFile:file];</div></pre></td></tr></table></figure>\n<p>需要从文件中解档对象就调用<code>NSKeyedUnarchiver</code>的一个工厂方法 <code>unarchiveObjectWithFile:</code> 即可。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *file = [<span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).firstObject stringByAppendingPathComponent:<span class=\"string\">@\"person.data\"</span>];</div><div class=\"line\">Person *person = [<span class=\"built_in\">NSKeyedUnarchiver</span> unarchiveObjectWithFile:file];</div><div class=\"line\"><span class=\"keyword\">if</span> (person) </div><div class=\"line\">&#123;</div><div class=\"line\">   <span class=\"keyword\">self</span>.avatarView.image = person.avatar;</div><div class=\"line\">   <span class=\"keyword\">self</span>.nameField.text = person.name;</div><div class=\"line\">   <span class=\"keyword\">self</span>.ageField.text = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%ld\"</span>, person.age];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-注意\"><a href=\"#3-注意\" class=\"headerlink\" title=\"3.注意\"></a>3.注意</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">必须遵循并实现<span class=\"built_in\">NSCoding</span>协议</div><div class=\"line\">保存文件的扩展名可以任意指定</div><div class=\"line\">继承时必须先调用父类的归档解档方法</div></pre></td></tr></table></figure>\n<h3 id=\"SQLite3\"><a href=\"#SQLite3\" class=\"headerlink\" title=\"SQLite3\"></a>SQLite3</h3><blockquote>\n<p>之前的所有存储方法，都是覆盖存储。如果想要增加一条数据就必须把整个文件读出来，然后修改数据后再把整个内容覆盖写入文件。所以它们都不适合存储大量的内容。</p>\n</blockquote>\n<h4 id=\"1-字段类型\"><a href=\"#1-字段类型\" class=\"headerlink\" title=\"1.字段类型\"></a>1.字段类型</h4><p>表面上·SQLite·将数据分为以下几种类型：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">integer : 整数</div><div class=\"line\">real : 实数（浮点数）</div><div class=\"line\">text : 文本字符串</div><div class=\"line\">blob : 二进制数据，比如文件，图片之类的</div></pre></td></tr></table></figure>\n<p>实际上<code>SQLite</code>是无类型的。即不管你在创表时指定的字段类型是什么，存储是依然可以存储任意类型的数据。而且在创表时也可以不指定字段类型。<code>SQLite</code>之所以什么类型就是为了良好的编程规范和方便开发人员交流，所以平时在使用时最好设置正确的字段类型！主键必须设置成<code>integer</code></p>\n<h4 id=\"2-准备工作\"><a href=\"#2-准备工作\" class=\"headerlink\" title=\"2. 准备工作\"></a>2. 准备工作</h4><p>准备工作就是导入依赖库啦，在<code>iOS</code>中要使用<code>SQLite3</code>，需要添加库文件：<code>libsqlite3.dylib</code>并导入主头文件，这是一个<code>C语言</code>的库，所以直接使用<code>SQLite3</code>还是比较麻烦的。</p>\n<h4 id=\"3-使用\"><a href=\"#3-使用\" class=\"headerlink\" title=\"3.使用\"></a>3.使用</h4><h5 id=\"1-创建数据库并打开\"><a href=\"#1-创建数据库并打开\" class=\"headerlink\" title=\"1.创建数据库并打开\"></a>1.创建数据库并打开</h5><p>操作数据库之前必须先指定数据库文件和要操作的表，所以使用<code>SQLite3</code>，首先要打开数据库文件，然后指定或创建一张表。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//  打开数据库并创建一个表</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)openDatabase </div><div class=\"line\">&#123;</div><div class=\"line\">   <span class=\"comment\">//1.设置文件名</span></div><div class=\"line\">   <span class=\"built_in\">NSString</span> *filename = [<span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).firstObject stringByAppendingPathComponent:<span class=\"string\">@\"person.db\"</span>];</div><div class=\"line\">   </div><div class=\"line\">   <span class=\"comment\">//2.打开数据库文件，如果没有会自动创建一个文件</span></div><div class=\"line\">   <span class=\"built_in\">NSInteger</span> result = sqlite3_open(filename.UTF8String, &amp;_sqlite3);</div><div class=\"line\">   </div><div class=\"line\">   <span class=\"keyword\">if</span> (result == SQLITE_OK) </div><div class=\"line\">   &#123;</div><div class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"打开数据库成功！\"</span>);</div><div class=\"line\">       </div><div class=\"line\">       <span class=\"comment\">//3.创建一个数据库表</span></div><div class=\"line\">       <span class=\"keyword\">char</span> *errmsg = <span class=\"literal\">NULL</span>;</div><div class=\"line\">       sqlite3_exec(_sqlite3, <span class=\"string\">\"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)\"</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, &amp;errmsg);</div><div class=\"line\">       </div><div class=\"line\">       <span class=\"keyword\">if</span> (errmsg) </div><div class=\"line\">       &#123;</div><div class=\"line\">           <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"错误：%s\"</span>, errmsg);</div><div class=\"line\">       &#125; </div><div class=\"line\">       <span class=\"keyword\">else</span> </div><div class=\"line\">       &#123;</div><div class=\"line\">           <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"创表成功！\"</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125; </div><div class=\"line\">   <span class=\"keyword\">else</span> </div><div class=\"line\">   &#123;</div><div class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"打开数据库失败！\"</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"2-执行指令\"><a href=\"#2-执行指令\" class=\"headerlink\" title=\"2.执行指令\"></a>2.执行指令</h5><p>使用 <code>sqlite3_exec()</code> 方法可以执行任何<code>SQL</code>语句，比如<code>创表、更新、插入和删除</code>操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 往表中插入1000条数据</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)insertData </div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *nameStr;</div><div class=\"line\">    <span class=\"built_in\">NSInteger</span> age;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) </div><div class=\"line\">    &#123;</div><div class=\"line\">      nameStr = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"Bourne-%d\"</span>, arc4random_uniform(<span class=\"number\">10000</span>)];</div><div class=\"line\">      age = arc4random_uniform(<span class=\"number\">80</span>) + <span class=\"number\">20</span>;</div><div class=\"line\">      <span class=\"built_in\">NSString</span> *sql = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"INSERT INTO t_person (name, age) VALUES('%@', '%ld')\"</span>, nameStr, age];</div><div class=\"line\">      <span class=\"keyword\">char</span> *errmsg = <span class=\"literal\">NULL</span>;</div><div class=\"line\">      sqlite3_exec(_sqlite3, sql.UTF8String, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, &amp;errmsg);</div><div class=\"line\">      <span class=\"keyword\">if</span> (errmsg) </div><div class=\"line\">      &#123;</div><div class=\"line\">          <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"错误：%s\"</span>, errmsg);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"插入完毕！\"</span>);   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"3-查询指令\"><a href=\"#3-查询指令\" class=\"headerlink\" title=\"3.查询指令\"></a>3.查询指令</h5><p>前面说过一般不使用 sqlite3_exec() 方法查询数据。因为查询数据必须要获得查询结果，所以查询相对比较麻烦。示例代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// sqlite3_prepare_v2() : 检查sql的合法性</span></div><div class=\"line\"><span class=\"comment\">// sqlite3_step() : 逐行获取查询结果，不断重复，直到最后一条记录</span></div><div class=\"line\"><span class=\"comment\">// sqlite3_coloum_xxx() : 获取对应类型的内容，iCol对应的就是SQL语句中字段的顺序，从0开始。根据实际查询字段的属性，使用sqlite3_column_xxx取得对应的内容即可。</span></div><div class=\"line\"><span class=\"comment\">// sqlite3_finalize() : 释放stmt</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 从表中读取数据到数组中</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)readData </div><div class=\"line\">&#123;</div><div class=\"line\">   <span class=\"built_in\">NSMutableArray</span> *mArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithCapacity:<span class=\"number\">1000</span>];</div><div class=\"line\">   <span class=\"keyword\">char</span> *sql = <span class=\"string\">\"select name, age from t_person;\"</span>;</div><div class=\"line\">   sqlite3_stmt *stmt;</div><div class=\"line\">   <span class=\"built_in\">NSInteger</span> result = sqlite3_prepare_v2(_sqlite3, sql, <span class=\"number\">-1</span>, &amp;stmt, <span class=\"literal\">NULL</span>);</div><div class=\"line\">   </div><div class=\"line\">   <span class=\"keyword\">if</span> (result == SQLITE_OK) </div><div class=\"line\">   &#123;</div><div class=\"line\">       <span class=\"keyword\">while</span> (sqlite3_step(stmt) == SQLITE_ROW) </div><div class=\"line\">       &#123;</div><div class=\"line\">           <span class=\"keyword\">char</span> *name = (<span class=\"keyword\">char</span> *)sqlite3_column_text(stmt, <span class=\"number\">0</span>);</div><div class=\"line\">           <span class=\"built_in\">NSInteger</span> age = sqlite3_column_int(stmt, <span class=\"number\">1</span>);</div><div class=\"line\">           <span class=\"comment\">//创建对象</span></div><div class=\"line\">           Person *person = [Person personWithName:[<span class=\"built_in\">NSString</span> stringWithUTF8String:name] Age:age];</div><div class=\"line\">           [mArray addObject:person];</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">self</span>.dataList = mArray;</div><div class=\"line\">   &#125;</div><div class=\"line\">   sqlite3_finalize(stmt);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h4><p>总得来说，<code>SQLite3</code>的使用还是比较麻烦的，因为都是些<code>c语言</code>的函数，理解起来有些困难。不过在一般开发过程中，使用的都是第三方开源库 <code>FMDB</code>，封装了这些基本的<code>c语言</code>方法，使得我们在使用时更加容易理解，提高开发效率。</p>\n<h3 id=\"FMDB\"><a href=\"#FMDB\" class=\"headerlink\" title=\"FMDB\"></a>FMDB</h3><h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h4><blockquote>\n<p>FMDB是iOS平台的SQLite数据库框架，它是以OC的方式封装了SQLite的C语言API，它相对于cocoa自带的C语言框架有如下的优点:<br>使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码<br>对比苹果自带的Core Data框架，更加轻量级和灵活<br>提供了多线程安全的数据库操作方法，有效地防止数据混乱</p>\n</blockquote>\n<h4 id=\"2-核心类\"><a href=\"#2-核心类\" class=\"headerlink\" title=\"2.核心类\"></a>2.核心类</h4><p><strong>FMDB有三个主要的类：</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// FMDatabase</span></div><div class=\"line\">一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// FMResultSet</span></div><div class=\"line\">使用FMDatabase执行查询后的结果集</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// FMDatabaseQueue</span></div><div class=\"line\">用于在多线程中执行多个查询或更新，它是线程安全的</div></pre></td></tr></table></figure>\n<h4 id=\"3-打开数据库\"><a href=\"#3-打开数据库\" class=\"headerlink\" title=\"3.打开数据库\"></a>3.打开数据库</h4><blockquote>\n<p>和c语言框架一样，FMDB通过指定SQLite数据库文件路径来创建FMDatabase对象，但FMDB更加容易理解，使用起来更容易，使用之前一样需要导入sqlite3.dylib。打开数据库方法如下：</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *path = [<span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).firstObject stringByAppendingPathComponent:<span class=\"string\">@\"person.db\"</span>];</div><div class=\"line\">FMDatabase *database = [FMDatabase databaseWithPath:path]; </div><div class=\"line\">   </div><div class=\"line\"><span class=\"keyword\">if</span> (![database open]) </div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"数据库打开失败！\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>值得注意的是，Path的值可以传入以下三种情况：</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 具体文件路径，如果不存在会自动创建</span></div><div class=\"line\"><span class=\"comment\">// 空字符串@\"\"，会在临时目录创建一个空的数据库，当FMDatabase连接关闭时，数据库文件也被删除</span></div><div class=\"line\"><span class=\"comment\">// nil，会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁</span></div></pre></td></tr></table></figure>\n<h4 id=\"4-更新\"><a href=\"#4-更新\" class=\"headerlink\" title=\"4.更新\"></a>4.更新</h4><blockquote>\n<p>在FMDB中，除查询以外的所有操作，都称为“更新”, 如：create、drop、insert、update、delete等操作，使用executeUpdate:方法执行更新：</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//常用方法有以下 3 种：   </span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)executeUpdate:(<span class=\"built_in\">NSString</span>*)sql, ...</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)executeUpdateWithFormat:(<span class=\"built_in\">NSString</span>*)format, ...</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)executeUpdate:(<span class=\"built_in\">NSString</span>*)sql withArgumentsInArray:(<span class=\"built_in\">NSArray</span> *)arguments</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//示例</span></div><div class=\"line\">[database executeUpdate:<span class=\"string\">@\"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)\"</span>]; </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">//或者  </span></div><div class=\"line\">[database executeUpdate:<span class=\"string\">@\"INSERT INTO t_person(name, age) VALUES(?, ?)\"</span>, <span class=\"string\">@\"Bourne\"</span>, [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">42</span>]];</div></pre></td></tr></table></figure>\n<h4 id=\"5-查询\"><a href=\"#5-查询\" class=\"headerlink\" title=\"5.查询\"></a>5.查询</h4><p>查询方法也有3种，使用起来相当简单：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (FMResultSet *)executeQuery:(<span class=\"built_in\">NSString</span>*)sql, ...</div><div class=\"line\">- (FMResultSet *)executeQueryWithFormat:(<span class=\"built_in\">NSString</span>*)format, ...</div><div class=\"line\">- (FMResultSet *)executeQuery:(<span class=\"built_in\">NSString</span> *)sql withArgumentsInArray:(<span class=\"built_in\">NSArray</span> *)arguments</div></pre></td></tr></table></figure>\n<p>查询示例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1.执行查询</span></div><div class=\"line\">FMResultSet *result = [database executeQuery:<span class=\"string\">@\"SELECT * FROM t_person\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2.遍历结果集</span></div><div class=\"line\"><span class=\"keyword\">while</span> ([result next]) </div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *name = [result stringForColumn:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> age = [result intForColumn:<span class=\"string\">@\"age\"</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"6-线程安全\"><a href=\"#6-线程安全\" class=\"headerlink\" title=\"6.线程安全\"></a>6.线程安全</h4><blockquote>\n<p>在多个线程中同时使用一个 <code>FMDatabase</code> 实例是不明智的。不要让多个线程分享同一个<code>FMDatabase</code>实例，它无法在多个线程中同时使用。 如果在多个线程中同时使用一个<code>FMDatabase</code>实例，会造成数据混乱等问题。所以，请使用 <code>FMDatabaseQueue</code>，它是线程安全的。以下是使用方法：</p>\n</blockquote>\n<p>创建队列。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用队列</span></div><div class=\"line\">[queue inDatabase:^(FMDatabase *database)</div><div class=\"line\">&#123;    </div><div class=\"line\">          [database executeUpdate:<span class=\"string\">@\"INSERT INTO t_person(name, age) VALUES (?, ?)\"</span>, <span class=\"string\">@\"Bourne_1\"</span>, [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">1</span>]];    </div><div class=\"line\">          [database executeUpdate:<span class=\"string\">@\"INSERT INTO t_person(name, age) VALUES (?, ?)\"</span>, <span class=\"string\">@\"Bourne_2\"</span>, [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">2</span>]];    </div><div class=\"line\">          [database executeUpdate:<span class=\"string\">@\"INSERT INTO t_person(name, age) VALUES (?, ?)\"</span>, <span class=\"string\">@\"Bourne_3\"</span>, [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">3</span>]];      </div><div class=\"line\">          FMResultSet *result = [database executeQuery:<span class=\"string\">@\"select * from t_person\"</span>];    </div><div class=\"line\">         <span class=\"keyword\">while</span>([result next]) &#123;   </div><div class=\"line\">         &#125;    </div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 而且可以轻松地把简单任务包装到事务里：</span></div><div class=\"line\">[queue inTransaction:^(FMDatabase *database, <span class=\"built_in\">BOOL</span> *rollback) &#123;    </div><div class=\"line\">          [database executeUpdate:<span class=\"string\">@\"INSERT INTO t_person(name, age) VALUES (?, ?)\"</span>, <span class=\"string\">@\"Bourne_1\"</span>, [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">1</span>]];    </div><div class=\"line\">          [database executeUpdate:<span class=\"string\">@\"INSERT INTO t_person(name, age) VALUES (?, ?)\"</span>, <span class=\"string\">@\"Bourne_2\"</span>, [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">2</span>]];    </div><div class=\"line\">          [database executeUpdate:<span class=\"string\">@\"INSERT INTO t_person(name, age) VALUES (?, ?)\"</span>, <span class=\"string\">@\"Bourne_3\"</span>, [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">3</span>]];      </div><div class=\"line\">          FMResultSet *result = [database executeQuery:<span class=\"string\">@\"select * from t_person\"</span>];    </div><div class=\"line\">             <span class=\"keyword\">while</span>([result next]) &#123;   </div><div class=\"line\">             &#125;   </div><div class=\"line\">           <span class=\"comment\">//回滚</span></div><div class=\"line\">           *rollback = <span class=\"literal\">YES</span>;  </div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<p>FMDatabaseQueue 后台会建立系列化的<code>GCD</code>队列，并执行你传给<code>GCD</code>队列的块。这意味着 你从多线程同时调用调用方法，<code>GCD</code>也会按它接收的块的顺序来执行了。</p>\n","excerpt":"文章大纲，便于浏览 01-iOS程序启动过程 02-浅拷贝-深拷贝 03-View的生命周期 04-@property 05-事件传递和事件响应 06-KVC 07-KVO 08-iOS数据持久化方案 01-iOS-App-startup-process一、启动完整过程","categories":[],"tags":[{"name":"知识总结","slug":"知识总结","permalink":"http://yoursite.com/tags/知识总结/"}]},{"title":"weak-弱引用实现原理","date":"2017-04-03T06:33:09.000Z","path":"2017/04/03/weak-弱引用实现原理/","text":"weak是一个弱引用，这个引用不会增加对象的引用计数，并且所指对象在释放后被自动置为nil。weak通常用于处理循环引用的问题。如代理属性以及block中用得比较多。 此处重点记录一下weak的实现过程 123&#123; id __weak obj1 = obj;&#125; 当我们初始化一个weak属性的变量时，Runtime会调用objc_initWeak函数 声明如下： 123&#123; id objc_initWeak (id *object , id value);&#125; 其具体实现如下： 12345id objc_initWeak (id *object , id value)&#123; *object = 0; return objc_storeWeak(object,value);&#125; 轮换成编译器代码如下 12id obj1;objc_initWeak(&amp;obj1,obj); 因此，这里所做的事是先将obj1初始化为0(nil)，然后将obj1的地址及obj作为参数传递给objc_storeWeak函数。 objc_storeWeak的函数声明如下: 1id objc_storeWeak(id *location, id value); 具体实现相对较为复杂，去掉线程之间锁之后，大致如下： 12345678910111213141516171819202122id objc_storeWeak(id *location, id newObj)&#123; id oldObj; SideTable *oldTable; SideTable *newTable; oldObj = *location; // 旧值 oldTable = SideTable::tableForPointer(oldObj); // 旧表 newTable = SideTable::tableForPointer(newObj); // 新表 if (oldObj) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); &#125; if (newObj) &#123; newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location); &#125; *location = newObj; return newObj;&#125; 这里面有很关键的两个结构体weak和SideTable weak表是一个弱引用表，实现为一个weak_table_t结构体，存储了某个对象相关的的所有的弱引用信息。其定义如下(具体定义在objc-weak.h中)： 12345struct weak_table_t &#123; weak_entry_t *weak_entries; size_t num_entries; ......&#125;; 其中weak_entry_t是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用hash表。其定义如下： 1234567891011121314struct weak_entry_t &#123; DisguisedPtr&lt;objc_object&gt; referent; union &#123; struct &#123; weak_referrer_t *referrers; uintptr_t out_of_line : 1; ...... &#125;; struct &#123; weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; &#125;; &#125;;&#125;; SideTable是一个用C++实现的类，它的具体定义在NSObject.mm中，看看它的一些成员变量的定义: 1234567class SideTable &#123;private: static uint8_t table_buf[SIDE_TABLE_STRIPE * SIDE_TABLE_SIZE];public: RefcountMap refcnts; weak_table_t weak_table;&#125; 了解了weak表和SideTable，让我们再回过头来看看objc_storeWeak。首先是根据weak指针找到其指向的老的对象： 1oldObj = *location; 然后获取到与新旧对象相关的SideTable对象： 12oldTable = SideTable::tableForPointer(oldObj);newTable = SideTable::tableForPointer(newObj); 下面要做的就是在老对象的weak表中移除指向信息，而在新对象的weak表中建立关联信息： 123456if (oldObj) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);&#125;if (newObj) &#123; newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location);&#125; 接下来让弱引用指针指向新的对象： 1*location = newObj; 最后会返回这个新对象： 1return newObj; 而当weak引用指向的对象被释放时，其基本流程如下： 调用objc_release 因为对象的引用计数为0，所以执行dealloc 在dealloc中，调用了_objc_rootDealloc函数 在_objc_rootDealloc中，调用了object_dispose函数 调用objc_destructInstance 最后调用objc_clear_deallocating objc_clear_deallocating中首先取出对象对应的SideTable实例，如果这个对象有关联的弱引用，则调用arr_clear_deallocating来清除对象的弱引用信息。 这个函数首先是找出对象对应的weak_entry_t链表，然后挨个将弱引用置为nil。最后清理对象的记录。 一个weak引用的处理涉及各种查表、添加与删除操作，还是有一定消耗的。所以如果大量使用__weak变量的话，会对性能造成一定的影响。","content":"<p><code>weak</code>是一个弱引用，这个引用不会增加对象的引用计数，并且所指对象在释放后被自动置为nil。<code>weak</code>通常用于处理循环引用的问题。如<code>代理</code>属性以及<code>block</code>中用得比较多。</p>\n<p>此处重点记录一下<code>weak</code>的实现过程</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> __<span class=\"keyword\">weak</span> obj1 = obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>当我们初始化一个<code>weak</code>属性的变量时，<code>Runtime</code>会调用<code>objc_initWeak</code>函数</p>\n<p>声明如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> objc_initWeak (<span class=\"keyword\">id</span> *object , <span class=\"keyword\">id</span> value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其具体实现如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">id</span> objc_initWeak (<span class=\"keyword\">id</span> *object , <span class=\"keyword\">id</span> value)</div><div class=\"line\">&#123;</div><div class=\"line\">   *object = <span class=\"number\">0</span>;</div><div class=\"line\">   <span class=\"keyword\">return</span> objc_storeWeak(object,value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>轮换成编译器代码如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">id</span> obj1;</div><div class=\"line\">objc_initWeak(&amp;obj1,obj);</div></pre></td></tr></table></figure>\n<p>因此，这里所做的事是先将<code>obj1</code>初始化为<code>0(nil)</code>，然后将<code>obj1</code>的地址及<code>obj</code>作为参数传递给<code>objc_storeWeak</code>函数。</p>\n<p><code>objc_storeWeak</code>的函数声明如下:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">id</span> objc_storeWeak(<span class=\"keyword\">id</span> *location, <span class=\"keyword\">id</span> value);</div></pre></td></tr></table></figure>\n<p>具体实现相对较为复杂，去掉线程之间锁之后，大致如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">id</span> objc_storeWeak(<span class=\"keyword\">id</span> *location, <span class=\"keyword\">id</span> newObj)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> oldObj;</div><div class=\"line\">    SideTable *oldTable;</div><div class=\"line\">    SideTable *newTable;  </div><div class=\"line\"></div><div class=\"line\">    oldObj = *location;                               <span class=\"comment\">// 旧值</span></div><div class=\"line\">    oldTable = SideTable::tableForPointer(oldObj);    <span class=\"comment\">// 旧表</span></div><div class=\"line\">    newTable = SideTable::tableForPointer(newObj);    <span class=\"comment\">// 新表</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (oldObj) &#123;</div><div class=\"line\">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (newObj) &#123;</div><div class=\"line\">        newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location);</div><div class=\"line\">    &#125;</div><div class=\"line\">   </div><div class=\"line\">    *location = newObj;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> newObj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里面有很关键的两个结构体<code>weak</code>和<code>SideTable</code></p>\n<p><code>weak</code>表是一个弱引用表，实现为一个<code>weak_table_t</code>结构体，存储了某个对象相关的的所有的弱引用信息。其定义如下(具体定义在<code>objc-weak.h</code>中)：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> weak_table_t &#123;</div><div class=\"line\">    weak_entry_t *weak_entries;</div><div class=\"line\">    size_t    num_entries;</div><div class=\"line\">    ......</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>其中<code>weak_entry_t</code>是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用<code>hash</code>表。其定义如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> weak_entry_t &#123;</div><div class=\"line\">    DisguisedPtr&lt;objc_object&gt; referent;</div><div class=\"line\">    <span class=\"keyword\">union</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">            weak_referrer_t *referrers;</div><div class=\"line\">            uintptr_t        out_of_line : <span class=\"number\">1</span>;</div><div class=\"line\">            ......</div><div class=\"line\">        &#125;;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>SideTable</code>是一个用<code>C++</code>实现的类，它的具体定义在<code>NSObject.mm</code>中，看看它的一些成员变量的定义:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> SideTable &#123;</div><div class=\"line\">private:</div><div class=\"line\">    <span class=\"keyword\">static</span> uint8_t table_buf[SIDE_TABLE_STRIPE * SIDE_TABLE_SIZE];</div><div class=\"line\">public:</div><div class=\"line\">    RefcountMap refcnts;</div><div class=\"line\">    weak_table_t weak_table;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>了解了<code>weak</code>表和<code>SideTable</code>，让我们再回过头来看看<code>objc_storeWeak</code>。首先是根据<code>weak</code>指针找到其指向的老的对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">oldObj = *location;</div></pre></td></tr></table></figure>\n<p>然后获取到与新旧对象相关的<code>SideTable</code>对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">oldTable = SideTable::tableForPointer(oldObj);</div><div class=\"line\">newTable = SideTable::tableForPointer(newObj);</div></pre></td></tr></table></figure>\n<p>下面要做的就是在老对象的<code>weak</code>表中移除指向信息，而在新对象的<code>weak</code>表中建立关联信息：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (oldObj) &#123;</div><div class=\"line\">    weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">if</span> (newObj) &#123;</div><div class=\"line\">    newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来让弱引用指针指向新的对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">*location = newObj;</div></pre></td></tr></table></figure>\n<p>最后会返回这个新对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> newObj;</div></pre></td></tr></table></figure>\n<p>而当<code>weak</code>引用指向的对象被释放时，其基本流程如下：</p>\n<ul>\n<li>调用<code>objc_release</code></li>\n<li>因为对象的引用计数为<code>0</code>，所以执行<code>dealloc</code></li>\n<li>在<code>dealloc</code>中，调用了<code>_objc_rootDealloc</code>函数</li>\n<li>在<code>_objc_rootDealloc</code>中，调用了<code>object_dispose</code>函数</li>\n<li>调用<code>objc_destructInstance</code></li>\n<li>最后调用<code>objc_clear_deallocating</code></li>\n</ul>\n<p><code>objc_clear_deallocating</code>中首先取出对象对应的<code>SideTable</code>实例，如果这个对象有关联的弱引用，则调用<code>arr_clear_deallocating</code>来清除对象的弱引用信息。</p>\n<p>这个函数首先是找出对象对应的<code>weak_entry_t</code>链表，然后挨个将弱引用置为<code>nil</code>。最后清理对象的记录。</p>\n<p>一个<code>weak</code>引用的处理涉及各种查表、添加与删除操作，还是有一定消耗的。所以如果大量使用__weak变量的话，会对性能造成一定的影响。</p>\n","excerpt":"weak是一个弱引用，这个引用不会增加对象的引用计数，并且所指对象在释放后被自动置为nil。weak通常用于处理循环引用的问题。如代理属性以及block中用得比较多。 此处重点记录一下weak的实现过程 123&#123; id __weak obj1 = obj;&#125;","categories":[],"tags":[{"name":"读后感","slug":"读后感","permalink":"http://yoursite.com/tags/读后感/"}]},{"title":"Healthkit睡眠分析","date":"2016-05-03T06:55:55.000Z","path":"2016/05/03/Healthkit睡眠分析/","text":"原文：http://appcoda.com/sleep-analysis-healthkit/ 翻译：Liberalism 日期：2016年5月3日 现如今，睡眠变革已经成为了一种全新的潮流。用户比以往任何时候都更加关注自己的睡眠。他们不仅仅关心自己睡了多久，同样也很希望通过一段时间的数据收集和分析能够绘制出他们的睡眠趋势。而技术上的进步，包括硬件、特别是智能手机的高速发展，使睡眠变革这一高速发展的领域迎来了全新的曙光。 苹果在基于安全的前提下，提供了一种非常酷的方式来与用户的个人健康信息进行通信，并通过iOS内置的健康应用存储信息。作为开发者不仅可以使用HealyhKit来打造健康类的App，同时该框架还允许开发者访问睡眠数据，进行处理分析。 在本教程中，针对Healthkit框架我会带领大家快速入门，同时会向大家演示如果快速搭建一个简单的睡眠分析的App 1.简介 HealthKit框架结构提供了一个称之为HealthKit Store的加密数据库，开发者可以使用HKhealth Store这个类来访问这个数据库。iPhone和Apple Watch分别有自己的HealthKit Store，健康数据会在iPhone和Apple Watch之间同步。然而，Apple Watch为了节省内存空间会自动清理掉一些旧的数据。目前healthKit框架和健康类的App在iPad上是不支持的。 如果你想创建一个基于健康数据的iOS App或者是WatchOS App，HealthKit框架无疑是非常强大的一个工具。HealthKit设计的初衷是管理来源广泛的数据，基于用户喜好把来源不同的数据进行自动合并。应用程序还可以访问每个源的原始数据，并将数据本身合并。App不仅仅用于身体指标的检测、健身或营养情况，还可以用于睡眠分析 那么在接下来的文章里，我会向大家展示在iOS平台上如何利用HealthKit框架去存储、连接睡眠的分析数据。以上的方法也同样适用于watchOS平台上应用。需要注意的是这篇教程使用了Swift2.0和Xcode 7，所以为了接下来的课程，请确保你目前正在使用的Xcode 7 在我们正式开始之前，请提前下载好我们的项目并且解压。我已经创建好了基本的UI界面。当你运行时，你会看到一个计时器的UI界面，当你按下开始按钮之后，就会发现开始计时。 2.使用HealthKit Framework我们App的目标是存储睡眠的分析信息，并通过开始和结束两个按钮检索信息。要使用HealthKit，首先应该在你应用的bundle中打开HealthKit的权限。在你的项目中，在导航中找到当前的target -&gt; 再找到 capabilities，然后打开。 接下来你需要按照以下的代码在ViewController类里创建一个HKHealthStore的实例变量 1let healthStore = HKHealthStore() 然后，我们将利用HKHealthStore这个实例变量去连接HealthKit Store这个加密数据库。 如之前所说，HealthKit允许用户掌握自己的健康数据，所以在你可以操作、分析用户的睡眠数据之前，你首先需要去获取用户许可。获取许可，首先要导入HealthKit Framework，然后如下面一样更新ViewDidLoad中的代码 1234567891011121314151617override func viewDidLoad() &#123; super.viewDidLoad() let typestoRead = Set([ HKObjectType.categoryTypeForIdentifier(HKCategoryTypeIdentifierSleepAnalysis)! ]) let typestoShare = Set([ HKObjectType.categoryTypeForIdentifier(HKCategoryTypeIdentifierSleepAnalysis)! ]) self.healthStore.requestAuthorizationToShareTypes(typestoShare, readTypes: typestoRead) &#123; (success, error) -&gt; Void in if success == false &#123; NSLog(\" Display not allowed\") &#125; &#125;&#125; 以上代码可以提供给用户同意或拒绝的提示，通过block，你可以在处理成功和失败后进行相应的操作并获得最终的结果。没有必要一直向用户请求许可，你必须很好的处理程序中的各种错误 但是为了避免用户的误操作，用户必须在设置页面亲自打开允许按钮，这样才能确保真正获得设备上健康数据的权限 写入睡眠分析数据 首先，如何去检索睡眠分析数据呢？根据苹果官方文档的说法，每一个睡眠分析的样本都有一个唯一值，为了确保用户是躺下并且入睡，HealthKit在同一时间内会对两个或更多的数据进行采样。通过对这些样本的开始时间和结束时间进行对比，应用程序可以进行大量的二次统计和计算。 用户花费多少时间入睡。 用户躺在床上实际入睡时间所占的比例 用户醒来之后，会在床上躺多久 用户在床上，以及睡眠时所花费的时间汇总 简明的讲，把睡眠分析数据储存到HealthKit store数据库中时，你需要遵循以下方法 首先我们需要定义两个NSDate对象去对应开始时间和结束时间。 然后我们利用HKCategoryTypeIdentifierSleepAnalysis创建一个HKObjectType的实例变量 我们需要创建一个全新的HKCategorySample类型的对象，通常采用分类样本的方式来存储睡眠数据，独立的样本代表用户躺在床上或者入睡的时间段。所以我们可以在同一时间段内分别创建出在床上未入睡以及入睡之后的样本 最终，我们就可以利用HKHealthStore类中的saveObject方法把对象存储起来 编者提示：如果想查看样本的类型，可以查阅HealthKit官方文档 如果你把以上的注意点和方法转化到Swift中，以下就是把躺床上未入睡和入睡的分析数据储存起来的代码，请把以下代码插入到ViewController类中 123456789101112131415161718192021222324252627282930313233343536func saveSleepAnalysis() &#123; // alarmTime and endTime are NSDate objects if let sleepType = HKObjectType.categoryTypeForIdentifier(HKCategoryTypeIdentifierSleepAnalysis) &#123; // we create our new object we want to push in Health app let object = HKCategorySample(type:sleepType, value: HKCategoryValueSleepAnalysis.InBed.rawValue, startDate: self.alarmTime, endDate: self.endTime) // at the end, we save it healthStore.saveObject(object, withCompletion: &#123; (success, error) -&gt; Void in if error != nil &#123; // something happened return &#125; if success &#123; print(\"My new data was saved in HealthKit\") &#125; else &#123; // something happened again &#125; &#125;) let object2 = HKCategorySample(type:sleepType, value: HKCategoryValueSleepAnalysis.Asleep.rawValue, startDate: self.alarmTime, endDate: self.endTime) healthStore.saveObject(object2, withCompletion: &#123; (success, error) -&gt; Void in if error != nil &#123; // something happened return &#125; if success &#123; print(\"My new data (2) was saved in HealthKit\") &#125; else &#123; // something happened again &#125; &#125;) &#125; &#125; 这个方法会在我们想把睡眠分析数据存储到HealthKit中时被调用 3.读取睡眠分析数据 想要读取睡眠分析数据，我们需要创建一个查询对象。首先需要为HKCategoryTypeIdentifierSleepAnalysis定义一个HKObjectType类型的分类。或许你希望通过谓词在开始时间和结束时间这个你需要的时间段内进行筛选、检索数据。你也需要为分类检索查询创建 一个分类描述器以获取我们想要的结果 您的用于检索睡眠分析数据的代码应如下所示： 1234567891011121314151617181920212223242526272829303132333435363738func retrieveSleepAnalysis() &#123; // first, we define the object type we want if let sleepType = HKObjectType.categoryTypeForIdentifier(HKCategoryTypeIdentifierSleepAnalysis) &#123; // Use a sortDescriptor to get the recent data first let sortDescriptor = NSSortDescriptor(key: HKSampleSortIdentifierEndDate, ascending: false) // we create our query with a block completion to execute let query = HKSampleQuery(sampleType: sleepType, predicate: nil, limit: 30, sortDescriptors: [sortDescriptor]) &#123; (query, tmpResult, error) -&gt; Void in if error != nil &#123; // something happened return &#125; if let result = tmpResult &#123; // do something with my data for item in result &#123; if let sample = item as? HKCategorySample &#123; let value = (sample.value == HKCategoryValueSleepAnalysis.InBed.rawValue) ? \"InBed\" : \"Asleep\" print(\"Healthkit sleep: \\(sample.startDate) \\(sample.endDate) - value: \\(value)\") &#125; &#125; &#125; &#125; // finally, we execute our query healthStore.executeQuery(query) &#125;&#125; 此代码查询HealthKit以获取所有睡眠分析数据，然后将其按降序排序。 然后使用startDate和endDate以及值的类型（即In Bed或Asleep）打印每个查询。 我已将限制设置为30，以检索最近30个记录的样本。 您还可以使用谓词方法来选择自定义的开始和结束日期。 4.App 测试对于演示应用程序，我使用NSTimer显示自您按下启动按钮以来经过的时间。 NSDate对象在开始和结束按钮上创建，以将睡眠分析数据保存为已用时间。 在停止操作方法中，可以调用saveSleepAnalysis（）和retrieveSleepAnalysis（）方法来保存和获取睡眠数据。 123456@IBAction func stop(sender: AnyObject) &#123; endTime = NSDate() saveSleepAnalysis() retrieveSleepAnalysis() timer.invalidate()&#125; 在您的应用程序中，您可能需要更改NSDate对象以选择相关的开始和结束时间（可能不同），以保存躺在床上的数据和睡眠值。 完成更改后，您可以运行演示应用并启动计时器。让它运行几分钟，然后点击停止按钮。之后打开健康应用程序。你会发现睡眠数据。 5.对使用 HealthKit 应用的一些建议HealthKit旨在为应用开发人员提供一个通用平台，以便轻松共享和访问用户数据，并避免数据中可能的重复或不一致。苹果审查指南非常明确的说明应用程序使用HealthKit和访问用户读/写权限必须通过向用户请求，但没有清楚地阐述HealthKit的使用可能会导致应用程序被拒绝。 将假的或不正确的数据保存到健康的应用程序也将被拒绝。 这意味着，你不能天真地使用算法来计算不同的健康值，如本教程中的睡眠分析。 您应该尝试使用内置的传感器数据读取和操作任何参数，以避免计算假数据。 对于完整的Xcode项目，你可以在这里得到。","content":"<p>原文：<a href=\"\"></a><a href=\"http://appcoda.com/sleep-analysis-healthkit/\" target=\"_blank\" rel=\"external\">http://appcoda.com/sleep-analysis-healthkit/</a></p>\n<p>翻译：Liberalism</p>\n<p>日期：2016年5月3日</p>\n<hr>\n<p>现如今，睡眠变革已经成为了一种全新的潮流。用户比以往任何时候都更加关注自己的睡眠。他们不仅仅关心自己睡了多久，同样也很希望通过一段时间的数据收集和分析能够绘制出他们的睡眠趋势。而技术上的进步，包括硬件、特别是智能手机的高速发展，使睡眠变革这一高速发展的领域迎来了全新的曙光。</p>\n<p>苹果在基于安全的前提下，提供了一种非常酷的方式来与用户的个人健康信息进行通信，并通过iOS内置的<code>健康</code>应用存储信息。作为开发者不仅可以使用<code>HealyhKit</code>来打造健康类的<code>App</code>，同时该框架还允许开发者访问睡眠数据，进行处理分析。</p>\n<p>在本教程中，针对<code>Healthkit</code>框架我会带领大家快速入门，同时会向大家演示如果快速搭建一个简单的睡眠分析的App</p>\n<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h2><blockquote>\n<p><code>HealthKit</code>框架结构提供了一个称之为<code>HealthKit Store</code>的加密数据库，开发者可以使用<code>HKhealth Store</code>这个类来访问这个数据库。iPhone和Apple Watch分别有自己的<code>HealthKit Store</code>，健康数据会在iPhone和Apple Watch之间同步。然而，Apple Watch为了节省内存空间会自动清理掉一些旧的数据。目前<code>healthKit</code>框架和健康类的App在iPad上是不支持的。</p>\n</blockquote>\n<p>如果你想创建一个基于健康数据的iOS App或者是WatchOS App，<code>HealthKit</code>框架无疑是非常强大的一个工具。HealthKit设计的初衷是管理来源广泛的数据，基于用户喜好把来源不同的数据进行自动合并。应用程序还可以访问每个源的原始数据，并将数据本身合并。App不仅仅用于身体指标的检测、健身或营养情况，还可以用于睡眠分析</p>\n<p>那么在接下来的文章里，我会向大家展示在iOS平台上如何利用<code>HealthKit</code>框架去存储、连接睡眠的分析数据。以上的方法也同样适用于watchOS平台上应用。需要注意的是这篇教程使用了Swift2.0和Xcode 7，所以为了接下来的课程，请确保你目前正在使用的Xcode 7</p>\n<p>在我们正式开始之前，请提前下载好我们的项目并且解压。我已经创建好了基本的UI界面。当你运行时，你会看到一个计时器的UI界面，当你按下开始按钮之后，就会发现开始计时。</p>\n<a id=\"more\"></a>\n<h2 id=\"2-使用HealthKit-Framework\"><a href=\"#2-使用HealthKit-Framework\" class=\"headerlink\" title=\"2.使用HealthKit Framework\"></a>2.使用HealthKit Framework</h2><p>我们App的目标是存储睡眠的分析信息，并通过开始和结束两个按钮检索信息。要使用<code>HealthKit</code>，首先应该在你应用的bundle中打开<code>HealthKit</code>的权限。在你的项目中，在导航中找到当前的target -&gt; 再找到 capabilities，然后打开。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/translate/image/Healthkit-01.png?watermark/2/text/QExpYmVyYWxpc20=/font/5a6L5L2T/fontsize/800/fill/IzhBMTgxOA==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" alt=\"\"></p>\n<p>接下来你需要按照以下的代码在ViewController类里创建一个HKHealthStore的实例变量</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> healthStore = <span class=\"type\">HKHealthStore</span>()</div></pre></td></tr></table></figure>\n<p>然后，我们将利用<code>HKHealthStore</code>这个实例变量去连接<code>HealthKit Store</code>这个加密数据库。</p>\n<p>如之前所说，<code>HealthKit</code>允许用户掌握自己的健康数据，所以在你可以操作、分析用户的睡眠数据之前，你首先需要去获取用户许可。获取许可，首先要导入HealthKit Framework，然后如下面一样更新<code>ViewDidLoad</code>中的代码</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.viewDidLoad()</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">let</span> typestoRead = <span class=\"type\">Set</span>([</div><div class=\"line\">        <span class=\"type\">HKObjectType</span>.categoryTypeForIdentifier(<span class=\"type\">HKCategoryTypeIdentifierSleepAnalysis</span>)!</div><div class=\"line\">        ])</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">let</span> typestoShare = <span class=\"type\">Set</span>([</div><div class=\"line\">        <span class=\"type\">HKObjectType</span>.categoryTypeForIdentifier(<span class=\"type\">HKCategoryTypeIdentifierSleepAnalysis</span>)!</div><div class=\"line\">        ])</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">self</span>.healthStore.requestAuthorizationToShareTypes(typestoShare, readTypes: typestoRead) &#123; (success, error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></div><div class=\"line\">        <span class=\"keyword\">if</span> success == <span class=\"literal\">false</span> &#123;</div><div class=\"line\">            <span class=\"type\">NSLog</span>(<span class=\"string\">\" Display not allowed\"</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上代码可以提供给用户<code>同意</code>或<code>拒绝</code>的提示，通过<code>block</code>，你可以在处理成功和失败后进行相应的操作并获得最终的结果。没有必要一直向用户请求许可，你必须很好的处理程序中的各种错误</p>\n<p>但是为了避免用户的误操作，用户必须在设置页面亲自打开允许按钮，这样才能确保真正获得设备上健康数据的权限</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/translate/image/Healthkit-02.png?watermark/2/text/QExpYmVyYWxpc20=/font/5a6L5L2T/fontsize/800/fill/IzhBMTgxOA==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" alt=\"\"></p>\n<p>写入睡眠分析数据</p>\n<p>首先，如何去检索睡眠分析数据呢？根据苹果官方文档的说法，每一个睡眠分析的样本都有一个唯一值，为了确保用户是躺下并且入睡，HealthKit在同一时间内会对两个或更多的数据进行采样。通过对这些样本的开始时间和结束时间进行对比，应用程序可以进行大量的二次统计和计算。</p>\n<ul>\n<li>用户花费多少时间入睡。</li>\n<li>用户躺在床上实际入睡时间所占的比例</li>\n<li>用户醒来之后，会在床上躺多久</li>\n<li>用户在床上，以及睡眠时所花费的时间汇总<br><img src=\"http://okhqmtd8q.bkt.clouddn.com/translate/image/Healthkit-03.png?watermark/2/text/QExpYmVyYWxpc20=/font/5a6L5L2T/fontsize/800/fill/IzhBMTgxOA==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" alt=\"\"></li>\n</ul>\n<p>简明的讲，把睡眠分析数据储存到HealthKit store数据库中时，你需要遵循以下方法</p>\n<hr>\n<ul>\n<li>首先我们需要定义两个NSDate对象去对应开始时间和结束时间。</li>\n</ul>\n<ul>\n<li>然后我们利用<code>HKCategoryTypeIdentifierSleepAnalysis</code>创建一个<code>HKObjectType</code>的实例变量</li>\n</ul>\n<ul>\n<li>我们需要创建一个全新的<code>HKCategorySample</code>类型的对象，通常采用分类样本的方式来存储睡眠数据，独立的样本代表用户躺在床上或者入睡的时间段。所以我们可以在同一时间段内分别创建出<code>在床上未入睡</code>以及<code>入睡之后</code>的样本</li>\n</ul>\n<ul>\n<li>最终，我们就可以利用<code>HKHealthStore</code>类中的<code>saveObject</code>方法把对象存储起来</li>\n</ul>\n<hr>\n<blockquote>\n<p>编者提示：如果想查看样本的类型，可以查阅<br><a href=\"https://developer.apple.com/reference/healthkit/healthkit_constants#//apple_ref/doc/uid/TP40014710\" target=\"_blank\" rel=\"external\"><code>HealthKit</code>官方文档</a></p>\n</blockquote>\n<hr>\n<p>如果你把以上的注意点和方法转化到Swift中，以下就是把<code>躺床上未入睡</code>和<code>入睡</code>的分析数据储存起来的代码，请把以下代码插入到<code>ViewController</code>类中</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">saveSleepAnalysis</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// alarmTime and endTime are NSDate objects</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> sleepType = <span class=\"type\">HKObjectType</span>.categoryTypeForIdentifier(<span class=\"type\">HKCategoryTypeIdentifierSleepAnalysis</span>) &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// we create our new object we want to push in Health app</span></div><div class=\"line\">        <span class=\"keyword\">let</span> object = <span class=\"type\">HKCategorySample</span>(type:sleepType, value: <span class=\"type\">HKCategoryValueSleepAnalysis</span>.<span class=\"type\">InBed</span>.rawValue, startDate: <span class=\"keyword\">self</span>.alarmTime, endDate: <span class=\"keyword\">self</span>.endTime)</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// at the end, we save it</span></div><div class=\"line\">        healthStore.saveObject(object, withCompletion: &#123; (success, error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">if</span> error != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// something happened</span></div><div class=\"line\">                <span class=\"keyword\">return</span></div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> success &#123;</div><div class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"My new data was saved in HealthKit\"</span>)    </div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// something happened again</span></div><div class=\"line\">            &#125;     </div><div class=\"line\">        &#125;)</div><div class=\"line\">        <span class=\"keyword\">let</span> object2 = <span class=\"type\">HKCategorySample</span>(type:sleepType, value: <span class=\"type\">HKCategoryValueSleepAnalysis</span>.<span class=\"type\">Asleep</span>.rawValue, startDate: <span class=\"keyword\">self</span>.alarmTime, endDate: <span class=\"keyword\">self</span>.endTime)</div><div class=\"line\">        </div><div class=\"line\">        healthStore.saveObject(object2, withCompletion: &#123; (success, error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></div><div class=\"line\">            <span class=\"keyword\">if</span> error != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// something happened</span></div><div class=\"line\">                <span class=\"keyword\">return</span></div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> success &#123;</div><div class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"My new data (2) was saved in HealthKit\"</span>)</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// something happened again</span></div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;)   </div><div class=\"line\">    &#125;   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法会在我们想把睡眠分析数据存储到<code>HealthKit</code>中时被调用</p>\n<h2 id=\"3-读取睡眠分析数据\"><a href=\"#3-读取睡眠分析数据\" class=\"headerlink\" title=\"3.读取睡眠分析数据\"></a>3.读取睡眠分析数据</h2><ul>\n<li>想要读取睡眠分析数据，我们需要创建一个查询对象。首先需要为<code>HKCategoryTypeIdentifierSleepAnalysis</code>定义一个<code>HKObjectType</code>类型的分类。或许你希望通过谓词在开始时间和结束时间这个你需要的时间段内进行筛选、检索数据。你也需要为分类检索查询创建 一个分类描述器以获取我们想要的结果</li>\n</ul>\n<p>您的用于检索睡眠分析数据的代码应如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">retrieveSleepAnalysis</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// first, we define the object type we want</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> sleepType = <span class=\"type\">HKObjectType</span>.categoryTypeForIdentifier(<span class=\"type\">HKCategoryTypeIdentifierSleepAnalysis</span>) &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// Use a sortDescriptor to get the recent data first</span></div><div class=\"line\">        <span class=\"keyword\">let</span> sortDescriptor = <span class=\"type\">NSSortDescriptor</span>(key: <span class=\"type\">HKSampleSortIdentifierEndDate</span>, ascending: <span class=\"literal\">false</span>)</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// we create our query with a block completion to execute</span></div><div class=\"line\">        <span class=\"keyword\">let</span> query = <span class=\"type\">HKSampleQuery</span>(sampleType: sleepType, predicate: <span class=\"literal\">nil</span>, limit: <span class=\"number\">30</span>, sortDescriptors: [sortDescriptor]) &#123; (query, tmpResult, error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">if</span> error != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">                </div><div class=\"line\">                <span class=\"comment\">// something happened</span></div><div class=\"line\">                <span class=\"keyword\">return</span></div><div class=\"line\">                </div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> result = tmpResult &#123;</div><div class=\"line\">                </div><div class=\"line\">                <span class=\"comment\">// do something with my data</span></div><div class=\"line\">                <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> result &#123;</div><div class=\"line\">                </div><div class=\"line\">                    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> sample = item <span class=\"keyword\">as</span>? <span class=\"type\">HKCategorySample</span> &#123;</div><div class=\"line\">                    </div><div class=\"line\">                        <span class=\"keyword\">let</span> value = (sample.value == <span class=\"type\">HKCategoryValueSleepAnalysis</span>.<span class=\"type\">InBed</span>.rawValue) ? <span class=\"string\">\"InBed\"</span> : <span class=\"string\">\"Asleep\"</span></div><div class=\"line\">                        </div><div class=\"line\">                        <span class=\"built_in\">print</span>(<span class=\"string\">\"Healthkit sleep: \\(sample.startDate) \\(sample.endDate) - value: \\(value)\"</span>)</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// finally, we execute our query</span></div><div class=\"line\">        healthStore.executeQuery(query)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>此代码查询<code>HealthKit</code>以获取所有睡眠分析数据，然后将其按降序排序。 然后使用<code>startDate</code>和<code>endDate</code>以及值的类型（即In Bed或Asleep）打印每个查询。 我已将限制设置为30，以检索最近30个记录的样本。 您还可以使用谓词方法来选择自定义的开始和结束日期。</p>\n<h2 id=\"4-App-测试\"><a href=\"#4-App-测试\" class=\"headerlink\" title=\"4.App 测试\"></a>4.App 测试</h2><p>对于演示应用程序，我使用<code>NSTimer</code>显示自您按下启动按钮以来经过的时间。 <code>NSDate</code>对象在开始和结束按钮上创建，以将睡眠分析数据保存为已用时间。 在停止操作方法中，可以调用<code>saveSleepAnalysis（）</code>和<code>retrieveSleepAnalysis（）</code>方法来保存和获取睡眠数据。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stop</span><span class=\"params\">(sender: AnyObject)</span></span> &#123;</div><div class=\"line\">    endTime = <span class=\"type\">NSDate</span>()</div><div class=\"line\">    saveSleepAnalysis()</div><div class=\"line\">    retrieveSleepAnalysis()</div><div class=\"line\">    timer.invalidate()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在您的应用程序中，您可能需要更改<code>NSDate</code>对象以选择相关的开始和结束时间（可能不同），以保存躺在床上的数据和睡眠值。</p>\n<p>完成更改后，您可以运行演示应用并启动计时器。让它运行几分钟，然后点击停止按钮。之后打开<code>健康</code>应用程序。你会发现睡眠数据。</p>\n<p><img src=\"http://okhqmtd8q.bkt.clouddn.com/translate/image/Healthkit-04.png?watermark/2/text/QExpYmVyYWxpc20=/font/5a6L5L2T/fontsize/800/fill/IzhBMTgxOA==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" alt=\"\"></p>\n<h2 id=\"5-对使用-HealthKit-应用的一些建议\"><a href=\"#5-对使用-HealthKit-应用的一些建议\" class=\"headerlink\" title=\"5.对使用 HealthKit 应用的一些建议\"></a>5.对使用 <code>HealthKit</code> 应用的一些建议</h2><p><code>HealthKit</code>旨在为应用开发人员提供一个通用平台，以便轻松共享和访问用户数据，并避免数据中可能的重复或不一致。苹果审查指南非常明确的说明应用程序使用<code>HealthKit</code>和访问用户<code>读/写权限</code>必须通过向用户请求，但没有清楚地阐述<code>HealthKit</code>的使用可能会导致应用程序被拒绝。</p>\n<p>将假的或不正确的数据保存到<code>健康</code>的应用程序也将被拒绝。 这意味着，你不能天真地使用算法来计算不同的健康值，如本教程中的睡眠分析。 您应该尝试使用内置的传感器数据读取和操作任何参数，以避免计算假数据。</p>\n<p>对于完整的Xcode项目，你可以在这里<a href=\"https://github.com/appcoda/SleepAnalysis\" target=\"_blank\" rel=\"external\">得到</a>。</p>\n","excerpt":"原文：http://appcoda.com/sleep-analysis-healthkit/ 翻译：Liberalism 日期：2016年5月3日 现如今，睡眠变革已经成为了一种全新的潮流。用户比以往任何时候都更加关注自己的睡眠。他们不仅仅关心自己睡了多久，同样也很希望通过一段时间的数据收集和分析能够绘制出他们的睡眠趋势。而技术上的进步，包括硬件、特别是智能手机的高速发展，使睡眠变革这一高速发展的领域迎来了全新的曙光。 苹果在基于安全的前提下，提供了一种非常酷的方式来与用户的个人健康信息进行通信，并通过iOS内置的健康应用存储信息。作为开发者不仅可以使用HealyhKit来打造健康类的App，同时该框架还允许开发者访问睡眠数据，进行处理分析。 在本教程中，针对Healthkit框架我会带领大家快速入门，同时会向大家演示如果快速搭建一个简单的睡眠分析的App 1.简介 HealthKit框架结构提供了一个称之为HealthKit Store的加密数据库，开发者可以使用HKhealth Store这个类来访问这个数据库。iPhone和Apple Watch分别有自己的HealthKit Store，健康数据会在iPhone和Apple Watch之间同步。然而，Apple Watch为了节省内存空间会自动清理掉一些旧的数据。目前healthKit框架和健康类的App在iPad上是不支持的。 如果你想创建一个基于健康数据的iOS App或者是WatchOS App，HealthKit框架无疑是非常强大的一个工具。HealthKit设计的初衷是管理来源广泛的数据，基于用户喜好把来源不同的数据进行自动合并。应用程序还可以访问每个源的原始数据，并将数据本身合并。App不仅仅用于身体指标的检测、健身或营养情况，还可以用于睡眠分析 那么在接下来的文章里，我会向大家展示在iOS平台上如何利用HealthKit框架去存储、连接睡眠的分析数据。以上的方法也同样适用于watchOS平台上应用。需要注意的是这篇教程使用了Swift2.0和Xcode 7，所以为了接下来的课程，请确保你目前正在使用的Xcode 7 在我们正式开始之前，请提前下载好我们的项目并且解压。我已经创建好了基本的UI界面。当你运行时，你会看到一个计时器的UI界面，当你按下开始按钮之后，就会发现开始计时。","categories":[],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://yoursite.com/tags/翻译/"}]}]