[{"title":"总结-iOS Summary Part1","date":"2017-03-07T08:57:09.000Z","path":"2017/03/07/总结-iOS Summary Part1/","text":"文章大纲，便于浏览 01-iOS程序启动过程 i.完整启动过程 ii.程序启动原理 02-浅拷贝-深拷贝 i. 系统对象的 copy/mutableCopy ii.自定义对象实现 Copy-MutableCopy iii.copy 本质 03-View的生命周期 04-@property 05-事件传递和事件响应 06-KVC 01-iOS-App-startup-process###一、启动完整过程 1.main函数 2.UIApplicationMain函数 创建UIApplication对象 创建UIApplication的delegate对象 3.delegate对象开始处理(监听)系统事件(没有storyboard) 程序启动完毕的时候, 就会调用代理的:didFinishLaunchingWithOptions:方法 在application:didFinishLaunchingWithOptions:中创建UIWindow 创建和设置UIWindow的rootViewController 显示窗口 4.根据Info.plist获得最主要storyboard的文件名,加载最主要的storyboard(有storyboard) 创建UIWindow 创建和设置UIWindow的rootViewController 显示窗口 ###二、程序启动原理 1.main函数中执行了一个UIApplicationMain这个函数 123int UIApplicationMain(int argc, char *argv[], NSString *principalClassName, NSString *delegateClassName);argc、argv：直接传递给UIApplicationMain进行相关处理即可 2.principalClassName：指定应用程序类名（app的象征），该类必须是UIApplication(或子类)。如果为nil,则用UIApplication类作为默认值 3.delegateClassName：指定应用程序的代理类，该类必须遵守UIApplicationDelegate协议 4.UIApplicationMain函数会根据principalClassName创建UIApplication对象，根据delegateClassName创建一个delegate对象，并将该delegate对象赋值给UIApplication对象中的delegate属性 5.接着会建立应用程序的Main Runloop（事件循环），进行事件的处理(首先会在程序完毕后调用delegate对象的application:didFinishLaunchingWithOptions:方法) 程序正常退出时UIApplicationMain函数才返回 1234567891011int main(int argc, char * argv[])&#123; @autoreleasepool &#123; /*** argc: 系统或者用户传入的参数个数* argv: 系统或者用户传入的实际参数 * 1.根据传入的第三个参数创建UIApplication对象 * 2.根据传入的第四个产生创建UIApplication对象的代理* 3.设置刚刚创建出来的代理对象为UIApplication的代理 * 4.开启一个事件循环 **/ return UIApplicationMain(argc, argv, @\"UIApplication\", @\"YYAppDelegate\"); &#125;&#125; 启动与代理： 02-ShallowCopy-DeepCopy简要总结一下什么是浅拷贝，什么是深拷贝 深拷贝就是内容拷贝 浅拷贝就是指针拷贝 ###一.系统对象的 copy/mutableCopy 1234567891011121314151617NSString *string = @\"LiMing\"; NSString *copyString = [string copy]; NSString *mutableString = [string mutableCopy]; NSLog(@\"string = %p\",string); NSLog(@\"copyString = %p\",copyString); NSLog(@\"mutableString = %p \",mutableString);结论：1.string 和 copyString 他们只是二个不同的指针，指向内存中的同一块地址，copy 只是指针复制2.string 和 mutableString 打印出来的地址不同，是因为两个指针指向的地址本就不同，mutableCopy 是内容复制注意：其他对象 NSArray 、NSMutableArray 、NSDictionary 、NSMutableDictionary 一样适用 规律可以从这张图看出来 ###二.自定义对象实现 Copy-MutableCopy copy 1234GZQPerson *person = [[GZQPerson alloc] init];person.age = 20;person.name = @\"GZQ\";GZQPerson *copyP = [person copy]; // 这里崩溃 崩溃： 看崩溃信息GZQPerson应该先实现： 1- (id)copyWithZone:(NSZone *)zone; 测试： 12345678910111213141516171819202122232425#import \"GZQPerson.h\"@interface GZQPerson ()&lt;NSCopying,NSMutableCopying&gt;@end@implementation GZQPerson- (id)copyWithZone:(NSZone *)zone &#123; GZQPerson *person = [[[self class] allocWithZone:zone] init]; person.age = self.age; person.name = self.name; return person;&#125;- (id)mutableCopyWithZone:(NSZone *)zone &#123; GZQPerson *person = [[[self class] allocWithZone:zone] init]; person.age = self.age; person.name = self.name; return person;&#125;@end 12345678910111213141516171819202122232425#import \"ViewController.h\"#import \"GZQPerson.h\"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; GZQPerson *person = [[GZQPerson alloc] init]; person.age = 20; person.name = @\"GZQ\"; GZQPerson *copyP = [person copy]; NSLog(@\"copyP=%p\",copyP); NSLog(@\"person=%p\",person); NSLog(@\"person=%p\",copyP.name); NSLog(@\"person=%p\",person.name); &#125;@end 可以看出虽然指针的地址不同，但是存储的地址是一致的。 ###三.copy 本质 property copy 实际上就对name干了这个： 12345678#import &lt;Foundation/Foundation.h&gt;property copy 实际上就对name干了这个：- (void)setName:(NSString *)name&#123; _name = [name copy];&#125; strong是不执行Copy操作的 1234567891011@property (nonatomic, strong) NSString *name;NSMutableString *string = [NSMutableString stringWithFormat:@\"深拷贝-浅拷贝\"];GZQPerson *person = [[GZQPerson alloc] init];person.name = string;// 可以改变person.name的值，因为其内部没有生成新的对象[string appendString:@\"LALALA\"];NSLog(@\"name = %@\", person.name); 03-View的生命周期 读懂这一张图即可 04-@property @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的 @property 的本质. 1@property = ivar + getter + setter; 下面解释下： “属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。 “属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示: 编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说： 1@property = getter + setter; 例如下面这个类： 1234@interface Person : NSObject@property NSString *firstName;@property NSString *lastName;@end 上述代码写出来的类与下面这种写法等效： 123456@interface Person : NSObject- (NSString *)firstName;- (void)setFirstName:(NSString *)firstName;- (NSString *)lastName;- (void)setLastName:(NSString *)lastName;@end property在runtime中是objc_property_t定义如下: 1typedef struct objc_property *objc_property_t; 而objc_property是一个结构体，包括name和attributes，定义如下： 1234struct property_t &#123; const char *name; const char *attributes;&#125;; 而attributes本质是objc_property_attribute_t，定义了property的一些属性，定义如下： 12345/// Defines a property attributetypedef struct &#123; const char *name; /**&lt; The name of the attribute */ const char *value; /**&lt; The value of the attribute (usually empty) */&#125; objc_property_attribute_t; 而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。 例如：我们定义一个string的property 1@property (nonatomic, copy) NSString *string; 通过 property_getAttributes(property)获取到attributes并打印出来之后的结果为 1T@\"NSString\",C,N,V_string 其中T就代表类型，可参阅Type Encodings，C就代表Copy，N代表nonatomic，V就代表对于的实例变量。 ivar、getter、setter 是如何生成并添加到这个类中的? “自动合成”( autosynthesis) 完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过@synthesize 语法来指定实例变量的名字. 1234@implementation Person@synthesize firstName = _myFirstName;@synthesize lastName = _myLastName;@end 我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西 1234561. OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。2. setter 与 getter 方法对应的实现函数3. ivar_list ：成员变量列表4. method_list ：方法列表5. prop_list ：属性列表也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转. 属性可以拥有的特质分为四类: 原子性— nonatomic 特质,在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。 读/写权限—readwrite(读写)、readonly (只读) 内存管理语义—assign、strong、 weak、unsafe_unretained、copy 方法名—getter= 、setter= getter=的样式： 123@property (nonatomic, getter=isOn) BOOL on; (`setter=`这种不常用，也不推荐使用。故不在这里给出写法。） setter=一般用在特殊的情境下，比如： 在数据反序列化、转模型的过程中，服务器返回的字段如果以 init 开头，所以你需要定义一个 init 开头的属性，但默认生成的 setter 与 getter 方法也会以 init 开头，而编译器会把所有以 init 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。 这时你就可以使用下面的方式来避免编译器报错： 1@property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:)NSString *initBy; 另外也可以用关键字进行特殊说明，来避免编译器报错： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@property(nonatomic, readwrite, copy, null_resettable) NSString *initBy;- (NSString *)initBy __attribute__((objc_method_family(none)));1. 不常用的：nonnull,null_resettable,nullable注意：很多人会认为如果属性具备 nonatomic 特质，则不使用 “同步锁”。其实在属性设置方法中使用的是自旋锁，自旋锁相关代码如下：static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)&#123; if (offset == 0) &#123; object_setClass(self, newValue); return; &#125; id oldValue; id *slot = (id*) ((char*)self + offset); if (copy) &#123; newValue = [newValue copyWithZone:nil]; &#125; else if (mutableCopy) &#123; newValue = [newValue mutableCopyWithZone:nil]; &#125; else &#123; if (*slot == newValue) return; newValue = objc_retain(newValue); &#125; if (!atomic) &#123; oldValue = *slot; *slot = newValue; &#125; else &#123; spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); &#125; objc_release(oldValue);&#125;void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) &#123; bool copy = (shouldCopy &amp;&amp; shouldCopy != MUTABLE_COPY); bool mutableCopy = (shouldCopy == MUTABLE_COPY); reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);&#125; 05-事件传递和事件响应这部分知识如果自己总结，篇幅较长。可以参考以下文章 06-KVCKey-Value Coding (KVC) KVC（Key-value coding）键值编码，单看这个名字可能不太好理解。其实翻译一下就很简单了，就是指iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值。而不需要调用明确的存取方法。这样就可以在运行时动态在访问和修改对象的属性。而不是在编译时确定，这也是iOS开发中的黑魔法之一。很多高级的iOS开发技巧都是基于KVC实现的。目前网上关于KVC的文章在非常多，有的只是简单地说了下用法，有的讲得深入但是在使用场景和最佳实践没有说明，我写下这遍文章就是给大家详解一个最完整最详细的KVC。 KVC在iOS中的定义 无论是Swift还是Objective-C，KVC的定义都是对NSObject的扩展来实现的(Objective-C中有个显式的NSKeyValueCoding类别名，而Swift没有，也不需要)所以对于所有继承了NSObject在类型，都能使用KVC(一些纯Swift类和结构体是不支持KVC的)，下面是KVC最为重要的四个方法 1234- (nullable id)valueForKey:(NSString *)key; //直接通过Key来取值- (void)setValue:(nullable id)value forKey:(NSString *)key; //通过Key来设值- (nullable id)valueForKeyPath:(NSString *)keyPath; //通过KeyPath来取值- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; //通过KeyPath来设值 当然NSKeyValueCoding类别中还有其他的一些方法，下面列举一些 1234567891011121314+ (BOOL)accessInstanceVariablesDirectly;//默认返回YES，表示如果没有找到Set&lt;Key&gt;方法的话，会按照_key，_iskey，key，iskey的顺序搜索成员，设置成NO就不这样搜索- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;//KVC提供属性值确认的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;//这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回- (nullable id)valueForUndefinedKey:(NSString *)key;//如果Key不存在，且没有KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;//和上一个方法一样，只不过是设值。- (void)setNilValueForKey:(NSString *)key;//如果你在SetValue方法时面给Value传nil，则会调用这个方法- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;//输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。 上面的这些方法在碰到特殊情况或者有特殊需求还是会用到的，所以也是可以了解一下。后面的代码示例会有讲到其中的一些方法。同时苹果对一些容器类比如NSArray或者NSSet等，KVC有着特殊的实现。建议有基础的或者英文好的开发者直接去看苹果的官方文档，相信你会对KVC的理解更上一个台阶。 KVC是怎么寻找Key的 KVC是怎么使用的，我相信绝大多数的开发者都很清楚，我在这里就不再写简单的使用KVC来设值和取值的代码了，首页我们来探讨KVC在内部是按什么样的顺序来寻找key的。当调用setValue：属性值 forKey：``@”name“的代码时，底层的执行机制如下： 程序优先调用set&lt;Key&gt;:属性值方法，代码通过setter方法完成设置。注意，这里的&lt;key&gt;是指成员变量名，首字母大清写要符合KVC的全名规则，下同 如果没有找到setName：方法，KVC机制会检查+ (BOOL)accessInstanceVariablesDirectly方法有没有返回YES，默认该方法会返回YES，如果你重写了该方法让其返回NO的话，那么在这一步KVC会执行setValue：forUNdefinedKey：方法，不过一般开发者不会这么做。所以KVC机制会搜索该类里面有没有名为_&lt;key&gt;的成员变量，无论该变量是在类接口部分定义，还是在类实现部分定义，也无论用了什么样的访问修饰符，只在存在以_&lt;key&gt;命名的变量，KVC都可以对该成员变量赋值。 如果该类即没有set&lt;Key&gt;：方法，也没有_&lt;key&gt;成员变量，KVC机制会搜索_is&lt;Key&gt;的成员变量， 和上面一样，如果该类即没有set&lt;Key&gt;：方法，也没有_&lt;key&gt;和_is&lt;Key&gt;成员变量，KVC机制再会继续搜索&lt;key&gt;和is&lt;Key&gt;的成员变量。再给它们赋值。 如果上面列出的方法或者成员变量都不存在，系统将会执行该对象的setValue：forUNdefinedKey：方法，默认是抛出异常。 如果开发者想让这个类禁用KVC里，那么重写+ (BOOL)accessInstanceVariablesDirectly方法让其返回NO即可，这样的话如果KVC没有找到set&lt;Key&gt;:属性名时，会直接用setValue：forUNdefinedKey：方法。","tags":[]},{"title":"序列化和反序列化","date":"2017-03-06T00:39:37.000Z","path":"2017/03/06/序列化和反序列化/","text":"定义以及相关概念互联网的产生带来了机器间通讯的需求，而互联通讯的双方需要采用约定的协议，序列化和反序列化属于通讯协议的一部分。通讯协议往往采用分层模型，不同模型每层的功能定义以及颗粒度不同，例如：TCP/IP协议是一个四层协议，而OSI模型却是七层协议模型。在OSI七层协议模型中 展现层（Presentation Layer）的主要功能是把应用层的对象转换成一段连续的二进制串，或者反过来，把二进制串转换成应用层的对象–这两个功能就是序列化和反序列化。一般而言，TCP/IP协议的应用层对应与OSI七层协议模型的应用层，展示层和会话层，所以序列化协议属于TCP/IP协议应用层的一部分。本文对序列化协议的讲解主要基于OSI七层协议模型。 序列化(Serialization)： 将数据结构或对象转换成二进制串的过程。在iOS中称为归档(Archive)反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。 不同的计算机语言中，数据结构，对象以及二进制串的表示方式并不相同。 数据结构和对象：对于类似Java这种完全面向对象的语言，工程师所操作的一切都是对象（Object），来自于类的实例化。在Java语言中最接近数据结构的概念，就是POJO（Plain Old Java Object）或者Javabean－－那些只有setter/getter方法的类。而C二进制串：序列化所生成的二进制串指的是存储在内存中的一块数据。C语言的字符串可以直接被传输层使用，因为其本质上就是以’0’结尾的存储在内存中的二进制串。在Java语言里面，二进制串的概念容易和String混淆。实际上String是Java的一等公民，是一种特殊对象（Object）。对于跨语言间的通讯，序列化后的数据当然不能是某种语言的特殊数据类型。,在iOS中对象转为NSData类型，就是序列化之后的，而NSData转为其他类型对象就是反序列化。 在iOS中序列化与反序列化 将任何对象转NSData，这个对象都需要遵循一个协议，就是NSCoding协议。代码如下： 1234567 //每个属性变量分别转码，序列化- (void)encodeWithCoder:(NSCoder *)aCoder &#123; [aCoder encodeObject:self.FYusername forKey:@\"username\"]; [aCoder encodeObject:self.FriendlyName forKey:@\"FriendlyName\"]; [aCoder encodeObject:self.phoneNum forKey:@\"phoneNum\"];&#125; 1234567891011//分别把每个属性变量根据关键字进行逆转码，最后返回一个Student类的对象,反序列化- (id)initWithCoder:(NSCoder *)aDecoder&#123; if (self = [super init]) &#123; self.FYusername = [aDecoder decodeObjectForKey:@\"username\"]; self.FriendlyName= [aDecoder decodeObjectForKey:@\"FriendlyName\"]; self.phoneNum= [aDecoder decodeObjectForKey:@\"phoneNum\"]; &#125; return self;&#125; 对象在实现NSCoding协议后，在外面使用这个对象的时候可以通过归档函数来转成NSData: 1234// 归档调动，序列化NSData *contactsData=[NSKeyedArchiver archivedDataWithRootObject:ContactsArray]; //反序列化，转变为对象NSObject&lt;NSCoding&gt; *obj=[NSKeyedUnarchiver unarchiveObjectWithFile:path]; 其中的NSCoder是一个编码的工具性类，封装了对象序列化和反序列化的函数，所以实际上，我们并没有自己写序列化算法，只是遵循了这个协议让系统去调用罢了。 iOS利用序列化和反序列化的作用实现NSCoding的类，并序列化数据，有2个好处：1.序列化数据可以直接进行存储2.序列化数据容易进行完全拷贝 序列化数据可以直接进行存储在iOS中，进行存储比较快捷的方式是NSUserDefaults，存储方式如下：但它支持的数据类型很有限：NSNumber（NSInteger、float、double），NSString，NSData，NSArray，NSDictionary，BOOL. 12[[NSUserDefaults standardUserDefaults] setObject:nickName forKey:UserDefault_NickName];[[NSUserDefaults standardUserDefaults] synchronize]; 一般都是些不可变的基本类型，存储其他类型时，如NSMutableArray等类型时，会崩溃的。解决办法如下： 1234//当然，不能忽略的是，如果是自定义对象，别忘了NSCoding协议。NSData *contactsData=[NSKeyedArchiver archivedDataWithRootObject:ContactsArray];[[NSUserDefaults standardUserDefaults] setObject:contactsData forKey:UserDefault_ContactsArray];[[NSUserDefaults standardUserDefaults] synchronize]; 除了NSUserDefaults，另外存储NSData的方式可以用归档+地址： 1[NSKeyedArchiver archiveRootObject:obj toFile:path]; 序列化数据容易进行完全拷贝：这里简单说下使用NSKeyedArchiver来实现深拷贝：主要的方法是先将某个对象转NSData,然后NSData转回赋值给新建对象： 12NSData *data = [NSKeyedArchiver archivedDataWithRootObject:oldContactsArray];NSMutableArray *newContactsArray = [NSKeyedUnarchiver unarchiveObjectWithData:data];","tags":[]},{"title":"源码解析-SDWebImage","date":"2017-02-21T04:48:01.000Z","path":"2017/02/21/源码解析-SDWebImage/","text":"SDWebImage是我们经常使用的一个异步图片加载库，大大提高了我们的开发效率。它支持从网络中下载且缓存图片，并设置图片到对应的UIImageView控件或者UIButton控件上。 SDWebImage 概论123456789101.提供了一个UIImageView的category用来加载网络图片并且对网络图片的缓存进行管理2.采用异步方式来下载网络图片3.采用异步方式，使用memory＋disk来缓存网络图片，自动管理缓存。4.支持GIF动画,支持JEPG,JPG格式。5.支持WebP格式6.同一个URL的网络图片不会被重复下载7.失效的URL不会被无限重试8.耗时操作都在子线程，确保不会阻塞主线程9.使用GCD和ARC10.支持Arm64 ##SDWebImage知识点的梳理 正常程序退出后，会在几秒内停止工作,要想申请更长的时间，需要用到beginBackgroundTaskWithExpirationHandler endBackgroundTask一定要成对出现 使用NSdirectoryEnumerator遍历所有的缓存文件不会有性能耗时的问题,检查某个文件是否存在或者检查是否为文件夹都会检查文件的inode 数据,而这个inode中包括file的各种attribute. 使用NSCache作为内存储存比NSDictionary的好处是:当系统资源要耗尽的时候可以自动的删减,NSCache不会自动的拷贝键,并且是线程安全的,比NSDictionary线程安全. 线程中urlCallbacks的增加,改动都是使用所有增改回调集合URLCallbacks的操作使用dispatch_barrier_sync放入队列barrierQueue中，而查询URLCallbakcs的操作只需使用dispatch_sync放入队列barrierQueue中。 要先说一些系统中锁的问题: 同步锁@synchronized(self)在self上加一个同步锁,频繁滥用的话会导致程序会等待另外一段与此代码无关的执行完毕之后才能执行,会耗时. 123[_lock lock];//[_lock unlock]; 这样遇到死锁也会很麻烦,并且效率也不高.一般情况下想要为代码加锁,最好使用CGD.将所有的操作放到串行队列中执行.而对于并行队列的话就需要,读取的话可以并发进行,并没有任何改动,而增加或者修改数据的话必须保证此时不能进行读取数据,那么可以使用栅栏(barrier)来设置.在队列中栅栏块必须单独执行,不能与其他一起执行.这对于并发队列来说,如果并发队列发下下面要处理的是栅栏块,那么会一直等前面所有的并发块执行完毕后才执行这个栅栏,而等栅栏执行完毕后才执行其后的并发任务.所以增加和修改使用栅栏可以保证线程安全. 5.图片的解码.当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。SDWebImage就是在后台生成这种位图. SDWebImageManager结构关于结构，我们可以用一张流程图说明 SDWebImage的工作流程 SDWebImageManager主要管理的类,下载的主要方法就是在这个类中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; // 断言一下完成这个回调如果是预先下载这个类进行压在 NSAssert(completedBlock != nil, @\"If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead\"); // 判断一下url是否是正确的url if ([url isKindOfClass:NSString.class]) &#123; url = [NSURL URLWithString:(NSString *)url]; &#125; if (![url isKindOfClass:NSURL.class]) &#123; url = nil; &#125; // 对于operation再次包装一层,对应一个operation __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new]; __weak SDWebImageCombinedOperation *weakOperation = operation; // 判断一下是不是之前已经下载失败过的url BOOL isFailedUrl = NO; if (url) &#123; @synchronized (self.failedURLs) &#123; isFailedUrl = [self.failedURLs containsObject:url]; &#125; &#125; //如果是url为空或者不要求失败再次下载并且已知已经下载失败过一次的话,直接回掉完成的block if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123; [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil] url:url]; return operation; &#125; // 直接加入到正在下载的operation数组中 @synchronized (self.runningOperations) &#123; [self.runningOperations addObject:operation]; &#125; // 获取ulr的字符串,也就是key NSString *key = [self cacheKeyForURL:url]; // 从磁盘中获取图片的方法 operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123; // 因为是异步执行,可能被取消任务,所以需要先检查一下 if (operation.isCancelled) &#123; [self safelyRemoveOperationFromRunning:operation]; return; &#125; // 如果并没有缓存图片或者 或者要求即使有缓存图片也要刷新 又或者是要求下载图片,那么就需要重新从网上下载图片 if ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123; // 如果有缓存图片,但是要求不停刷新缓存图片,那么就先显示上缓存图片,进行完成的回调 if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; [self callCompletionBlockForOperation:weakOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; &#125; //对于下载要求的一些整理 SDWebImageDownloaderOptions downloaderOptions = 0; // 下载优先级 if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority; // 渐进式的显示 if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload; // 刷新缓存,需要先进行缓存 if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache; // 后台继续下载 if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground; // 使用cookie if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies; // 允许通过不可靠的认证 if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates; // 高优先级下载 if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority; // 自动缩小大图 if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages; // 有缓存也要刷新的时候就不用进行渐渐显示的样式,并且要忽略缓存的响应内容 if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload; downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse; &#125; // 调用下载的方法进行下载,并且设置完成之后的回调方法 SDWebImageDownloadToken *subOperationToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123; __strong __typeof(weakOperation) strongOperation = weakOperation; // 有错或者取消,并且添加到失败的url数组中进行记录 if (!strongOperation || strongOperation.isCancelled) &#123; &#125; else if (error) &#123; [self callCompletionBlockForOperation:strongOperation completion:completedBlock error:error url:url]; if ( error.code != NSURLErrorNotConnectedToInternet &amp;&amp; error.code != NSURLErrorCancelled &amp;&amp; error.code != NSURLErrorTimedOut &amp;&amp; error.code != NSURLErrorInternationalRoamingOff &amp;&amp; error.code != NSURLErrorDataNotAllowed &amp;&amp; error.code != NSURLErrorCannotFindHost &amp;&amp; error.code != NSURLErrorCannotConnectToHost) &#123; @synchronized (self.failedURLs) &#123; [self.failedURLs addObject:url]; &#125; &#125; &#125; else &#123; if ((options &amp; SDWebImageRetryFailed)) &#123; @synchronized (self.failedURLs) &#123; [self.failedURLs removeObject:url]; &#125; &#125; // 是否要储存到内存中 BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly); // 有缓存图片,但是没有下载图片的时候就啥也不做了 if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123; // 有下载图片但是没有动态图,但是要求是动态图 &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123; // 图片转换成动态图片 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url]; if (transformedImage &amp;&amp; finished) &#123; BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage]; // 储存图片 [self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil]; &#125; [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125;); &#125; else &#123; if (downloadedImage &amp;&amp; finished) &#123; [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil]; &#125; [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125; &#125; // 将operation 移除 if (finished) &#123; [self safelyRemoveOperationFromRunning:strongOperation]; &#125; &#125;]; // 下载过程中删除这个操作的一些回调 operation.cancelBlock = ^&#123; [self.imageDownloader cancel:subOperationToken]; __strong __typeof(weakOperation) strongOperation = weakOperation; [self safelyRemoveOperationFromRunning:strongOperation]; &#125;; &#125; else if (cachedImage) &#123; // 有缓存图片直接用缓存图片 __strong __typeof(weakOperation) strongOperation = weakOperation; [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; [self safelyRemoveOperationFromRunning:operation]; &#125; else &#123; // Image not in cache and download disallowed by delegate __strong __typeof(weakOperation) strongOperation = weakOperation; [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url]; [self safelyRemoveOperationFromRunning:operation]; &#125; &#125;]; return operation;&#125; SDWebImageCacheSDSebImageCache分为内存储存和磁盘储存，磁盘储存的路径默认是(../Library/Caches/default/com.hackemist.SDWebImageCache.default/ )下的文件夹中.当然也可以自定义其他路径。 这个类主要包括: 读取图片， 保存下载图片， 删除某个或者整个文件夹图片， 删除已经过期或者超过内存的图片， 计算磁盘中图片的大小，个数等等。 需要逐个解读。 方法初始化的解读： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns diskCacheDirectory:(nonnull NSString *)directory &#123; if ((self = [super init])) &#123; NSString *fullNamespace = [@\"com.hackemist.SDWebImageCache.\" stringByAppendingString:ns]; // 创建一个单线程 _ioQueue = dispatch_queue_create(\"com.hackemist.SDWebImageCache\", DISPATCH_QUEUE_SERIAL); // 默认配置图片可压缩,不储存在icloud,储存在内存中,最长储存时间是1周,不限制储存大小. _config = [[SDImageCacheConfig alloc] init]; //初始化内存储存的类 _memCache = [[AutoPurgeCache alloc] init]; _memCache.name = fullNamespace;// 初始化储存文件夹的路径 if (directory != nil) &#123; _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace]; &#125; else &#123; NSString *path = [self makeDiskCachePath:ns]; _diskCachePath = path; &#125; dispatch_sync(_ioQueue, ^&#123; _fileManager = [NSFileManager new]; &#125;);// 注册内存警告,终止应用,退到后台的通知[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(clearMemory) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deleteOldFiles) name:UIApplicationWillTerminateNotification object:nil];[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(backgroundDeleteOldFiles) name:UIApplicationDidEnterBackgroundNotification object:nil]; &#125; return self;&#125; 储存图片的关键代码的解读: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061- (void)storeImage:(nullable UIImage *)image imageData:(nullable NSData *)imageData forKey:(nullable NSString *)key toDisk:(BOOL)toDisk completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123; // key值图片的url路径,然后经过MD5(128位)加密之后,把加密后的字符串变成以16进制的形式变成名字.// 没有图片,并且没有图片名字的情况下直接返回if (!image || !key) &#123; if (completionBlock) &#123; completionBlock(); &#125; return; &#125; // 判断是否保存到内存中 if (self.config.shouldCacheImagesInMemory) &#123; // 图片的长*宽*scale*scale NSUInteger cost = SDCacheCostForImage(image); // 以图片名字为key值储存图片 [self.memCache setObject:image forKey:key cost:cost]; &#125; // 根据是否保存到磁盘中 if (toDisk) &#123; //异步储存图片 dispatch_async(self.ioQueue, ^&#123; NSData *data = imageData; if (!data &amp;&amp; image) &#123; //获取图片的类型,根据图片data的第一个字节判断类型:jpeg,png,gif,tiff,webP,未知类型 SDImageFormat imageFormatFromData = [NSData sd_imageFormatForImageData:data]; // 根据图片类型,生成不同的data(jpg,png) data = [image sd_imageDataAsFormat:imageFormatFromData]; &#125; // 根据图片的路径,生成根据 [_fileManager createFileAtPath:cachePathForKey contents:imageData attributes:nil] //这个方法写入文件中 [self storeImageDataToDisk:data forKey:key]; // 之后在主线程进行回调 if (completionBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completionBlock(); &#125;); &#125; else &#123; if (completionBlock) &#123; completionBlock(); &#125; &#125;&#125; 读取图片关键代码解读 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)key &#123;- // 现根据key从内存中取图片 UIImage *image = [self imageFromMemoryCacheForKey:key]; if (image) &#123; return image; &#125; // 然后再次从磁盘中取图片 image = [self imageFromDiskCacheForKey:key]; return image;&#125;// 磁盘中取出图片- (nullable UIImage *)diskImageForKey:(nullable NSString *)key &#123; // 根据key从磁盘中找出来是data数据 NSData *data = [self diskImageDataBySearchingAllPathsForKey:key]; if (data) &#123; //根据data判断生成的图片是普通图片或者是gif(动画效果) // 生成的CGImage等系统方法判断出图片的方向,生成图片方向的图片,普通方法生成的朝上的,其他方向需要自己计算. UIImage *image = [UIImage sd_imageWithData:data]; // 根据屏幕的生成@2x 和@3x图片 image = [self scaledImageForKey:key image:image]; // 根据是否需要压缩图片进行图片压缩 if(self.config.shouldDecompressImages) &#123; //将图片的透明度去掉,重新生成位图 image = [UIImage decodedImageWithImage:image]; &#125; return image; &#125; else &#123; return nil; &#125;&#125;// 在磁盘各个路径寻找图片- (nullable NSData *)diskImageDataBySearchingAllPathsForKey:(nullable NSString *)key &#123; // 默认路径 NSString *defaultPath = [self defaultCachePathForKey:key]; // 默认路径下找图片 NSData *data = [NSData dataWithContentsOfFile:defaultPath]; if (data) &#123; return data; &#125; //如果没有找到, 去掉图片后缀之后再次查找一遍 data = [NSData dataWithContentsOfFile:defaultPath.stringByDeletingPathExtension]; if (data) &#123; return data; &#125; // 如果还么有找到,在一些自定义的刻度路径下查找图片 NSArray&lt;NSString *&gt; *customPaths = [self.customPaths copy]; for (NSString *path in customPaths) &#123; NSString *filePath = [self cachePathForKey:key inPath:path]; NSData *imageData = [NSData dataWithContentsOfFile:filePath]; if (imageData) &#123; return imageData; &#125; // 同样也查找一遍去掉后缀之后的 imageData = [NSData dataWithContentsOfFile:filePath.stringByDeletingPathExtension]; if (imageData) &#123; return imageData; &#125; &#125; return nil;&#125; 删除某个图片或者删除这个文件夹 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 删除某张图片- (void)removeImageForKey:(nullable NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(nullable SDWebImageNoParamsBlock)completion &#123; if (key == nil) &#123; return; &#125; // 如果内存中也应该删除 if (self.config.shouldCacheImagesInMemory) &#123; [self.memCache removeObjectForKey:key]; &#125; // 从磁盘上删除 if (fromDisk) &#123; // 拼接好文件路径,异步删除,主线程进行回调 dispatch_async(self.ioQueue, ^&#123; [_fileManager removeItemAtPath:[self defaultCachePathForKey:key] error:nil]; if (completion) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completion(); &#125;); &#125; &#125;); &#125; else if (completion) &#123; completion(); &#125;&#125;// 删除真个文件夹下面的图片- (void)clearDiskOnCompletion:(nullable SDWebImageNoParamsBlock)completion &#123; dispatch_async(self.ioQueue, ^&#123; // 删除真个文件夹 [_fileManager removeItemAtPath:self.diskCachePath error:nil]; // 删除之后再次创建默认文件夹 [_fileManager createDirectoryAtPath:self.diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL]; // 主线程回掉 if (completion) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completion(); &#125;); &#125; &#125;);&#125; 删除过期或者超过内存文件,主要是通过接受到通知自己的删除,核心代码解读 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock &#123; //异步进行删除 dispatch_async(self.ioQueue, ^&#123; // 找到储存文件的文件夹默认路径 NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES]; NSArray&lt;NSString *&gt; *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey]; // 查找这些文件 NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL includingPropertiesForKeys:resourceKeys options:NSDirectoryEnumerationSkipsHiddenFiles errorHandler:NULL]; // 过期文件的日期 NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge]; NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = [NSMutableDictionary dictionary]; NSUInteger currentCacheSize = 0; NSMutableArray&lt;NSURL *&gt; *urlsToDelete = [[NSMutableArray alloc] init]; // 将查到的这些文件过滤出需要删除的文件 for (NSURL *fileURL in fileEnumerator) &#123; NSError *error; NSDictionary&lt;NSString *, id&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error]; // 过滤掉是文件夹以及出错的路径 if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) &#123; continue; &#125; // 算出文件的日期 NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey]; // 比较是否已经过期,过期文件加入一个数组中 if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123; [urlsToDelete addObject:fileURL]; continue; &#125; //计算存留下来的文件的大小 NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey]; currentCacheSize += totalAllocatedSize.unsignedIntegerValue;cacheFiles[fileURL] = resourceValues;&#125; // 删除过期的文件 for (NSURL *fileURL in urlsToDelete) &#123; [_fileManager removeItemAtURL:fileURL error:nil]; &#125; // 判断剩下的文件总共大小是否多于设置的最大值 if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) &#123; // 目标值 const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2; // 按日期最靠前的方式进行排序,并且可以并发进行排序 NSArray&lt;NSURL *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent usingComparator:^NSComparisonResult(id obj1, id obj2) &#123; return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]]; &#125;]; // 删除多余的文件 for (NSURL *fileURL in sortedFiles) &#123; if ([_fileManager removeItemAtURL:fileURL error:nil]) &#123; NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles[fileURL]; NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey]; currentCacheSize -= totalAllocatedSize.unsignedIntegerValue; // 当小于理想的size就停止 if (currentCacheSize &lt; desiredCacheSize) &#123; break; &#125; &#125; &#125; &#125; if (completionBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completionBlock(); &#125;); &#125; &#125;);&#125; SDWebImageDownloader这个类是将NSOperation中子集任务的封装,就一些列的任务封装起来,并对下载的顺序FIFO或者LIFO等进行调整,以及下载任务请求头的封装,最大并发量等等事情进行操作.实际上也是对NSOperationQueue的封装. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123; __weak SDWebImageDownloader *wself = self; return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123; // 创建一个SDWebImageDownloaderOperation // __Strong是为了再次对其强引用,以防self被释放 __strong __typeof (wself) sself = wself; // 一般是15s NSTimeInterval timeoutInterval = sself.downloadTimeout; if (timeoutInterval == 0.0) &#123; timeoutInterval = 15.0; &#125; // 创建请求的请求头,缓存策略 NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval]; // cookies request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies); request.HTTPShouldUsePipelining = YES; // 自定义请求头的一些内容 if (sself.headersFilter) &#123; request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders copy]); &#125; else &#123; request.allHTTPHeaderFields = sself.HTTPHeaders; &#125; // 创建NSOperation SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options]; operation.shouldDecompressImages = sself.shouldDecompressImages; // 如果有认证策略,需要用户名和密码 if (sself.urlCredential) &#123; operation.credential = sself.urlCredential; &#125; else if (sself.username &amp;&amp; sself.password) &#123; operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession]; &#125; if (options &amp; SDWebImageDownloaderHighPriority) &#123; operation.queuePriority = NSOperationQueuePriorityHigh; &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123; operation.queuePriority = NSOperationQueuePriorityLow; &#125; // 将operation加入到queue队列中 [sself.downloadQueue addOperation:operation]; // 添加依赖的策略,一般是FIFO,如果是LIFO,就需要添加 if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123; // Emulate LIFO execution order by systematically adding new operations as last operation's dependency [sself.lastAddedOperation addDependency:operation]; // 记录最后一个任务 sself.lastAddedOperation = operation; &#125; return operation; &#125;];&#125;// 取消某一个opration,token代表一个opration- (void)cancel:(nullable SDWebImageDownloadToken *)token &#123; dispatch_barrier_async(self.barrierQueue, ^&#123; SDWebImageDownloaderOperation *operation = self.URLOperations[token.url]; BOOL canceled = [operation cancel:token.downloadOperationCancelToken]; if (canceled) &#123; [self.URLOperations removeObjectForKey:token.url]; &#125; &#125;);&#125;// 在operation中添加过程和完成的回调block- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(nullable NSURL *)url createCallback:(SDWebImageDownloaderOperation *(^)())createCallback &#123; if (url == nil) &#123; if (completedBlock != nil) &#123; completedBlock(nil, nil, nil, NO); &#125; return nil; &#125; __block SDWebImageDownloadToken *token = nil; dispatch_barrier_sync(self.barrierQueue, ^&#123; // 取出opration,如果没有就创建,创建之后将其和url形成字典,添加到URLOperations SDWebImageDownloaderOperation *operation = self.URLOperations[url]; if (!operation) &#123; operation = createCallback(); self.URLOperations[url] = operation; // 创建operation的完成回调:从字典中去除, __weak SDWebImageDownloaderOperation *woperation = operation; operation.completionBlock = ^&#123; SDWebImageDownloaderOperation *soperation = woperation; if (!soperation) return; if (self.URLOperations[url] == soperation) &#123; [self.URLOperations removeObjectForKey:url]; &#125;; &#125;; &#125; // 创建operation对应的token标志,这个token包括operaion的url属性和对应的过程和完成回调两个方面 id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]; token = [SDWebImageDownloadToken new]; token.url = url; token.downloadOperationCancelToken = downloadOperationCancelToken; &#125;); return token;&#125; SDWebImageOperation这个类继承于NSOperation,主要是封装了下载的操作.执行一个operation有两种方法，第一种是自己手动的调用start这个方法，这种方法调用会在当前调用的线程进行同步执行，所以在主线程里面自己一定要小心的调用，不然就会把主线程给卡死，还不如直接用GCD呢。第二种是将operation添加到operationQueue中去，这个也是我们用得最多的也是提倡的方法。NSOperationQueue会在我们添加进去operation的时候尽快进行执行。当然如果NSOperationQueue的maxConcurrentOperationCount如果设置为1的话，进相当于FIFO了。 核心代码分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192- (void)start &#123; // 锁定self,这样可以在执行过程中外界不能修改这个对象, @synchronized (self) &#123; //如果已经取消这个任务,就将session和datatask取消,并且也将已经记录的数据imagedata,回调之类全部取消 if (self.isCancelled) &#123; self.finished = YES; [self reset]; return; &#125; #if SD_UIKIT Class UIApplicationClass = NSClassFromString(@\"UIApplication\"); BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)]; if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123; __weak __typeof__ (self) wself = self; UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)]; self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123; __strong __typeof (wself) sself = wself; if (sself) &#123; [sself cancel]; [app endBackgroundTask:sself.backgroundTaskId]; sself.backgroundTaskId = UIBackgroundTaskInvalid; &#125; &#125;]; &#125; #endif// 判断一下从外界传递过来的session是否存在,如果不存在需要自己创建 NSURLSession *session = self.unownedSession; if (!self.unownedSession) &#123; NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration]; sessionConfig.timeoutIntervalForRequest = 15; self.ownedSession = [NSURLSession sessionWithConfiguration:sessionConfig delegate:self delegateQueue:nil]; session = self.ownedSession; &#125; // 创建下载的任务 self.dataTask = [session dataTaskWithRequest:self.request]; //标记执行的状态 self.executing = YES; &#125; // 开始下载任务 [self.dataTask resume]; // 在任务开始的时候就需要通过取出其中的过程回调任务开始回调一些参数 if (self.dataTask) &#123; for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123; progressBlock(0, NSURLResponseUnknownLength, self.request.URL); &#125; // 回到主线程通知已经开始下载 dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self]; &#125;); &#125; else &#123; // 如果没有开始下载就直接结束,回调结束的芳芳 [self callCompletionBlocksWithError:[NSError errorWithDomain:NSURLErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @\"Connection can't be initialized\"&#125;]]; &#125; Class UIApplicationClass = NSClassFromString(@\"UIApplication\"); if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123; return; &#125; if (self.backgroundTaskId != UIBackgroundTaskInvalid) &#123; UIApplication * app = [UIApplication performSelector:@selector(sharedApplication)]; [app endBackgroundTask:self.backgroundTaskId]; self.backgroundTaskId = UIBackgroundTaskInvalid; &#125;&#125; session回调方法的解读 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272//刚开始下载的时候会回调这个方法- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123; // 如果响应的状态码不是304(表示没有任何修改和之前一样),并且不是400, if (![response respondsToSelector:@selector(statusCode)] || (((NSHTTPURLResponse *)response).statusCode &lt; 400 &amp;&amp; ((NSHTTPURLResponse *)response).statusCode != 304)) &#123; NSInteger expected = response.expectedContentLength &gt; 0 ? (NSInteger)response.expectedContentLength : 0; // 获得期望下载的大小 self.expectedSize = expected; // 执行下载过程中的回调 for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123; //回到下载进度,期望下载的大小,以及url progressBlock(0, expected, self.request.URL); &#125; // 初始化储存下载数据的data集合 self.imageData = [[NSMutableData alloc] initWithCapacity:expected]; self.response = response; //回调主线程通知已经开始接收数据 dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:self]; &#125;); &#125; else &#123; NSUInteger code = ((NSHTTPURLResponse *)response).statusCode; // 304需要直接从系统中取出数据即可 if (code == 304) &#123; [self cancelInternal]; &#125; else &#123; [self.dataTask cancel]; &#125; // 通知停止下载 dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:self]; &#125;); // 回到完成的参数 [self callCompletionBlocksWithError:[NSError errorWithDomain:NSURLErrorDomain code:((NSHTTPURLResponse *)response).statusCode userInfo:nil]]; // 标志状态finish = yes,executing=no,取消任务等等 [self done]; &#125; if (completionHandler) &#123; completionHandler(NSURLSessionResponseAllow); &#125;&#125;// 开始接受数据的过程不停回调的方法- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123; // 拼接数据 [self.imageData appendData:data]; //如果选择的状态是渐进式的,就需要不断的显示图片. if ((self.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; self.expectedSize &gt; 0) &#123; CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)self.imageData, NULL); // 如果还没有开始创建图片 if (width + height == 0) &#123; // 得到图片的一些属性 CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, NULL); //图片的高 宽 方向 if (properties) &#123; NSInteger orientationValue = -1; CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight); if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;height); val = CFDictionaryGetValue(properties, kCGImagePropertyPixelWidth); if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;width); val = CFDictionaryGetValue(properties, kCGImagePropertyOrientation); if (val) CFNumberGetValue(val, kCFNumberNSIntegerType, &amp;orientationValue); CFRelease(properties); #if SD_UIKIT || SD_WATCH orientation = [[self class] orientationFromPropertyValue:(orientationValue == -1 ? 1 : orientationValue)]; #endif &#125;&#125; // 当中间过程中不断地绘制图片 if (width + height &gt; 0 &amp;&amp; totalSize &lt; self.expectedSize) &#123; // 创建图片 CGImageRef partialImageRef = CGImageSourceCreateImageAtIndex(imageSource, 0, NULL); #if SD_UIKIT || SD_WATCH // 创建图片的高度 颜色空间 位图context,然后进行画图 if (partialImageRef) &#123; const size_t partialHeight = CGImageGetHeight(partialImageRef); CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef bmContext = CGBitmapContextCreate(NULL, width, height, 8, width * 4, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst); CGColorSpaceRelease(colorSpace); if (bmContext) &#123; CGContextDrawImage(bmContext, (CGRect)&#123;.origin.x = 0.0f, .origin.y = 0.0f, .size.width = width, .size.height = partialHeight&#125;, partialImageRef); CGImageRelease(partialImageRef); partialImageRef = CGBitmapContextCreateImage(bmContext); CGContextRelease(bmContext); &#125; else &#123; CGImageRelease(partialImageRef); partialImageRef = nil; &#125; &#125; #endif if (partialImageRef) &#123; #if SD_UIKIT || SD_WATCH // 得到图片 UIImage *image = [UIImage imageWithCGImage:partialImageRef scale:1 orientation:orientation]; #elif SD_MAC UIImage *image = [[UIImage alloc] initWithCGImage:partialImageRef size:NSZeroSize]; #endif // 对图片进行一些列操作,并且返回 NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL]; UIImage *scaledImage = [self scaledImageForKey:key image:image]; if (self.shouldDecompressImages) &#123; // 直接对图片进行解压 image = [UIImage decodedImageWithImage:scaledImage]; &#125; else &#123; image = scaledImage; &#125; CGImageRelease(partialImageRef); [self callCompletionBlocksWithImage:image imageData:nil error:nil finished:NO]; &#125; &#125; CFRelease(imageSource); &#125; for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123; // 如果是普通option.只需要在过程中对调,不需要不断的显示 progressBlock(self.imageData.length, self.expectedSize, self.request.URL); &#125;&#125;// 询问代理数据是否需要储存在响应的缓存里- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler &#123; responseFromCached = NO; // If this method is called, it means the response wasn't read from cache NSCachedURLResponse *cachedResponse = proposedResponse; // 如果是忽略掉本地的缓存的话,就直接将 if (self.request.cachePolicy == NSURLRequestReloadIgnoringLocalCacheData) &#123; cachedResponse = nil; &#125; if (completionHandler) &#123; completionHandler(cachedResponse); &#125;&#125;#pragma mark NSURLSessionTaskDelegate// 完成任务的回到- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123; @synchronized(self) &#123; // 任务清空 self.dataTask = nil; // 通知停止和完成两个操作 dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:self]; if (!error) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadFinishNotification object:self]; &#125; &#125;); &#125; // 如果有错误,回调有错 if (error) &#123; [self callCompletionBlocksWithError:error]; &#125; else &#123; if ([self callbacksForKey:kCompletedCallbackKey].count &gt; 0) &#123; //如果option是忽略缓存,但是响应还是来自缓存,那么什么也不返回 if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse &amp;&amp; responseFromCached &amp;&amp; [[NSURLCache sharedURLCache] cachedResponseForRequest:self.request]) &#123; [self callCompletionBlocksWithImage:nil imageData:nil error:nil finished:YES]; &#125; else if (self.imageData) &#123; // 根据data生成有方向,jpg或者gif或者png图片 UIImage *image = [UIImage sd_imageWithData:self.imageData]; // 图片的真正尺寸 NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL]; image = [self scaledImageForKey:key image:image]; // 压缩图片 if (!image.images) &#123; if (self.shouldDecompressImages) &#123; if (self.options &amp; SDWebImageDownloaderScaleDownLargeImages) &#123; #if SD_UIKIT || SD_WATCH image = [UIImage decodedAndScaledDownImageWithImage:image]; [self.imageData setData:UIImagePNGRepresentation(image)]; #endif &#125; else &#123; image = [UIImage decodedImageWithImage:image]; &#125; &#125; &#125; //进一步判断图片是不是空 if (CGSizeEqualToSize(image.size, CGSizeZero)) &#123; [self callCompletionBlocksWithError:[NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @\"Downloaded image has 0 pixels\"&#125;]]; &#125; else &#123; [self callCompletionBlocksWithImage:image imageData:self.imageData error:nil finished:YES]; &#125; &#125; else &#123; [self callCompletionBlocksWithError:[NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @\"Image data is nil\"&#125;]]; &#125; &#125; &#125; [self done];&#125;","tags":[]},{"title":"制作正式版 Mac OS 10.12 安装 U盘","date":"2017-02-03T03:05:45.000Z","path":"2017/02/03/制作正式版 Mac OS 10.12 安装 U盘/","text":"1.准备工作： 准备一个 8GB 或以上容量的 U 盘，确保里面的数据已经妥善备份好（该过程会抹掉 U 盘全部数据） 首先，在 MAS 下载 macOS 10.12 原版安装包。或者通过其他途径下载，拖动至自己的 应用程序（Applications）文件夹。 确定应用程序名字为「Install macOS Sierra.app」 2.格式化优盘 插入你的 U 盘，然后在「应用程序」-&gt;「实用工具」里面找到并打开「磁盘工具」 在左方列表中找到 U 盘的名称并点击 右边顶部选择「分区」，然后在「分区布局」选择「1个分区」 在分区信息中的 「名称」输入「ABCD」 (由于后面的命令中会用到此名称，如果你要修改成其他(英文)，请务必对应修改后面的命令) 在「格式」中选择 「Mac OS 扩展 (日志式)」 这时，先别急着点“应用”，还要先在 「选项」里面，选择「GUID 分区表」 开始格式化 3.输入终端命令开始制作启动盘 1.请再次确保安装文件是保存在「应用程序」的目录中 2.在「应用程序」-&gt;「实用工具」里面找到「终端」并打开。也可以直接通过 Spotlight 搜索「终端」打开 3.复制下面的命令，并粘贴到「终端」里，按回车运行： ——命令开始—— 从sudo开始复制（不要复制这句话） sudo /Applications/Install\\ macOS\\ Sierra.app/Contents/Resources/createinstallmedia –volume /Volumes/ABCD –applicationpath /Applications/Install\\ macOS\\ Sierra.app –nointeraction ——命令结束—— 到nointeraction结束（不要复制这句话） 命令说明：Install\\ macOS\\ Sierra.app 这个是正式版的“安装 macOS Sierra” 正确位置ABCD 这个是优盘的名字 回车后，系统会提示你输入管理员密码，接下来就是等待系统开始制作启动盘了。这时，命令执行中你会陆续看到类似以下的信息： （在这里输入密码） Erasing Disk: 0%… 10%… 20%… 30%…100%…Copying installer files to disk…Copy complete.Making disk bootable…Copying boot files…Copy complete.Done. 当你看到最后有 「Copy complete」和「Done」 字样出现就是表示启动盘已经制作完成了！ 4.U 盘启动安装 macOS Sierra 的方法 当你插入制作完成的 macOS Sierra U盘启动盘之后，桌面出现「Install macOS Sierra」的盘符那么就表示启动盘是正常的了。那么怎样通过 USB 启动进行全新的系统安装呢？ 其实很简单，先在目标电脑上插上 U 盘，然后重启你的 Mac，然后一直按住「option」(alt) 按键不放，直到屏幕显示多出一个 USB 启动盘的选项。 这时选择 U 盘的图标回车，即可通过 U 盘来安装 macOS Sierra 了！这时，你可以直接覆盖安装系统(升级)，也可以在磁盘工具里面格式化抹掉整个硬盘，或者重新分区等实现全新的干净的安装。","tags":[]},{"title":"翻译-利用 Healthkit 进行睡眠分析（Swift）","date":"2017-02-03T00:12:38.000Z","path":"2017/02/03/翻译-利用Healthkit进行睡眠分析(Swift）/","text":"原文：http://appcoda.com/sleep-analysis-healthkit/ 翻译：Liberalism 日期：2016年10月5日 现如今，睡眠变革已经成为了一种全新的潮流。用户比以往任何时候都更加关注自己的睡眠。他们不仅仅关心自己睡了多久，同样也很希望通过一段时间的数据收集和分析能够绘制出他们的睡眠趋势。而技术上的进步，包括硬件、特别是智能手机的高速发展，使睡眠变革这一高速发展的领域迎来了全新的曙光。 苹果在基于安全的前提下，提供了一种非常酷的方式来与用户的个人健康信息进行通信，并通过iOS内置的健康应用存储信息。作为开发者不仅可以使用HealyhKit来打造健康类的App，同时该框架还允许开发者访问睡眠数据，进行处理分析。 在本教程中，针对Healthkit框架我会带领大家快速入门，同时会向大家演示如果快速搭建一个简单的睡眠分析的App 1.简介 HealthKit框架结构提供了一个称之为HealthKit Store的加密数据库，开发者可以使用HKhealth Store这个类来访问这个数据库。iPhone和Apple Watch分别有自己的HealthKit Store，健康数据会在iPhone和Apple Watch之间同步。然而，Apple Watch为了节省内存空间会自动清理掉一些旧的数据。目前healthKit框架和健康类的App在iPad上是不支持的。 如果你想创建一个基于健康数据的iOS App或者是WatchOS App，HealthKit框架无疑是非常强大的一个工具。HealthKit设计的初衷是管理来源广泛的数据，基于用户喜好把来源不同的数据进行自动合并。应用程序还可以访问每个源的原始数据，并将数据本身合并。App不仅仅用于身体指标的检测、健身或营养情况，还可以用于睡眠分析 那么在接下来的文章里，我会向大家展示在iOS平台上如何利用HealthKit框架去存储、连接睡眠的分析数据。以上的方法也同样适用于watchOS平台上应用。需要注意的是这篇教程使用了Swift2.0和Xcode 7，所以为了接下来的课程，请确保你目前正在使用的Xcode 7 在我们正式开始之前，请提前下载好我们的项目并且解压。我已经创建好了基本的UI界面。当你运行时，你会看到一个计时器的UI界面，当你按下开始按钮之后，就会发现开始计时。 2.使用HealthKit Framework我们App的目标是存储睡眠的分析信息，并通过开始和结束两个按钮检索信息。要使用HealthKit，首先应该在你应用的bundle中打开HealthKit的权限。在你的项目中，在导航中找到当前的target -&gt; 再找到 capabilities，然后打开。 接下来你需要按照以下的代码在ViewController类里创建一个HKHealthStore的实例变量 1let healthStore = HKHealthStore() 然后，我们将利用HKHealthStore这个实例变量去连接HealthKit Store这个加密数据库。 如之前所说，HealthKit允许用户掌握自己的健康数据，所以在你可以操作、分析用户的睡眠数据之前，你首先需要去获取用户许可。获取许可，首先要导入HealthKit Framework，然后如下面一样更新ViewDidLoad中的代码 1234567891011121314151617override func viewDidLoad() &#123; super.viewDidLoad() let typestoRead = Set([ HKObjectType.categoryTypeForIdentifier(HKCategoryTypeIdentifierSleepAnalysis)! ]) let typestoShare = Set([ HKObjectType.categoryTypeForIdentifier(HKCategoryTypeIdentifierSleepAnalysis)! ]) self.healthStore.requestAuthorizationToShareTypes(typestoShare, readTypes: typestoRead) &#123; (success, error) -&gt; Void in if success == false &#123; NSLog(\" Display not allowed\") &#125; &#125;&#125; 以上代码可以提供给用户同意或拒绝的提示，通过block，你可以在处理成功和失败后进行相应的操作并获得最终的结果。没有必要一直向用户请求许可，你必须很好的处理程序中的各种错误 但是为了避免用户的误操作，用户必须在设置页面亲自打开允许按钮，这样才能确保真正获得设备上健康数据的权限 写入睡眠分析数据 首先，如何去检索睡眠分析数据呢？根据苹果官方文档的说法，每一个睡眠分析的样本都有一个唯一值，为了确保用户是躺下并且入睡，HealthKit在同一时间内会对两个或更多的数据进行采样。通过对这些样本的开始时间和结束时间进行对比，应用程序可以进行大量的二次统计和计算。 用户花费多少时间入睡。 用户躺在床上实际入睡时间所占的比例 用户醒来之后，会在床上躺多久 用户在床上，以及睡眠时所花费的时间汇总 简明的讲，把睡眠分析数据储存到HealthKit store数据库中时，你需要遵循以下方法 首先我们需要定义两个NSDate对象去对应开始时间和结束时间。 然后我们利用HKCategoryTypeIdentifierSleepAnalysis创建一个HKObjectType的实例变量 我们需要创建一个全新的HKCategorySample类型的对象，通常采用分类样本的方式来存储睡眠数据，独立的样本代表用户躺在床上或者入睡的时间段。所以我们可以在同一时间段内分别创建出在床上未入睡以及入睡之后的样本 最终，我们就可以利用HKHealthStore类中的saveObject方法把对象存储起来 编者提示：如果想查看样本的类型，可以查阅HealthKit官方文档 如果你把以上的注意点和方法转化到Swift中，以下就是把躺床上未入睡和入睡的分析数据储存起来的代码，请把以下代码插入到ViewController类中 123456789101112131415161718192021222324252627282930313233343536func saveSleepAnalysis() &#123; // alarmTime and endTime are NSDate objects if let sleepType = HKObjectType.categoryTypeForIdentifier(HKCategoryTypeIdentifierSleepAnalysis) &#123; // we create our new object we want to push in Health app let object = HKCategorySample(type:sleepType, value: HKCategoryValueSleepAnalysis.InBed.rawValue, startDate: self.alarmTime, endDate: self.endTime) // at the end, we save it healthStore.saveObject(object, withCompletion: &#123; (success, error) -&gt; Void in if error != nil &#123; // something happened return &#125; if success &#123; print(\"My new data was saved in HealthKit\") &#125; else &#123; // something happened again &#125; &#125;) let object2 = HKCategorySample(type:sleepType, value: HKCategoryValueSleepAnalysis.Asleep.rawValue, startDate: self.alarmTime, endDate: self.endTime) healthStore.saveObject(object2, withCompletion: &#123; (success, error) -&gt; Void in if error != nil &#123; // something happened return &#125; if success &#123; print(\"My new data (2) was saved in HealthKit\") &#125; else &#123; // something happened again &#125; &#125;) &#125; &#125; 这个方法会在我们想把睡眠分析数据存储到HealthKit中时被调用 3.读取睡眠分析数据 想要读取睡眠分析数据，我们需要创建一个查询对象。首先需要为HKCategoryTypeIdentifierSleepAnalysis定义一个HKObjectType类型的分类。或许你希望通过谓词在开始时间和结束时间这个你需要的时间段内进行筛选、检索数据。你也需要为分类检索查询创建 一个分类描述器以获取我们想要的结果 您的用于检索睡眠分析数据的代码应如下所示： 1234567891011121314151617181920212223242526272829303132333435363738func retrieveSleepAnalysis() &#123; // first, we define the object type we want if let sleepType = HKObjectType.categoryTypeForIdentifier(HKCategoryTypeIdentifierSleepAnalysis) &#123; // Use a sortDescriptor to get the recent data first let sortDescriptor = NSSortDescriptor(key: HKSampleSortIdentifierEndDate, ascending: false) // we create our query with a block completion to execute let query = HKSampleQuery(sampleType: sleepType, predicate: nil, limit: 30, sortDescriptors: [sortDescriptor]) &#123; (query, tmpResult, error) -&gt; Void in if error != nil &#123; // something happened return &#125; if let result = tmpResult &#123; // do something with my data for item in result &#123; if let sample = item as? HKCategorySample &#123; let value = (sample.value == HKCategoryValueSleepAnalysis.InBed.rawValue) ? \"InBed\" : \"Asleep\" print(\"Healthkit sleep: \\(sample.startDate) \\(sample.endDate) - value: \\(value)\") &#125; &#125; &#125; &#125; // finally, we execute our query healthStore.executeQuery(query) &#125;&#125; 此代码查询HealthKit以获取所有睡眠分析数据，然后将其按降序排序。 然后使用startDate和endDate以及值的类型（即In Bed或Asleep）打印每个查询。 我已将限制设置为30，以检索最近30个记录的样本。 您还可以使用谓词方法来选择自定义的开始和结束日期。 4.App 测试对于演示应用程序，我使用NSTimer显示自您按下启动按钮以来经过的时间。 NSDate对象在开始和结束按钮上创建，以将睡眠分析数据保存为已用时间。 在停止操作方法中，可以调用saveSleepAnalysis（）和retrieveSleepAnalysis（）方法来保存和获取睡眠数据。 123456@IBAction func stop(sender: AnyObject) &#123; endTime = NSDate() saveSleepAnalysis() retrieveSleepAnalysis() timer.invalidate()&#125; 在您的应用程序中，您可能需要更改NSDate对象以选择相关的开始和结束时间（可能不同），以保存躺在床上的数据和睡眠值。 完成更改后，您可以运行演示应用并启动计时器。让它运行几分钟，然后点击停止按钮。之后打开健康应用程序。你会发现睡眠数据。 5.对使用 HealthKit 应用的一些建议HealthKit旨在为应用开发人员提供一个通用平台，以便轻松共享和访问用户数据，并避免数据中可能的重复或不一致。苹果审查指南非常明确的说明应用程序使用HealthKit和访问用户读/写权限必须通过向用户请求，但没有清楚地阐述HealthKit的使用可能会导致应用程序被拒绝。 将假的或不正确的数据保存到健康的应用程序也将被拒绝。 这意味着，你不能天真地使用算法来计算不同的健康值，如本教程中的睡眠分析。 您应该尝试使用内置的传感器数据读取和操作任何参数，以避免计算假数据。 对于完整的Xcode项目，你可以在这里得到。","tags":[]},{"title":"SVN上文件被locked的解决办法","date":"2017-01-30T08:57:42.000Z","path":"2017/01/30/SVN上文件被locked的解决办法/","text":"在工作过程中由于网络中断、或是人为的强制关闭SVN版本控制工具。SVN出于自我的保护机制，会自动在每个文件夹中生成lock文件，这样我们下次打开SVN是无法进行操作的，SVN会提示我们系统中有文件被锁，此时你只需进入项目文件夹中把所有的lock文件删除即可 1.首先使用终端 cd 到目标文件夹 2.直接执行下面的这句命令 12# 这句话的意思很简单，就是找到当前目录下的所有.SVN文件夹，并把文件夹下的所有LOCK文件 干掉。find . | grep \".svn/lock\" | xargs rm 3.之后再回到SVN中进行操作吧，大功告成。 按步骤进行的过程中遇到问题，欢迎和我交流。","tags":[]},{"title":"源码解析-MJExtension","date":"2017-01-28T08:13:18.000Z","path":"2017/01/28/源码解析-MJExtension/","text":"结构1.NSObjecte+MJKeyValue提供的字典和模型互相转换的核心代码和逻辑. 2.NSObject+MJProperty提供了字典key值和value值与模型属性的相对对应关系的配置.最常见写在模型中的方法mj_setupReplacedKeyFromPropertyName和mj_setupObjectClassInArray 3.NSObject+MJCoding主要是模型的归档和解码.外界实现比较方法,主要是一个宏,这个宏其实是代替两个方法. 4.NSObject+MJClass提供了遍历属性类型父类的方法.以及模型和字典互转过程中需要转化的白名单和黑名单. 5.MJProperty包装模型中每个属性,包括属性的类型,属性的名字,父类.储存和取出属性对应的值. 6.MJPropertyKey模型对应的key值,以及他的对应的类型(字典还是数组) 7.MJPropertyType属性对应的类型,这个里面比较细:比如这个属性是一个基本类型,还是一个foundation类,还是另外一个模型类型等等. 8.MJFoundation这两个类分别代表遍历某个类是不是Foudation框架下 9.MJExtensionConst一些基本的配置信息的宏,比如断言,错误,日志输出等等. 主要逻辑的说明1.从字典转模型基本方法 ==- (instancetype)mj_setKeyValues:(id)keyValues context:(NSManagedObjectContext *)context== 开始捋顺逻辑: 代码中需要学习的部分1.对于经常用到的方法或者语句可以抽成宏或者内联方法,方便使用. 2.runtime获取属性的应用是方法的关键. 3.对于objc_setAssociatedObject和objc_getAssociatedObject动态增加属性方法的使用. 4.将 key值 和 模型属性 的转换桥梁以动态属性的方式写在自己的类里面.对于模型的侵入性很小. 5.将每一个模型中属性的包装.然后NSObject中根据之后包装进行处理,转换成想要的样子 runTime1.获取所有属性class_copyPropertyList说明：使用class_copyPropertyList并不会获取无@property声明的成员变 获取属性名property_getName3.描述一个属性objc_property_t4.获取所有属性特性property_copyAttributeList 获取属性特性描述字符串property_getAttributes,获取的结果类似是T@&quot;NSDictionary&quot;,C,N,V_dict1 注意获取的结果解释: 属性类型 name值：T value：变化 编码类型 name值：C(copy) &amp;(strong) W(weak)空(assign) 等 value：无非/原子性 name值：空(atomic) N(Nonatomic) value：无变量名称 name值：V value：变化 12345678910unsigned int outPut = 0;objc_property_t *prots = class_copyPropertyList([TestMadal class], &amp;outPut);for (int i = 0; i&lt;outPut; i++)&#123; objc_property_t property = prots[i]; const char *t = property_getName(property); const char *attrs = property_getAttributes(property); NSLog(@&quot;%s---%s&quot;,t,attrs);&#125;","tags":[]},{"title":"源码解析-ObjectMapper","date":"2017-01-28T08:13:03.000Z","path":"2017/01/28/源码解析-ObjectMapper/","text":"两个协议文件(Mappleable 和 ImmutableMapple),是其他一切的基础 map文件 主要是用来匹配json字符和模型 Mapper文件是转换模型的逻辑文件,里面各种映射逻辑 operators 文件是操作符定义的文件,将模型和jsonvalue关联的地方 toJson 和 fromJson 文件是转换的过程中需要做的工作 transform 转成模型的具体类型的转换 ##Mappable和ImmutableMapple文件 1.文件中主要是两个必须实现的协议方法,以及协议的扩展,协议的扩展中的方法也可以直接调用转换成模型. 2.模型遵守协议的时候一定要搞清楚需要模型中的变量是变量还是常量.如果是常量的话,然后继承不同的协议,进行不同的处理. 12345678 struct Struct &#123; let prop1: String let prop2: Int&#125; extension Struct: ImmutableMappable &#123; init(map: Map) throws &#123; prop1 = try map.value(&quot;prop1&quot;) prop2 = try map.value(&quot;prop2&quot;) Mapper文件这个方法是跟外界接触的方法,主要分为两大部分: 将json[String:Any]转为模型T,还有就是把T转为json.主要说一下将json转化为模型. 将一个json串转化成的value给一个已经存在的模型对象赋值还是直接创建一个新的模型,对新的模型赋值.主要讲一下给一个新的模型赋值的例子方法例子: 12345678//直接将json中得到的value赋值给这个已经存在的object public func map(JSONObject: Any?, toObject object: N) -&gt; N&#123; &#125; // 重新创建一个模型,然后将json的value赋值给这个模型 public func map(JSONObject: Any?) -&gt; N?&#123; &#125; ####json数据处理1.map可以将json字符串转换成相应的字典或者数组格式,然后再次转换成相应的模型.格式对应的模型总结如下: [String:Any] -&gt; T,[[String:Any]] -&gt; [T],[String:[string:Any]] -&gt; [String:T],[String:[[String:Any]]] -&gt; [String:[T]],[[[string:Any]]] -&gt; [[T]]2.不管这些格式多么复杂,都是通过遍历等各种方法得到最终核心[String:Any]这个格式,然后变成T.所以可以看看这个方法是怎么写的: 123456789101112131415161718192021222324// 对于新创建一个模型 public func map(JSON: [String: Any]) -&gt; N? &#123; let map = Map(mappingType: .fromJSON, JSON: JSON, context: context, shouldIncludeNilValues: shouldIncludeNilValues) // N 是遵循了StaticMappable协议的 if let klass = N.self as? StaticMappable.Type &#123; if var object = klass.objectForMapping(map: map) as? N &#123; object.mapping(map: map) return object &#125; &#125; else if let klass = N.self as? Mappable.Type &#123; // Check if object is Mappable if var object = klass.init(map: map) as? N &#123; object.mapping(map: map) return object &#125; &#125; else if N.self is ImmutableMappable.Type &#123; // Check if object is ImmutableMappable assert(false, \"'ImmutableMappable' type requires throwing version of function \\(#function) - use 'try' before \\(#function)\") &#125; else &#123; // Ensure BaseMappable is not implemented directly assert(false, \"BaseMappable should not be implemented directly. Please implement Mappable, StaticMappable or ImmutableMappable\") &#125; return nil &#125; 对于上面一段代码主要是逻辑是: 创建一个map实例对象. 看一下模型T遵守的协议是哪个,然后创建模型实例并且调用协议中的方法 Map文件 1.map文件最主要搞明白几个主要的变量和subscript方法: JSON变量是mapper文件中传递过来带有json值得变量. isKeyPresent如果是true,则可以将其赋值给对应的模型变量. currentValue存放模型变量的值 currentKey是实例对象map中括号中的key值. keyIsNested是key值是否被包裹着,例如a.b就是被包裹着 toObject是否映射到一个已经存在的模型上. 重写subscript()方法就可以让自定义的实例变量也可以通过像字典那样,可以拥有key值.我们还可以给类、结构、枚举等自定义下标（subscript）。 12345678910111213141516171819202122232425262728//参数不可以是inout类型参数，且参数不能有默认值// 可以只实现get方法,或者set和get方法同时实现subscript(参数1，参数2...)-&gt;返回值&#123; get&#123; &#125; set(newValue)&#123; &#125; &#125;// 例子subscript(requestedMeal : MealTime) -&gt; String &#123; get &#123; if let thisMeal = meals[requestedMeal] &#123; return thisMeal &#125; else &#123; return &quot;Ramen&quot; &#125; &#125; set &#123; meals[requestedMeal] = newValue &#125; &#125; ** 其中最主要的方法是下面这个: 12345678910111213141516171819202122232425262728293031 public subscript(key: String, nested nested: Bool, delimiter delimiter: String, ignoreNil ignoreNil: Bool) -&gt; Map &#123; // save key and value associated to it currentKey = key keyIsNested = nested nestedKeyDelimiter = delimiter if mappingType == .fromJSON &#123; // check if a value exists for the current key // do this pre-check for performance reasons if nested == false &#123; let object = JSON[key] let isNSNull = object is NSNull // 判断是不是null isKeyPresent = isNSNull ? true : object != nil currentValue = isNSNull ? nil : object &#125; else &#123; // break down the components of the key that are separated by . (isKeyPresent, currentValue) = valueFor(ArraySlice(key.components(separatedBy: delimiter)), dictionary: JSON) &#125; // update isKeyPresent if ignoreNil is true if ignoreNil &amp;&amp; currentValue == nil &#123; isKeyPresent = false &#125; &#125; return self&#125; 主要逻辑是: 通过key或者去JSON字典中值,判断是不是nil或者NULL 如果key被包裹着,然后拆开获取JSON中的value值 Operators文件 Swift可以自定义运算符。自定义的运算符可以在全局使用。需要使用operator关键字。使用prefix, infix or postfix标记运算符使用的位置。(另外swift还可以对结构体.类重载已经存在运算符,在全局使用) 文件中对不同的参数进行了完备的定义.兼顾各种情况. 12345678910111213这里有三个步骤去定义一个自定义操作符： 1.命名你的运算符 例如:&gt;&gt;&gt; 2.选择一种类型:一元,二元,三元 例如:一元关键字 : prefix or postfix,二元或者三元 :infix. 3.设置它的优先级和结合性:associativity和优先级precedence。associativity有三个值：left, right, none,默认是none。precedence默认值是：100。可以默认不写 infix operator &gt;&gt;&gt; &#123; // 有默认值,可以不写 associativity left precedence 140 &#125;func +- (left: Int, right: Int) -&gt; Int &#123; return 111&#125; 暂时写这些捋顺一下这个源码的逻辑.","tags":[]},{"title":"NSPredicate的一些简单用法","date":"2017-01-21T03:00:42.000Z","path":"2017/01/21/NSPredicate的一些简单用法/","text":"NSPredicate可以支持数据库查询,平时的一些数组查询之类也用这个方法,以下是一些总结 ####格式字符串的一些基本写法1&gt; @&quot;attributeName == %@&quot; 就是属性名字等于某个值2&gt;@&quot;%K == %@&quot;,将属性名字变为%K,增加拓展性. 12345// 1.第一种写法,右边值如果是字符串,可以用单引号表示NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;nickName == &apos;小明&apos;&quot;,];// 2.第二种写法,%K的K必须大写,不能用%@代替NSString *name = @&quot;cat.nickName&quot;;NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;%K == %@&quot;,name,@&quot;小明&quot;]; ####左右两边基本的比较操作符号1.=,==左边表达式等于右手表达式 2.&gt;=,=&gt;左边表达式大于或等于右边表达式 3.&lt;=,=&lt;左变表达式小于或等于右边表达式 4&gt; 或者 &lt; 5.!=,&lt;&gt;左边表达式不等于右边表达式 6.IN左边表达式必须出现在右边表达式指定的集合中。即name IN {&#39;Milk&#39;，&#39;Eggs&#39;，&#39;Bread&#39;} 7.BETWEEN左边表达式在右边表达式之间或等于右边表达式。即1 {0，33}之间。如果你的左边表达式是0或33，也是真的 8.以下是字符串表达式的比较符号(1)BEGINSWITH左边表达式以右边表达式开始(2)CONTAINS左边表达式包含表达式(3)ENDSWITH左边表达式以右边表达式结束(4)LIKE左边表达式等于右手表达式：？和*作为通配符，其中？匹配1个字符，*匹配0个或多个字符(5)MATCHES左边表达式等于右边表达式使用正则表达式样式比较 ####两个表达式的逻辑符号1.AND,&amp;&amp;,逻辑AND 2.OR,||逻辑或 3.NOT,!逻辑NOT ###数组的操作的一些特性1.对数组中数字集合的一些操作(1)@avg返回collection中对象平均值,以NSNumber的形式返回(2)@count集合中总共的个数,,以NSNumber的形式返回(3)``@min1(4)使用``valueForKeyPath``返回相应的结果 // 处理大量数字组成的数组的时候可以使用,可以方便的进行判断.然后进行下一步操作NSArray array = @[@(30),@(40),@(50)];NSPredicate pre = [NSPredicate// 最小值是不是大于30predicateWithFormat:@”@min.intValue &gt; 30”];BOOL ok = [pre evaluateWithObject:array];// 可以使用key == value 来去的最小,最大,总和,平均等值.并且返回一个nsnumer类型的值NSNumber *a = [array11 valueForKeyPath:@”@min.intValue”];NSLog(@”%d”,a.intValue);12342.**数组中存放对象的一些操作**(1) ``@distinctUnionOfObjects``返回一个数组,这个数组是由操作符``.``右侧属性的值组成的,并且重复的值被过滤掉.``@unionOfObjects``逻辑和``@distinctUnionOfObjects``相同,但是重复的值没有被过滤掉(2)``@distinctUnionOfArrays``返回的是数组,但是将数组中的数组元素拆分到一个数组里面,逻辑同上面,不包括重复值``@unionOfArrays``包括重复值(3)返回值都是使用``valueForKeyPath``取到 CatModal cat1 = [[CatModal alloc] initWithNickName:@”小明” withWeight:30.1];CatModal cat2 = [[CatModal alloc] initWithNickName:@”mimi” withWeight:33.1]; CatModal cat4 = [[CatModal alloc] initWithNickName:@”fuu” withWeight:35.1];CatModal cat5 = [[CatModal alloc] initWithNickName:@”err” withWeight:35.1]; TestModal test1 = [[TestModal alloc] initWithName:@”小七” withHeith:90.1 withCat:cat1];TestModal test2 = [[TestModal alloc] initWithName:@”小七” withHeith:80.1 withCat:cat2];withHeith:60.1 withCat:cat3]; TestModal *test4 = [[TestModal alloc] initWithName:@”小七” withHeith:60.1 withCat:cat4]; TestModal *test5 = [[TestModal alloc] initWithName:@”小七” withHeith:60.1 withCat:cat5]; NSArray array = @[test2,test1];NSArray array2 = @[test4,test5];NSArray *arrayofarray = @[array,array2]; NSArray array11111 = [array valueForKeyPath:@”@distinctUnionOfObjects.cat”];for (CatModal cat in array11111) { NSLog(@”%@\\n”,cat.nickName);[小明,mini]} NSArray array1 = [arrayofarray valueForKeyPath:@”@distinctUnionOfArrays.cat”];for (CatModal cat in array1) { NSLog(@”%@\\n”,cat.nickName); // [fuu 小明 mimi err],并不是数组中的数组的形式}1234567893.**数组中的``SELF``指什么**数组中``SELF``指的是数组中包含的每一个对象4.**对数组中具体的某个位置进行操作查询**``array[index]``指定数组中指定索引处的元素进行匹配操作``array[FIRST]````array[LAST]````array[SIZE]``分别表示对数组第一个,最后一个,数组总数进行操作 CatModal cat1 = [[CatModal alloc] initWithNickName:@”小明” withWeight:30.1];CatModal cat2 = [[CatModal alloc] initWithNickName:@”mimi” withWeight:33.1];CatModal cat3 = [[CatModal alloc] initWithNickName:@”miru” withWeight:35.1];CatModal cat4 = [[CatModal alloc] initWithNickName:@”fuu” withWeight:35.1];CatModal cat5 = [[CatModal alloc] initWithNickName:@”err” withWeight:35.1];CatModal cat6 = [[CatModal alloc] initWithNickName:@”ooo” withWeight:35.1];TestModal *test1 = [[TestModal alloc] initWithName:@”小七” withHeith:90.1 withCat:cat1];test1.catsArray = @[cat2,cat1]; TestModal test2 = [[TestModal alloc] initWithName:@”小七” withHeith:80.1 withCat:cat2];test2.catsArray = @[cat4];TestModal test3 = [[TestModal alloc] initWithName:@”小七” withHeith:60.1 withCat:cat3];test3.catsArray = @[cat5,cat6]; NSArray array = @[test2,test1,test3];NSPredicate pre = [NSPredicate predicateWithFormat:@”catsArray[SIZE] == 1”];NSArray *array1 = [array filteredArrayUsingPredicate:pre];NSLog(@”11111%@”,array1);12345675.**对数组中的数组进行操作的时候查询关键字,只能用在数组,一对多的形式**``ANY或者SOME``对数组中的数组进行查询,只要有符合条件的,就返回``TRUE````ALL``数组中所有都符合条件的时候才会返回。``NONE``都不正确的时候才返回true。 CatModal cat1 = [[CatModal alloc] initWithNickName:@”小明” withWeight:30.1];CatModal cat2 = [[CatModal alloc] initWithNickName:@”mimi” withWeight:33.1];CatModal cat3 = [[CatModal alloc] initWithNickName:@”miru” withWeight:35.1];TestModal test1 = [[TestModal alloc] initWithName:@”小七” withHeith:90.1 withCat:cat1];test1.catsArray = @[cat2,cat3]; TestModal test2 = [[TestModal alloc] initWithName:@”小七” withHeith:80.1 withCat:cat1];test2.catsArray = @[cat2];TestModal test3 = [[TestModal alloc] initWithName:@”小七” withHeith:60.1 withCat:cat1];test3.catsArray = @[cat1,cat3];NSArray array = @[test2,test1,test3];// ALL ANY SOME 用于NSArray NSSet .ANY SOME是数组中有真的就返回. ALL是数组中全部是真的才返回NSPredicate pre = [NSPredicate predicateWithFormat:@”ALL catsArray.weight &gt; 31.0”];NSArray *array1 = [array filteredArrayUsingPredicate:pre];NSLog(@”%@”,array1);1234567891011注意:1.查询过程中使用``department.name``这样的形式比较耗费性能.尽量不要使用.``department == %@``这样的形式查询效率最高.2. ``@&quot;firstName beginswith[cd] &apos;Matt&apos; AND (ANY directreports.paygrade &lt;= 7)&quot;`` 比下面这种形式更高效 ``@&quot;(ANY directreports.paygrade &lt;= 7) AND (firstName beginswith[cd] &apos;Matt&apos;)&quot;``3.使用predicate的类必须支持key-value-coding ,这样才可以在其他地方使用. 实际上使用predicate 也是根据key-value这样的形式来查询的.4.``[c],[d],[cd]``可以加到比较符号的后面表示不区分大小写，不区分发音符号，两这个都不区分5.如果想要匹配null或者nil值得时候,需要额外增加一条对比 predicate = [NSPredicate predicateWithFormat:@”(firstName == %@) || (firstName == nil)”];filteredArray = [array filteredArrayUsingPredicate:predicate];NSLog(@”%@”, filteredArray);```","tags":[]},{"title":"iOS部署开发环境的几个步骤","date":"2017-01-21T03:00:42.000Z","path":"2017/01/21/iOS部署开发环境/","text":"安装 Homebrew Homebrew简称brew,是Mac OSX上的软件包管理工具,能在Mac中方便的安装软件或者卸载软件,可以说Homebrew就是MAC下的apt-get、yum神器 安装很简单,打开终端,直接输入命令即可,具体使用此处不提,可取官网参看文档 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装 Git Xcode中就自带Git,如果你是一名iOS Developer ,直接安装Xcode即可. 在终端中,输入git,会显示相关的命令,按需使用即可 安装 Zsh 自动安装 1curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh 手动安装 123456789// 1. 克隆到本地仓库git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh// 2. (可选)对本地已有文件备份~/.zshrc filecp ~/.zshrc ~/.zshrc.orig// 3. 利用提供的模板对zsh进行配置cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc// 4. 设置zsh为默认终端chsh -s /bin/zsh// 5. 重启你的终端设备 CocoaPods安装和使用 CocoaPods是iOS最常用的第三方类库管理工具，绝大部分有名的开源类库都支持CocoaPods。 CocoaPods是用Ruby实现的，要想使用它首先需要有Ruby的环境。幸运的是OS X系统默认已经可以运行Ruby了，因此我们只需执行以下命令： 123sudo gem install cocoapods// 或者sudo gem install -n/user/local/bin cocoapods 由于某些原因，执行时会出现下面的错误提示： 1ERROR: Could not find a valid gem 'cocoapods' (&gt;= 0), here is why: Unable to download data from https://rubygems.org/ - Errno::EPIPE: Broken pipe - SSL_connect (https://rubygems.org/latest_specs.4.8.gz) 当你使用代理后如果还是很慢，可以用淘宝的RubyGems镜像来代替官方版本，执行以下命令： 1234$ gem sources -l$ gem sources --remove https://rubygems.org/ $ gem sources -a https://ruby.taobao.org/ $ gem sources -l 将代理换回国内的淘宝后,重新执行一遍安装命令 1sudo gem install cocoapods 安装成功后，接着执行命令 1pod setup 如果Ruby环境不够新，可能需要更新以下： 1sudo gem update --system 然后利用vim打开Podfile文件编辑，加入你想要使用的类库，格式如下： 12345platform :ios, &apos;8.0&apos;use_frameworks!target &apos;Test&apos; do pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos; end 注意iOS8.0之后，可以增加的动态库了（以前只能是静态库的），为了匹配动态库，增加了 1use_frameworks! 最后执行安装命令 1[!] From now on use `Sample0814.xcworkspace`. 当终端出现类似下面的提示后，就代表成功了： 1pod install P.s.1 上面的每一步都有可能出现问题，但大部分问题都是因为大局域网的原因，用一个网速稳定的境外VPN可破。 P.s.2 如果上面因为权限问题安装失败，必须每次都要删除 1rm -rf /Users/loginnanme/Library/Caches/CocoaPods/ 因为这个缓存中会存下你的github的东西，造成每次都调用上次权限问题的缓存。 P.s.3 关于Podfile文件编辑时，第三方库版本号的各种写法： 123456789pod ‘AFNetworking’ //不显式指定依赖库版本，表示每次都获取最新版本 pod ‘AFNetworking’, ‘2.0’ //只使用2.0版本 pod ‘AFNetworking’, ‘&gt;2.0′ //使用高于2.0的版本pod ‘AFNetworking’, ‘&gt;=2.0′ //使用大于或等于2.0的版本 pod ‘AFNetworking’, ‘&lt;2.0′ //使用小于2.0的版本 pod ‘AFNetworking’, ‘&lt;=2.0′ //使用小于或等于2.0的版本 pod ‘AFNetworking’, ‘~&gt;0.1.2′ //使用大于等于0.1.2但小于0.2的版本，相当于&gt;=0.1.2并且&lt;0.2.0 pod ‘AFNetworking’, ‘~&gt;0.1′ //使用大于等于0.1但小于1.0的版本 pod ‘AFNetworking’, ‘~&gt;0′ //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本 再执行 1pod setup 的时候,可能会比较慢,这时候不要慌,可以通过 123cd .~/cocoapods 之后 du -sh 查看当前的安装进度 如果Mac自带的Ruby版本不够新,可以参考我的另一篇文章http://www.jianshu.com/p/2bc92a0e1b83 在按照步骤执行的过程中遇到任何问题希望大家多多交流","tags":[]}]